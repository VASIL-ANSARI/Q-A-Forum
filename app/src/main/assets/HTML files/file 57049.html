<p>If you need to query using the properties of your context (<code>context.TableName</code>), then <strong>NO</strong>.</p>

<p>You need to have the classes generated in some place, either automatically or manually (Entity Framework Code First Approach).</p>

<p>But there is no magic that lets the context have all your tables without a generated class file(s) [<strong>which is part of the dbml in your case</strong>]</p>

<p>However, you can create your own classes and use the <code>TableAttribute</code>. This is you manually replicating what the dbml is doing. Check this <a href="https://social.msdn.microsoft.com/Forums/en-US/73c48143-4def-43a2-a4cb-4a841ce126c8/linq-without-dbml-files?forum=linqtosql" rel="nofollow">link</a> for more.</p>

<p>Some example from the above link:</p>

<pre><code>[Table] 
public class Customer
{
   [Column(IsPrimaryKey=true)]  
   public int ID;
   [Column]                     
   public string Name;
}

public class DemoDataContext : DataContext
{
  public DemoDataContext (string cxString) : base (cxString) { }

  public Table&lt;Customer&gt; Customers { get { return GetTable&lt;Customer&gt;(); } }
  public Table&lt;Purchase&gt; Purchases { get { return GetTable&lt;Purchase&gt;(); } }
}
</code></pre>

<p>Usage:</p>

<pre><code>var db = new DataContext();
var customers = db.GetTable&lt;Customer&gt;();
var query = customers.Where (c =&gt; c.Name.StartsWith ("a"));
</code></pre>
