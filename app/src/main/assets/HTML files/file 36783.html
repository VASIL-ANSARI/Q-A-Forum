<p>If you wanted to make SWIG read boost/preprocessor.hpp you'd do that with:</p>

<pre><code>%module minimal
%{
#include "minimal.h"
%}
%include &lt;boost/preprocessor.hpp&gt;
%include "minimal.h"
</code></pre>

<p>Since by default SWIG doesn't follow <code>#include</code> directives. (You could also use <code>-includeall</code> to make it follow them instead). In this case though I think making the SWIG preprocessor make any kind of sense of the crazy magic that the Boost preprocessor library uses is a lost cause. </p>

<p>Instead though we can try to get something with equally nice, but "Pythonic" syntax instead. In esscence what we're going to do is write a totally different version of <code>DEFINE_ENUM_WITH_STRING_CONVERSIONS</code> for SWIG wrappers only. It will be compatible with the definitions seen by C++ though.</p>

<p>To do this I'm going to start by splitting your file minimal.h into two files. One with the macro definition and one that uses it. (We could have done this different ways, for example by wrapping the macro definitions with <code>#ifndef DEFINE_ENUM_WITH_STRING_CONVERSIONS</code> or <code>#ifndef SWIG</code>, which would be equally valid solutions).</p>

<p>Thus we now have enum.hh:</p>

<pre><code>#ifndef ENUM_H
#define ENUM_H
#include &lt;boost/preprocessor.hpp&gt;

//Found this here: http://stackoverflow.com/questions/5093460/how-to-convert-an-enum-type-variable-to-a-string
#define X_DEFINE_ENUM_WITH_STRING_CONVERSIONS_TOSTRING_CASE(r, data, elem)    \
    case elem : return BOOST_PP_STRINGIZE(elem);

#define DEFINE_ENUM_WITH_STRING_CONVERSIONS(name, enumerators)                \
    enum name {                                                               \
        BOOST_PP_SEQ_ENUM(enumerators)                                        \
    };                                                                        \
                                                                              \
    inline const char* ToString(name v)                                       \
    {                                                                         \
        switch (v)                                                            \
        {                                                                     \
            BOOST_PP_SEQ_FOR_EACH(                                            \
                X_DEFINE_ENUM_WITH_STRING_CONVERSIONS_TOSTRING_CASE,          \
                name,                                                         \
                enumerators                                                   \
            )                                                                 \
            default: return "[Unknown " BOOST_PP_STRINGIZE(name) "]";         \
        }                                                                     \
    }
#endif
</code></pre>

<p>And minimal.h:</p>

<pre><code>#ifndef MINIMAL_H
#define MINIMAL_H
#include "enum.h"

DEFINE_ENUM_WITH_STRING_CONVERSIONS(my_enum, (A)(B))
#endif
</code></pre>

<p>So your minimal.cpp continues to work as before, but now we can write a SWIG module that at least compiles, even if it doesn't do anything useful yet:</p>

<pre><code>%module minimal
%{
#include "minimal.h"
%}
%define DEFINE_ENUM_WITH_STRING_CONVERSIONS(name,enumerators)
%enddef
%include "minimal.h"
</code></pre>

<p>This currently has a stub, SWIG specific macro that we're going to fill out. It's a little ugly how I've done this, simply because I'm trying to avoid changing the way the existing macro is defined/used at all.</p>

<p>What I produced as a starting point is another file, enum.i:</p>

<pre class="lang-cpp prettyprint-override"><code>%include &lt;std_vector.i&gt;
%include &lt;std_string.i&gt;

%{
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
%}

%define DEFINE_ENUM_WITH_STRING_CONVERSIONS(name,enumerators)
%{
  typedef std::tuple&lt;name,std::string&gt; name ## _entry;
  struct name ## _helper {
    std::vector&lt;name ## _entry&gt; list;
    name ## _helper(const name value) {
      list.push_back(std::make_tuple(value,ToString(value)));
    }
    name ## _helper operator()(const name value) {
      list.push_back(std::make_tuple(value,ToString(value)));
      return *this;
    }
  };

  static const std::vector&lt;name ## _entry&gt; name ## _list = name ## _helper enumerators . list;
%}

struct name ## _entry {
  %extend {
    const unsigned long value {
      return std::get&lt;0&gt;(*$self);
    }
    const std::string&amp; label {
      return std::get&lt;1&gt;(*$self);
    }
  }
};

%template(name ## vec) std::vector&lt;name ## _entry&gt;;

const std::vector&lt;name ## _entry&gt; name ## _list;

%enddef
</code></pre>

<p>Such that minimal.i just needs to become:</p>

<pre><code>%module minimal

%{
#include "minimal.h"
%}

%include "enum.i"
%include "minimal.h"
</code></pre>

<p>All that macro does is take the value of <code>enumerators</code>, which is going to be something like <code>(A)(B)</code> and generate some code that's completely standard (if quirky) C++ that expands this into a <code>std::vector&lt;std::tuple&lt;my_enum,std::string&gt;&gt;</code>. That's done by mapping the first enum member onto a constructor call, and the rest onto an overloaded <code>operator()</code>. We use the <code>ToString()</code> supplied by enum.h to find the string representation. Finally our macro has enough information to wrap the vector of tuples in a way which makes sense from within Python. </p>

<p>With this in place we can do something like:</p>

<pre class="lang-py prettyprint-override"><code>import minimal
print ", ".join(("%s(%d)" % (x.label,x.value) for x in minimal.my_enum_list))
</code></pre>

<p>Which, when compiled and run gives:</p>

<pre class="lang-none prettyprint-override"><code>A(0), B(1)
</code></pre>

<p>I.e. enough to start writing Python code that's aware of both the label and the value of a C++ enum.</p>

<p>But let's not stop there! Why did I deliberately call the resulting vector <code>my_enum_list</code> instead of just <code>my_enum</code>? Because there's more we can do now.</p>

<p>Python 2.7 doesn't have any default "enum-ish", but that doesn't prevent us from wrapping this as something both Pythonic and natural to people who know about enums. I made my Python 2.7 enum support by reading <a href="http://stackoverflow.com/a/1695250/168175">this other answer</a>. To start with I added some generic enum support routines to the file using <code>%pythoncode</code>, (labelled #1 in final source) but outside the SWIG macro since there's no need to vary it. I also added a <code>%pythoncode</code> inside the SWIG macro (labelled #2) that invokes this once per actual enum. In order to make this work I had to convert the <code>const std::vector</code> from the previous version into a function so that it was accessible in the right part of the generated Python. Finally I had to show SWIG a forward declaration of the real enum, in order to persuade it to actually accept that as an argument to functions. The final result is:</p>

<pre class="lang-cpp prettyprint-override"><code>%include &lt;std_vector.i&gt;
%include &lt;std_string.i&gt;

%{
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
%}

// #1
%pythoncode %{
class EnumValue(int):
  def __new__(cls,v,l):
    result = super(EnumValue,cls).__new__(cls,v)
    result._value = l
    return result
  def __str__(self):
    return self._value

def make_enum(name,enums):
    return type(name, (), enums)
%}

%define DEFINE_ENUM_WITH_STRING_CONVERSIONS(name,enumerators)
%{
  typedef std::tuple&lt;name,std::string&gt; name ## _entry;
  struct name ## _helper {
    std::vector&lt;name ## _entry&gt; list;
    name ## _helper(const name value) {
      list.push_back(std::make_tuple(value,ToString(value)));
    }
    name ## _helper operator()(const name value) {
      list.push_back(std::make_tuple(value,ToString(value)));
      return *this;
    }
  };

  static const std::vector&lt;name ## _entry&gt; name ## _list() {
    return name ## _helper enumerators . list;
  }
%}

struct name ## _entry {
  %extend {
    const unsigned long value {
      return std::get&lt;0&gt;(*$self);
    }
    const std::string&amp; label {
      return std::get&lt;1&gt;(*$self);
    }
  }
};

%template(name ## vec) std::vector&lt;name ## _entry&gt;;

const std::vector&lt;name ## _entry&gt; name ## _list();

// #2
%pythoncode %{
  name = make_enum('name', {x.label: EnumValue(x.value, x.label) for x in name ## _list()})
%}

enum name;

%enddef
</code></pre>

<p>I added a function to minimal.i to prove it really does work:</p>

<pre class="lang-cpp prettyprint-override"><code>%module minimal

%{
#include "minimal.h"
%}

%include "enum.i"
%include "minimal.h"

%inline %{
  void foo(const my_enum&amp; v) {
    std::cerr &lt;&lt; "GOT: " &lt;&lt; v &lt;&lt; "\n";
  }
%}
</code></pre>

<p>And finally test it with:</p>

<pre class="lang-py prettyprint-override"><code>import minimal
print minimal.my_enum
print minimal.my_enum.A
print minimal.my_enum.B

minimal.foo(minimal.my_enum.B)
</code></pre>

<p>Which you'll be pleased to see worked and resulted in:</p>

<pre class="lang-none prettyprint-override"><code>&lt;class 'minimal.my_enum'&gt;
A
B
GOT: 1
</code></pre>

<p>If you're using Python 3 there's a possibly nicer way to <a href="https://docs.python.org/3/library/enum.html#module-enum" rel="nofollow">represent enums</a>, but I'll leave that as an exercise for the reader for now. You can obviously tweak the Python 2.7 fake enums to your taste as well.</p>
