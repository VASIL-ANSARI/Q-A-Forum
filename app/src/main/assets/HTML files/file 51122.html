<p>Other constructs exist to solve certain problems. They can</p>

<ul>
<li>improve performance </li>
<li>avoid deadlocks</li>
<li>enable higher-level concurrency abstractions that would otherwise require very coarse-grained locking (of course you could also call that "improve performance")</li>
</ul>

<p>A simple example for improving performance is a read-write-lock where a data-structure is safe to use by multiple threads as long as they only read from it. Only writers will have to acquire a non-shared lock.</p>

<p>Copy-on-Write / Immutable data structures / Snapshotting can allow one part of the application to work on some slightly outdated set of data, e.g. for reporting, without any locking and thus without impeding progress of other parts of an application.</p>

<p>Sufficiently complex code where synchronized methods call other code that also uses locks may eventually lead to code paths where locks are not taken in the same order, which is a recipe for deadlocks. Optimistic schemes (either try-lock or read-modify-conditional-update-or-retry) may be able to handle such situations more gracefully by having an error path that can notify a different layer that it has to retry.</p>
