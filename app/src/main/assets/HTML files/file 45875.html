<p><code>(state.PC)/4</code> makes sense to get the array index of the instruction. However, it does not make sense as an index into the register file.</p>

<p>You actually have to decode the <em>instruction</em>, which you just fetched in the IF stage. The bitfields in the instruction index into the register file. The immediate obviously doesn't come from the register file, it comes from the instruction, because that's what immediate means.</p>

<p>The instruction also shouldn't be re-fetched (as happens in <code>newState.IDEX.instr = state.instMem[(state.PC)/4];</code>), because you may need to kill it (a branch has to kill at least one instruction that is already in the pipeline but turns out to be there incorrectly, two if you don't have the delay slot).</p>

<p>As a general tip, if I were you I'd look at the pipeline diagram in any book that covers the classic RISC pipeline, for example Patterson &amp; Hennessy Computer Organization Design.</p>

<p>I have an example here, made partly by me (based on previously existing architectures by the University of Amsterdam) in SIM-PL (which is also from UvA).</p>

<p><img src="http://i.stack.imgur.com/toHRn.png" alt="pipeline"></p>

<p>You can see here that the ID stage doesn't even use PC. It just passes it on to the EX stage, which calculates the branch target.</p>
