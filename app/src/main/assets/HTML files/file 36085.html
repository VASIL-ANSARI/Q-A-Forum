<p>This topic is covered in <a href="http://stackoverflow.com/questions/3168484/pendingintent-works-correctly-for-the-first-notification-but-incorrectly-for-the?rq=1">an existing question</a></p>

<p>Since the points that will solve this problem and similar problems I have had, are spread around a bit in that topic, here is my two point cheat sheet:</p>

<p>Point 1: use code like the following to create a pending intent. The choice of flags in the last argument is important:</p>

<pre><code>PendingIntent pIntent = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
</code></pre>

<p>Point 2: pending intents are stored in a global system table, and only certain parts of the intent they are created from are part of the "key" that is used to look things up in this table. Extras are not part of the key, so if you want two intents to map to two different pending intents, make sure they are different in some other way, for example having different actions, data, or types.</p>

<p>This example changes the action:</p>

<pre><code>Intent intent = new Intent(this, MainActivity.class);
intent.putExtra("whattodo", "showmessage");
// add this:
intent.setAction("showmessage");
</code></pre>

<p>(The action can be anything as long as it is different than what you use with the same class elsewhere.
)</p>

<p>There is a good explanation in the <a href="https://developer.android.com/reference/android/app/PendingIntent.html" rel="nofollow">latest version of the Javadoc for pending intents.</a>, especially this quote I pulled out:</p>

<blockquote>
  <p>... it is important to know when two Intents are considered to be the same for purposes of retrieving a PendingIntent. A common mistake people make is to create multiple PendingIntent objects with Intents that only vary in their "extra" contents, expecting to get a different PendingIntent each time. This does not happen. The parts of the Intent that are used for matching are the same ones defined by Intent.filterEquals.</p>
</blockquote>
