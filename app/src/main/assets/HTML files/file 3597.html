<p>Applying a transformation to the CGPath and test against a point, is equivalent to applying the <em>inverse</em> transformation to the point.</p>

<p>Therefore, you can use</p>

<pre><code>CGPoint adjusted_point = CGPointMake(location.x - center.x, location.y - center.y);
if (CGPathContainsPoint(myPath, NULL, adjusted_point, YES)) 
</code></pre>

<p>But <code>CGPathContainsPoint</code> already takes a <code>CGAffineTransform</code> parameter (which you have <code>NULL</code>-ed it), so you can also use</p>

<pre><code>CGAffineTransform transf = CGAffineTransformMakeTranslation(-center.x, -center.y);
if (CGPathContainsPoint(myPath, &amp;transf, location, YES)) 
</code></pre>

<hr>

<p>If you are drawing, instead of changing the path, you can change the CTM in your drawing code directly. </p>

<pre><code>CGContextSaveGState(c);
CGContextTranslateCTM(c, center.x, center.y);
// draw your path
CGContextRestoreGState(c);
</code></pre>

<p>Use a <code>CAShapeLayer</code> if you need performance.</p>
