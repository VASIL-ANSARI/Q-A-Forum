<p>This comes about as a result of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1558">CWG Issue 1558</a>, and is now considered a bug in gcc (specifically <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64395">64395</a> - currently fixed). The idea behind the issue is that since you don't actually use the template parameters here:</p>

<pre><code>template &lt;typename...&gt; using void_t = void;
</code></pre>

<p>there's no substitution failure regardless of what types or expressions you try to pass in. </p>

<p>Thankfully, there's an easy workaround that doesn't involve upgrading your compiler. We can rewrite <code>void_t</code> to actually use its parameter pack, thereby triggering the substitution failure:</p>

<pre><code>namespace void_details {
    template &lt;class... &gt;
    struct make_void { using type = void; };
}

template &lt;class... T&gt; using void_t = typename void_details ::make_void&lt;T...&gt;::type;
</code></pre>

<p>That'll make your example do the right thing across all the gcc versions I tried. </p>
