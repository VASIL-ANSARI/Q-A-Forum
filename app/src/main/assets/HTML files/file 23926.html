<p>Simply because the listener callback or even the constructor itself is defined does not mean that it is invoked at the time it is defined. In fact, the constructor is just a function. Like any function declaration, it defines what will happen when invoked. If we don't invoke it, nothing happens. In the case of a constructor, it is invoked when we create a new instance of it. Eventually, your app will invoke the constructor and here is what will happen at that time:</p>

<ol>
<li><p>Using the special <code>new</code> keyword, we tell the JavaScript interpreter to invoke the constructor function and provide it with a new object inside of it.</p></li>
<li><p>The interpreter sets <code>this</code> inside the constructor to be a reference in memory to that new object.</p></li>
<li><p>Next, an event listener is created on the <code>window</code>. We pass a callback function to that listener which is a closure over the <code>this</code> object, making our current <code>this</code> reference available. But that callback does not execute yet and will not until the window's <code>load</code> event fires.</p></li>
<li><p>Imagine that it did fire immediately, (i.e. was not actually a callback) we would have a problem. Even though <code>this</code> exists at that time and actually already inherits from <code>Constructor.prototype</code>, it has no such method <code>_updateFilter</code>. The interpreter would then check up the prototype chain and see that there is no such function on <code>Constructor.prototype</code> either. It would continue up the chain, not find the function, and would throw an error. But remember, the callback does not fire yet.</p></li>
<li><p>Back to what actually does happen: Next we extend <code>Constructor</code>'s prototype with the new method <code>_updateFilter</code>.</p></li>
<li><p>So eventually the window's <code>load</code> event does fire and the callback really is called. The interpreter checks to see if <code>_updateFilter</code> exists on <code>this</code>, sees that it does not, and then checks up its prototype chain. Now it finds that function does exist on <code>Constructor.prototype</code>, and runs that code.</p></li>
</ol>
