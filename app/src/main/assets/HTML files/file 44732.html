<p>This is a bug that essentially reduces to GCC complaining about not-explicitly-initialized <code>const</code> data members in aggregate initialization. E.g.</p>

<pre><code>struct {const int i;} bar = {};
</code></pre>

<p><a href="http://coliru.stacked-crooked.com/a/b47f7fcb71c5925a" rel="nofollow">Fails</a> as there is no initializer-clause for <code>i</code> in <code>bar</code>'s initializer.  However, the standard specifies in <code>รยง8.5.1/7</code> that</p>

<blockquote>
  <p>If there are fewer <em>initializer-clauses</em> in the list than there are
  members in the aggregate, then <strong>each member not explicitly initialized
  shall be initialized</strong> from its <em>brace-or-equal-initializer</em> or, if there
  is no <em>brace-or-equal-initializer</em>, <strong>from an empty initializer list
  (8.5.4)</strong>.</p>
</blockquote>

<p>Thus the code initializes <code>i</code> (as if by <code>= {}</code>), and GCCs complaint is incorrect.  </p>

<p>In fact, this bug has already been reported four years ago as <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=49132" rel="nofollow"><strong>#49132</strong></a>, and is fixed in GCC 5. </p>
