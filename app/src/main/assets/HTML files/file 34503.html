<p>The same way it knows it needs to update anything else - dirty checking.</p>

<p>Angular is completely agnostic to the fact it is binding over a function or a value. It works by keeping an array of watchers, and checking those watchers. </p>

<p>The important thing here is that Angular watches the expressions you bind to, and not the scope objects themselves.</p>

<p>Let's look at a <em>very</em> simplistic version of what's happening.</p>

<p>So something like (simplistic):</p>

<pre><code> {{main.getSum()}}
</code></pre>

<p>Gets 'compiled' to (something like):</p>

<pre><code>var watcher = function(){ return main.getSum(); }
</code></pre>

<p>In turn, it gets added to an array of watchers. Which do something like:</p>

<pre><code> // run this 'digest' when any property is 'dirty', for example after calling $apply
 while(anyDirtyWatchers){
     // go through all watchers, for instance
     var newValue = watcher();
     if(newValue !== oldValue){
        anyDirtyWatchers = true; // keep digesting, in practice this has a limited number
        oldValue = newValue;     // of iterations
     }
 }
</code></pre>

<p>So, as you can see, there are no issues with binding to a function value (nor there should be any)</p>

<p>This was a very simplistic overview of what's happening. I hope you got the overall idea though.</p>
