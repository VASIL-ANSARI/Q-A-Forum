<p>The <code>ContextMenu</code> being separate from the visual tree, you cannot bind with and element outside of it.</p>

<p>If you check your output window, you should have a message saying that it can't find the object "Lst"</p>

<p>A common and easy workaround would be to manually set the DataContext in code-behind (note: this is not breaking MVVM at all. You are just performing a pure UI operation of linking DataContexts together):</p>

<p>In your Xaml:</p>

<pre><code>&lt;Button.ContextMenu&gt;
                        &lt;ContextMenu Opened="OnContextMenuOpened"&gt;                                
                            &lt;MenuItem Header="Send2" Command="{Binding ElementName=Lst, Path=DataContext.SaveCommand}" /&gt;
                        &lt;/ContextMenu&gt;
                    &lt;/Button.ContextMenu&gt;
</code></pre>

<p>In code-behind:</p>

<pre><code>public void OnContextMenuOpened(object sender, RoutedEventArgs args)
{
    (sender as ContextMenu).DataContext = Lst.DataContext;
}
</code></pre>

<p>You are therefore linking the <code>DataContext</code> every time the <code>ContextMenu</code> is opened (so if Lst's <code>DataContext</code> changes, your ContextMenu will as well)</p>

<p>Alternatively (cleaner if you are bound to use it a lot of times), get the <code>BindingProxy</code> from this article: <a href="http://tomlev2.wordpress.com/2011/03/21/wpf-how-to-bind-to-data-when-the-datacontext-is-not-inherited/" rel="nofollow">http://tomlev2.wordpress.com/2011/03/21/wpf-how-to-bind-to-data-when-the-datacontext-is-not-inherited/</a>  and it'll do the trick!</p>
