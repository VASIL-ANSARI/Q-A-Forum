<p>This part:</p>

<pre><code>collection: Backbone.Collection.extend({
    model: this.model
})
</code></pre>

<p>will be executed when you're building <code>ToDoApp</code> but <code>this</code> won't be <code>ToDoApp</code> at that time, <code>this</code> will probably be <code>window</code> and <code>window</code> won't have a <code>model</code> property. The result is that you're actually saying:</p>

<pre><code>collection: Backbone.Collection.extend({
    model: undefined
})
</code></pre>

<p>Similar problems happen here:</p>

<pre><code>view: Backbone.View.extend({
    model: new this.model(),
    tagName: 'li'
})
</code></pre>

<p>The easiest thing to do is build <code>ToDoApp</code> piece by piece:</p>

<pre><code>var ToDoApp = { };
ToDoApp.model = Backbone.Model.extend({ ... });
ToDoApp.collection = Backbone.Collection.extend({
    model: ToDoApp.model
});
ToDoApp.view = Backbone.View.extend({
    tagName: 'li'
});
</code></pre>

<p>Then you'd create the model for you view instance when you create the view instance:</p>

<pre><code>var model = new ToDoApp.model();
var view  = new ToDoApp.view({ model: model });
</code></pre>

<p>Also, using names like <code>ToDoApp.Model</code>, <code>ToDoApp.Collection</code>, and <code>ToDoApp.View</code> would be more common for your "classes".</p>
