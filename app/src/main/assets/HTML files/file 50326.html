<p>You have enums <code>MaritalStatus</code> and <code>Gender</code>. At the same time, you have properties named <code>MaritalStatus</code> and <code>Gender</code>. You need to avoid this.</p>

<p>Here: </p>

<pre><code>if (Gender == Gender.M)
if (MaritalStatus == MaritalStatus.Married)
</code></pre>

<p>the syntax is incorrect since <code>Gender</code> and <code>MaritalStatus</code> are recognized as variables, but not as type.<br>
Moreover, you need to use <code>.Value</code> to access a value of <code>Nullable</code>.</p>

<p>So, you can explicitly specify the namespace:</p>

<pre><code>if (Gender.Value == YourNamespace.Gender.M)
if (MaritalStatus.Value == YourNamespace.MaritalStatus.Married)
</code></pre>

<p>but I strongly recommend to rename your enums to <code>GenderEnum</code> and <code>MaritalStatusEnum</code>.</p>

<h2>Why does it happen?</h2>

<p>This problem is simply reproducable here:</p>

<pre><code>enum SameName { Value }
class Tester
{
   void Method1() {
      SameName SameName;
      SameName test = SameName.Value; // Works!
   }
   void Method2() {
      string SameName;
      SameName test = SameName.Value; // Doesn't work! Expects string method Value
   }
}
</code></pre>

<p>In <a href="http://stackoverflow.com/a/15976488/3218692">this answer</a> Eric Lippert has described the reason of this:</p>

<blockquote>
  <p>C# was designed to be robust in the face of a property named the same as its type because this is common:</p>
</blockquote>

<pre><code>class Shape
{
    public Color Color { get; set; }
    ...
</code></pre>

<blockquote>
  <p>If you have a type Color, it is very common to have a property also called Color, and there's no good way to rename either of them. Therefore C# was designed to handle this situation reasonably elegantly. </p>
</blockquote>

<p>So, if your variable is of type <code>Enum</code>, then it refers to the enum member; else - it refers to variable. <code>Enum?</code> belongs to "else".</p>
