<p>Your code above protects you from setting the array concurrently, or getting the array while another is setting it. Since it is a non-mutable array, this protects the array itself just fine. </p>

<p>However, if by "the array will change" you mean you'll be editing the items inside the array, you could still have some problems. For example, if the array was filled with NSMutableStrings, and you had a thread that ran:</p>

<pre><code>NSMutableString *foo = [myObject.myArray objectAtIndex:0];
[foo appendString:@"foo"];
</code></pre>

<p>and another that ran</p>

<pre><code>NSMutableString *bar = [myObject.myArray objectAtIndex:0];
[bar appendString:@"bar"];
</code></pre>

<p>The access to the array would be safe (one thread would have to wait for the other to access it), however, access to the foo/bar pointer (which is the same) would not be, since both calls to 'appendString' are outside of the @synchronized block.</p>

<p>If this is how your array will change, you'll need to synchronize these points of access as well. Either with more @synchronized blocks, or other types of locks. See <a href="http://developer.apple.com/mac/library/DOCUMENTATION/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW16">Using Locks</a></p>
