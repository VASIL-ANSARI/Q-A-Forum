<p>Just make <code>GetType</code> and <code>SetType</code> independent template parameters, and let the compiler worry about whether they're convertible.</p>

<p>eg. this:</p>

<pre><code>template&lt; class C, typename T, typename U &gt;
void addVarCB(C * _this, const std::string &amp;name, 
    T(C::*getter)(void) const, U(C::*setter)(const T&amp;), const std::string &amp;def);
</code></pre>

<p>requires that <code>setter</code>'s argument is a const reference to whatever <code>getter</code> returns. However, this:</p>

<pre><code>template &lt;typename Class, typename GetResult, typename SetArg, typename SetResult&gt;
void addVarCB(Class *instance, std::string const&amp; name,
              GetResult (Class::*getter)() const,
              SetResult (Class::*setter)(SetArg),
              std::string const &amp;def);
</code></pre>

<p>allows the <code>setter</code> argument and the <code>getter</code> return type to be different. Now, assuming you want to pass one to the other, it'll only compile if they're convertible (or you could use C++11 or Boost.TypeTraits <code>is_convertible</code> to assert this explicitly).</p>

<hr>

<p>... if that <em>won't</em> work, it would probably help if you show what goes inside <code>addVarCB</code>, or explain what you're trying to achieve.</p>
