<p>If you don't terminate a a C-style string with a null character there is no way to determine where the string ends. Thus, you'll need to terminate the strings.</p>

<p>I would personally read the data into <code>std::string</code> objects:</p>

<pre><code>std::string first, last, etc;
while (std::getline(readFromFile, first, '|')
    &amp;&amp; std::getline(readFromFile, last, '|')
    &amp;&amp; std::getline(readFromFile, etc)) {
    // do something with the input
}
</code></pre>

<p><code>std::endl</code> is a manipulator implemented as a function template. You can't compare a <code>char</code> with that. There is also hardly ever a reason to use <code>std::endl</code> because it flushes the stream after adding a newline which makes writing really slow. You probably meant to compare to a newline character, i.e., to <code>'\n'</code>. However, since you read the string with <code>std::getline()</code> the line break character will already be removed! You need to make sure you don't access more than <code>temp.size()</code> characters otherwise.</p>

<p>Your record also contains arrays of strings rather than arrays of characters and you assign individual <code>char</code>s to them. You either wanted to yse <code>char something[SIZE]</code> or you'd store strings! </p>
