<p>It is undefined behavior.</p>

<p>Section 6.2.7.2 of C99 states:</p>

<blockquote>
  <p>All declarations that refer to the same object or function shall have
  compatible type; otherwise, the behavior is undefined.</p>
</blockquote>

<p><strong>NOTE</strong>: As mentioned in the comments below, the important part here is <em>[...] that refer to the same object [...]</em>, which is further defined in 6.2.2:</p>

<blockquote>
  <p>In the set of translation units and libraries that constitutes an
  entire program, each declaration of a particular identifier with
  external linkage denotes the same object or function.</p>
</blockquote>

<p>About the type compatibility rules for array types, section 6.7.5.2.4 of C99 clarifies what it means for two array types to be compatible:</p>

<blockquote>
  <p>For two array types to be compatible, both shall have compatible
  element types, and if both size specifiers are present, and are
  integer constant expressions, <strong>then both size specifiers shall have the
  same constant value</strong>. If the two array types are used in a context
  which requires them to be compatible, it is undefined behavior if the
  two size specifiers evaluate to unequal values.</p>
</blockquote>

<p>(Emphasis mine)</p>

<p>In the real world, as long as you stick to 1D arrays, it is probably harmless, because there is no bounds checking and the address of the first element remains the same regardless of the size specifier, but note that the <code>sizeof</code> operator will return different values in each source file (opening a wonderful opportunity to write buggy code).</p>

<p>Things start to get really ugly if you decide to extrapolate on this example and declare multidimensional arrays with different dimension sizes, because the offset of each element in the array will not match with the real dimensions any more.</p>
