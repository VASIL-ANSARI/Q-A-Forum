<p>Singleton works on 3 ingredients:</p>

<ul>
<li>private reference</li>
<li>private constructor</li>
<li>public creational function ("instance", "getInstance" etc.)</li>
</ul>

<p>The trick goes like this:</p>

<ol>
<li>call the creational function</li>
<li>the creational function checks if the pointer is null</li>
<li>if the pointer is null - create new instance on it</li>
<li>return the pointer</li>
</ol>

<p>in your snippet the isntance is not held by a pointer, but is a full-standing object. if you change instance to be from the type 
<code>Properties*</code> and <code>getInstance()</code> to return  <code>Properties*</code> (or <code>Properties&amp;</code>) I guess the problem will be solved</p>

<p>Currently, at the verge of 2016, the correct way to write a singletone is as follows:</p>

<pre><code>class Singleton{

private:
  static std::unique_ptr&lt;Singleton&gt; instance;
  static std::once_flag onceFlag;
  Singleton();

public:
  static Singleton&amp; getInstance(){
    std::call_once(onceFlag,[&amp;]{
       instance = std::unique_ptr&lt;Singleton&gt;(new Singleton());    
    });
    return *instance;
  }

};
</code></pre>
