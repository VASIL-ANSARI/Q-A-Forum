<blockquote>
  <p>Now I wonder, is this a bug in the old g++</p>
</blockquote>

<p>No, there is no bug in g++ in this regard.</p>

<blockquote>
  <p>or am I doing it wrong</p>
</blockquote>

<p>Yes. This is explained in the <a href="http://stackoverflow.com/questions/17536570/reading-and-writing-to-the-same-file-using-the-same-fstream">answer</a> that you linked.</p>

<blockquote>
  <blockquote>
    <p>... output shall not be directly followed by input without an intervening call to the fflush function or to a file positioning function (fseek, fsetpos, or rewind), and input shall not be directly followed by output without an intervening call to a file positioning function, unless the input operation encounters end- of-file.</p>
  </blockquote>
</blockquote>

<p>Which is from C standard but made relevant by:</p>

<blockquote>
  <blockquote>
    <p>The restrictions on reading and writing a sequence controlled by an object of class basic_filebuf are the same as for reading and writing with the Standard C library FILEs.</p>
  </blockquote>
</blockquote>

<p>There is a bug, but it is in your code. Your program doesn't meet the requirements laid out by the standard.</p>

<blockquote>
  <p>but as I understand, this is a limitation under Windows</p>
</blockquote>

<p>That may possibly be the case, but more generally the limitation is in C++ (and C) specification. Whether a standard library has the limitation has no effect on whether the library is standard compliant. Any code that depends on the non-existence of the limitation is not compliant with the standard.</p>

<blockquote>
  <p>and was [I] just lucky with the modern g++ version</p>
</blockquote>

<p>One might say that you were unlucky. It was a stroke of luck when the program didn't work and you discovered the bug.</p>

<blockquote>
  <p>Second question, why does asking for the current position fix it?</p>
</blockquote>

<p>I doubt that <code>tellg</code> is sufficient to make your program compliant with the standard. So, I would say that it "fixes" the program by chance.</p>

<p>You should probably be using <code>std::flush(fs);</code> instead.</p>

<blockquote>
  <p>this would mean that the NEW version is LESS standard compliant? </p>
</blockquote>

<p>No, both versions of g++ are equally compliant in this regard. Your program isn't.</p>
