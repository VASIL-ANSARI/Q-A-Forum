<p>If you use <code>scheduledTimerWithTimeInterval(...)</code> to create your timer, it will be added to the current runloop with mode <code>NSDefaultRunLoopMode</code>. The timer will not fire while your app is busy with event tracking, i.e. if you scroll around in a UIScrollView or if you do any other interactions with your UI. </p>

<p>You can create a unscheduled NSTimer and add it to the runloop yourself, if you use <code>NSRunLoopCommonModes</code> as mode the timer will fire while you interact with the user interface. </p>

<pre><code>let timer = NSTimer(timeInterval: 1.0, target: self, selector: Selector("timerFired:"), userInfo: nil, repeats: true)
NSRunLoop.currentRunLoop().addTimer(timer, forMode: NSRunLoopCommonModes)
</code></pre>

<hr>

<p>For further information, the question <a href="http://stackoverflow.com/q/7222449/457406">NSDefaultRunLoopMode vs NSRunLoopCommonModes</a> contains a nice explanation about the different runloop modes. </p>
