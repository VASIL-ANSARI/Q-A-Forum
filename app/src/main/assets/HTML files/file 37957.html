<p>I am not sure as to why your code isn't working, but what you can do is on your local machine, create a new file for your minimum example to see if you can do what you want to do</p>

<pre><code>import pdb

for node_num in range(50):
    if node_num == 16:
        print(node_num)
        pdb.set_trace()
</code></pre>

<p>Now running it:</p>

<pre><code>16
&gt; /tmp/tmp.py(3)&lt;module&gt;()
-&gt; for node_num in range(50):
(Pdb) p node_num
16
</code></pre>

<p>As you can see this worked as intended with this trivial example, it's up to you to figure out how to adapt this to your code, and/or figure out what else did you do to your code/environment that prevented that prompt from showing up.</p>

<p>Alternatively, if you have a function that is dying in an exception and you want to know the exact line that caused it, you should use <code>post_mortem</code> instead.  Wrap the problematic section of code with this</p>

<pre><code>try:
    problem_function()
except Exception:  # or the specific exception type thrown
    pdb.post_mortem()
    raise
</code></pre>

<p>What post_mortem would do is dump a break point right at the point where the exception happened (specifically in that stack frame), and so this allows all values to be inspected and then let you continue execution.  However I also put a raise at the end to allow the exception to continue as normal, and this is intended as execution doesn't normally from where it die but just pause at that exception handling block due to the <code>post_mortem</code> call.  Might as well just give up after inspecting what went wrong.  </p>
