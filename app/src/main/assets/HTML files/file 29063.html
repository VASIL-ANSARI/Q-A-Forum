<p>I'm going to use <code>y'</code> to denote the y-position at the end of this time slice and <code>y</code> for the position at the end of the previous time slice, strictly for ease of labeling. This makes the third line of your code:</p>

<pre><code>y' = y + deltaY;
</code></pre>

<p>Let's consider the case in which <code>y'</code> is strictly greater than <code>getHeight()</code>. (The case where they are equal will end up being accounted for automatically, as you  will see below.) A quick drawing of the situation would be something like this:</p>

<pre><code>           _   o  - y
          |    o
          |    o
----------|--------------------- getHeight()
          |    O
 deltaY - |    O
          |    O
          |_   O  - y'
</code></pre>

<p>At some point during the current time slice, the ball hit the floor (at getHeight()). For the remainder of the current time slice, we overshot the floor by the amount:</p>

<pre><code>y' - getHeight()
</code></pre>

<p>We need this remainder to be the amount the ball bounced upward during the current time slice. The actual y-position at the end of the current time slice (neglecting your elasticity constant for the moment) would look like this:</p>

<pre><code>                     _   O  - y''
     _   o  - y     |    O
    |    o          |    O
    |    o          |    O
-------------------------------- getHeight()
</code></pre>

<p>Now, <code>y''</code> is <code>getHeight()</code> minus the amount by which we overshot the floor, which we calculated above:</p>

<pre><code>y'' = getHeight() - (y' - getHeight());
</code></pre>

<p>(You might be tempted to change this to <code>2*getHeight() - y'</code>, but hang on until we get to the end.)</p>

<p>We'll now quickly pull in the case we neglected earler in which <code>y' == getHeight()</code>. As you  can see, <code>y' - getHeight()</code> goes to zero, leaving <code>y'' == getHeight()</code>, just as we need, so there's no extra work to do for this case.</p>

<p>Good, so all we need to do now is take care of the elasticity constant (I assume that's what the 0.9 factor is for, so that the bounce decays over time). We want to apply that to <code>deltaY</code> as you've done, but we also need to apply it to the bounce in the current time slice since it hit the floor:</p>

<pre><code>y'' = getHeight() - 0.9*(y' - getHeight());
</code></pre>

<p>Since we haven't mixed <code>y</code>, <code>y'</code> and <code>y''</code> in the right-hand-side of any of the calculations we can simply replace all of them by <code>y</code> giving us the final <code>if</code> clause (only the last line has been changed):</p>

<pre><code>    if (y &gt;= getHeight()) {
        deltaY = -deltaY;
        deltaY = (int) (deltaY * 0.9);
        y = getHeight() - 0.9*(y - getHeight());
    }
</code></pre>

<p>I'm sure if you draw out your previous solution(s) you'll see where they went wrong. Also, using an int for deltaY seems to me to be asking for trouble. I'd rather use floats for all of the calculations and then round only when drawing. You'll notice that I haven't done any casting on the result for <code>y</code> above, which might be necessary depending on the type of <code>y</code>.</p>
