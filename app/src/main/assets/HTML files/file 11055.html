<p>Your call to <strong>reloadRowsAtIndexPaths</strong>: will cause the table view to reload the given cells and therefore cause the table to no longer have a selected row at that position.  The <strong>cellforRowAtIndexPath</strong> method is a request from the data source to provide a row for the given index path.  If you need to determine if a cell was selected prior to the request, you could store the indexPath of the selected row in a member.  Then check the member in your cellForIndexPathMethod.</p>

<p>The following code sample assumes you are using ARC for memory management.</p>

<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *CellIdentifier = @"Cell";

    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
    if (cell == nil) {
        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier];
    }

    cell.textLabel.text = [NSString stringWithFormat:@"Cell %d_%d", indexPath.section, indexPath.row];

    // Configure the cell...
    if(selectedIndexPath != nil) {
        NSLog(@"Selected section:%d row:%d", selectedIndexPath.section, selectedIndexPath.row);

        //TODO:Provide a custom cell for the selected one.

        //Set the selectedIndexPath to nil now that it has been handled
        selectedIndexPath = nil;
    }

    return cell;
}

#pragma mark - Table view delegate

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    //Store the selected indexPath
    selectedIndexPath = indexPath;

    [tableView reloadRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationNone];
}
</code></pre>
