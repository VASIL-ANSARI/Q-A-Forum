<h2>All is relative.</h2>

<p>In 1D x &amp; canvas center cc = 100. </p>

<p>You draw players <code>gameX + x</code> you draw self at <code>cc==100</code> So if self is 150 and player is 200 you draw player at <code>150+200=350</code> but self is drawn at cc making the player <code>350-cc = 250</code> pixels right of self. The player should be 50 pixel right of self <code>canvas.width/2 + 50</code>. </p>

<p>To fix draw players at the center of canvas (cc or origin) plus difference between self and player. </p>

<pre><code>ctx.drawRect((canvas.width / 2) + (player.x - self.x), ...
</code></pre>

<p><strong>BTW</strong></p>

<p>To make a character array</p>

<pre><code>charArr = "0123456789abcdefghijklmnopqrstuvwxyz.,:;!@#$%^&amp;*()-_[]()&lt;&gt;|".split("");
</code></pre>

<p>Saves you much typing next time you need such an array.</p>

<p>Never rely on data continuity</p>

<p>Sending movement only and relying on each client to maintain correct position is never going to work, miss one packet on one machine and every one will have the wrong view. Send absolute position at time (time stamped) plus current delta. Not as a string but encode into smallest packet you can send. </p>

<p>Use player's last delta to update position if next packet is late. Revert to actual position when packet does arrive. Allow interaction rollback if you get missing packets late. Ie don't kill player if position was guessed from previous delta and new position proves the hit was a miss. </p>

<p>What does now mean?</p>

<p>Remember the speed of light is limited, you update at 30ms (3/100th second) this gives light (@~300,000,000mps) time to move 9,000,000m or 9000km, just enough time to move across a country and back, add packet switching, client processing, response transmission delay, etc, for world wide games expect min ping time 150ms + (or limit game to low ping (local) only) We all have different nows, code multiplayer with that in mind.</p>
