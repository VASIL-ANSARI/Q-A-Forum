<p>I'll assume that </p>

<pre><code>var clB = new B();
</code></pre>

<p>The difference between the <code>Foo</code> and <code>Bar</code> methods is that while <code>Bar</code> uses inheritance and polymorphism to decide what implementation to call, the <code>Foo</code> method hides it's original implementation.</p>

<p>In, a word, <code>A.Foo()</code> and <code>B.Foo()</code> are completely unrelated, they just happen to have the same name. When the compiler sees that a variable of type <code>A</code> invokes <code>Foo</code> it goes in and executes <code>A.Foo()</code>, since the method is not virtual, so it cannot be overriden. Similarly, when it sees a variable of the type <code>B</code> invoking <code>Foo</code> it executes <code>B.Foo()</code>, regardless of the actual type of the instance that is contained in the variable.</p>

<p>On the other hand, the <code>Bar</code> method is defined as virtual, and the inheriting classes can (and are expected to) override it's implementation. So whenever a call is made to <code>Bar</code>, regardless if it is from a variable that is declared as <code>A</code> or <code>B</code>, the method that is actually called must be found as the "latest" implementation in the hierarchy of the calling object itself, with no impact from the type of variable that was used to refer to the object.</p>
