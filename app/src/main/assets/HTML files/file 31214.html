<p>I'd probably use the mediator pattern for this kind of thing. The various controls would register message handlers with the mediator class, one for each type of message they are interested in. Each can also send messages to the mediator when interesting events happen. When the mediator receives a message, it broadcasts it to all registered listeners for that type of message. So, for your case, each instance of the grid control would register with the mediator to receive "TileSelectionChanged" and "TileSetChanged" messages, and the tile set control would use the mediator to broadcast messages when these events occur, passing the relevant data along with the message. In the future, when you implement your tool menu, all you need to do is send a message to the mediator for each menu action, and register a handler for each of the message types in any controls which need to respond to them. </p>

<p>This pattern is, in a way, similar to what you're already doing: the main form is acting as a kind of mediator, listening to events in one control and broadcasting it to other controls which need to be updated. It's not the same, though. The key difference is that unlike a true mediator, your main form is responsible for actively registering for all of the events, which is where maintenance tediousness is introduced. A true mediator is more passive, letting the classes which want to publish messages do so, and routing the messages to any interested listeners. It neither knows nor cares where the message comes from or what it means, it just passes it along. In your current implementation, you have three places that need to change when a new event type is conceived: the originating control, the main form, and the control that ultimately responds to the event. With the mediator pattern, the change is reduced to two locations: the originating control and the responding control.</p>
