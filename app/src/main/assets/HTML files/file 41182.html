<p>The behavior you observe indicates that the hear is <em>already</em> corrupted by the moment you call your <code>malloc</code>. Your <code>malloc</code> call simply <em>detects</em> the corruption, it does not <em>cause</em> it.</p>

<p>One of the easiest ad-hoc tricks to find the source of corruption is to insert an additional <code>malloc</code> call with the same requested memory size (i.e. <code>sizeof(struct OpenFile) * 16</code>) somewhere higher upstream in the code. If it fails there as well, you move that extra call higher upstream. If it doesn't fail, you move it downstream. That way you will eventually be able to zero-in on the exact culprit that corrupts the heap. (This might require some creativity to make sure that that extra <code>malloc</code> call is executed on the proper iterations of various cycles you might have in your code and/or on the proper invocations of the functions, but it is doable.)</p>

<p>Or you can use valgrind for this purpose. Albeit I find it that in some cases the above ad-hoc procedure proves to be a more efficient approach for finding the source of the corruption, if the failure occurs quickly and you work in an environment that supports quick recompilation of the code.</p>
