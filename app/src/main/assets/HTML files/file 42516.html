<p>Interface fields are <code>static</code> and <code>final</code> implicitly. </p>

<p>What you could do is to have an interface method returning <code>Enum&lt;?&gt;</code>, and your classes implementing it. </p>

<p>For instance:</p>

<pre><code>interface Foo {
    public Enum&lt;?&gt; getEnum();
}
class Bar implements Foo {
    enum Blah {
        INSTANCE;
    }

    public Enum&lt;?&gt; getEnum() {
        return Blah.INSTANCE;
    }
}
</code></pre>

<p><strong>Edit</strong></p>

<p>Not completely sure I understand your question update, but here's a solution that will de-couple returning a specific <code>enum</code> instance from an <code>enum</code>, by means of two interfaces.</p>

<p>The example is self-contained in a <code>Main</code> class.</p>

<pre><code>public class Main {

    public static void main(String[] args) {
        System.out.println(new Bar().getEnumField().name());
    }
    static interface IHasEnum {
        public Enum&lt;? extends IMyEnum&gt; getEnumField();
    }
    static interface IMyEnum {
        public Enum&lt;? extends IMyEnum&gt; getField();
    }
    static class Bar implements IHasEnum {
        enum Blah implements IMyEnum {
            DEFAULT_INSTANCE,
            THE_FIELD;
            public Enum&lt;? extends IMyEnum&gt; getField() {
                return THE_FIELD;
            }
        }
        public Enum&lt;? extends IMyEnum&gt; getEnumField() {
            return Blah.DEFAULT_INSTANCE.getField();
        }

    }
}
</code></pre>

<p><strong>Output</strong></p>

<pre><code>THE_FIELD
</code></pre>

<p><strong>Note</strong></p>

<p>The trick here is to add a "default" instance to the enum (<code>DEFAULT_INSTANCE</code>), so the <code>getField</code> method is an instance method, hence overriding the one declared in the <code>IMyEnum</code> interface. </p>

<p>Again, not entirely sure this addresses your issue. </p>
