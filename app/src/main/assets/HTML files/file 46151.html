<p>Refactor the function to separate object creation and object usage.</p>

<p>If this is a method of a class, the trivial solution is to make <code>$obj</code> a class property so you can replace it with a mock.</p>

<p>If you always need a new instance of <code>CalculationObject</code>, the factory pattern can be used.</p>

<h3>Example:</h3>

<pre><code>function testMe ($a, $b)
{
    $obj = $this-&gt;factory-&gt;getNewCalculationObject();
    return $obj-&gt;calcIt ($a, $b);
}
</code></pre>

<p>Then replace <code>$this-&gt;factory</code> with a stub that returns your mock for <code>getNewCalculationObject()</code>.</p>

<p>If this is really a procedural function, not a method, you need to pass the dependency to the function:</p>

<pre><code>function testMe ($a, $b, $factory)
{
    $obj = $factory-&gt;getNewCalculationObject();
    return $obj-&gt;calcIt ($a, $b);
}
</code></pre>

<p>You could use the normal factory by default to make it backwards compatible to your current implementation:</p>

<pre><code>function testMe ($a, $b, $factory = null)
{
    if ($factory === null) {
        $factory = new CalculationObjectFactory();
    }
    $obj = $factory-&gt;getNewCalculationObject();
    return $obj-&gt;calcIt ($a, $b);
}
</code></pre>

<p>If this looks a bit clumsy to you, consider moving the function into a class.</p>
