<blockquote>
  <p>How VLAs are implemented in gcc / VC++ ?</p>
</blockquote>

<p>AFAIK VC++ doesn't implement VLA. It's a C++ compiler and it supports only C89 (no VLA, no restrict). I don't know how gcc implements VLAs but the fastest possible way is to store the pointer to the VLA and its size in the static portion of the stack-frame. This way you can access one of the VLAs with performance of a constant-sized array (it's the last VLA if the stack grows downwards like in x86 (dereference [stack pointer + index*element size + the size of last temporary pushes]), and the first VLA if it grows upwards (dereference [stackframe pointer + offset from stackframe + index*element size])). All the other VLAs will need one more indirection to get their base address from the static portion of the stack. </p>

<p>[ <em>Edit:</em> Also when using VLA the compiler can't omit stack-frame-base pointer, which is redundant otherwise, because all the offsets from the stack pointer can be calculated during compile time. So you have one less free register. &mdash; <em>end edit</em> ]</p>

<blockquote>
  <p>Is the cost really that impressive ?</p>
</blockquote>

<p>Not really. Moreover, if you don't use it, you don't pay for it.</p>

<p>[ <em>Edit:</em> Probably a more correct answer would be: Compared to what? Compared to a heap allocated vector, the access time will be the same but the allocation and deallocation will be faster. &mdash; <em>end edit</em> ]</p>
