<p>The problem is in your <code>increaseStack()</code> function, and it relates to my observation in comments that you keep a lot of redundant data.  Note in particular that the problem occurs immediately after your second stack expansion -- this is no coincidence.</p>

<p>Here is a high-level description of the behavior of your <code>increaseStack()</code> function:</p>

<ol>
<li><p>Record the stack capacity and number of elements, as indicated by the provided element pointer.</p></li>
<li><p>Adjust the element pointer to point to the bottom-most stack element, using the recorded element count.</p></li>
<li><p>Reallocate, choosing a new capacity based on the capacity indicated by the current element pointer (now pointing at the bottom-most element).</p></li>
<li><p>Adjust the stack pointer to point to the element of the reallocated space corresponding to the one that it pointed to on function entry.</p></li>
<li><p>Update the stack capacity recorded in the element pointed to by the stack pointer.</p></li>
</ol>

<p>Study steps 3 and 5 carefully, and consider why your approach would work for the first stack expansion, but not the second.</p>

<p>I suspect I know what your first inclination for a solution will be, but resist it.  Instead, give a thought to how you could design this better.  In particular, what benefit do you get from having a separate <code>iCount</code> and <code>iStackSize</code> for every element?  (Hint: none.)</p>

<p>I suggest changing your <code>struct stack</code> like so:</p>

<pre><code>typedef struct stack{
    int *iInfo;
    int iCount;
    int iStackSize;
}STACK;
</code></pre>

<p>Then, maintain just one <code>struct stack</code>, and perform your dynamic allocation / reallocation on its <code>iInfo</code> member.  Use simple indexing syntax based on <code>iCount</code> to store values in and retrieve them from the space pointed to by <code>iInfo</code>.</p>
