<p><code>__slots__</code> won't stop you from setting an attribute to a class, you need to override <code>__setattr__</code> for that. Something like this should do it:</p>

<pre><code>class B(type):
    def __new__(cls, clsname, bases, dct):
        dct['__slots__']  = ('x',)
        return type.__new__(cls, clsname, bases, dct)
    def __setattr__(cls, attr, val):
        if attr not in cls.__slots__:
            raise AttributeError('Can\'t set {!r}'.format(attr))
        else:
            type.__setattr__(cls, attr, val)

class A(metaclass=B):
    pass
</code></pre>

<p><strong>Demo:</strong></p>

<pre><code>&gt;&gt;&gt; A.x = 1
&gt;&gt;&gt; A.y = 2
Traceback (most recent call last):
  File "&lt;pyshell#2&gt;", line 1, in &lt;module&gt;
    A.y = 2
  File "C:\Python27\so.py", line 7, in __setattr__
    raise AttributeError('Can\'t set {!r}'.format(attr))
AttributeError: Can't set 'y'
</code></pre>
