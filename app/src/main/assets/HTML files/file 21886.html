<p>I'd probably write:</p>

<pre><code>&gt;&gt;&gt; lod = [{1: "a"}, {2: "b"}]
&gt;&gt;&gt; any(1 in d for d in lod)
True
&gt;&gt;&gt; any(3 in d for d in lod)
False
</code></pre>

<p>although if there are going to be a lot of dicts in this list you might want to reconsider your data structure.</p>

<p>If you want the index and/or the dictionary where the first match is found, one approach is to use <code>next</code> and <code>enumerate</code>:</p>

<pre><code>&gt;&gt;&gt; next(i for i,d in enumerate(lod) if 1 in d)
0
&gt;&gt;&gt; next(d for i,d in enumerate(lod) if 1 in d)
{1: 'a'}
&gt;&gt;&gt; next((i,d) for i,d in enumerate(lod) if 1 in d)
(0, {1: 'a'})
</code></pre>

<p>This will raise <code>StopIteration</code> if it's not there:</p>

<pre><code>&gt;&gt;&gt; next(i for i,d in enumerate(lod) if 3 in d)
Traceback (most recent call last):
  File "&lt;ipython-input-107-1f0737b2eae0&gt;", line 1, in &lt;module&gt;
    next(i for i,d in enumerate(lod) if 3 in d)
StopIteration
</code></pre>

<p>If you want to avoid that, you can either catch the exception or pass <code>next</code> a default value like <code>None</code>:</p>

<pre><code>&gt;&gt;&gt; next((i for i,d in enumerate(lod) if 3 in d), None)
&gt;&gt;&gt;
</code></pre>

<p>As noted in the comments by @drewk, if you want to get multiple indices returned in the case of multiple values, you can use a list comprehension:</p>

<pre><code>&gt;&gt;&gt; lod = [{1: "a"}, {2: "b"}, {2: "c"}]
&gt;&gt;&gt; [i for i,d in enumerate(lod) if 2 in d]
[1, 2]
</code></pre>
