<p>The part of the decorator code which is "executed everytime" is the wrapper function. The code outside that wrapper function is executed just when the operator is applied -</p>

<p>This nothing magic or "new" - just see the order things are and what is called when - the only thing out of normal execution order which cold be called  just a bit magic is the decoration itself- just remember that:</p>

<pre><code> @memoize
 def multiply(x, y):
     return x * y
</code></pre>

<p>is just the same thing as:</p>

<pre><code>def multiply(x, y):
     return x * y

multiply = memoize(multiply)
</code></pre>

<p>Also, if you are trying to understand decorators, leave the <code>functools.wraps</code> call out of it for now. It is good for production code, and for filling in small details: it disguises your wrapper function as the inner function it decorates (for example, the function <code>wrapper</code> <code>__name__</code>attribute is set to <code>multiply</code> in this example), but is an unnecessary complication when trying to understand decorators.</p>
