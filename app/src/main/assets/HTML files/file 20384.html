<p>Decorators usually return a wrapper function; just put your logic in the wrapper function after invoking the wrapped function.</p>

<pre><code>def audit_action(action):
    def decorator_func(func):
        def wrapper_func(*args, **kwargs):
            # Invoke the wrapped function first
            retval = func(*args, **kwargs)
            # Now do something here with retval and/or action
            print 'In wrapper_func, handling action {!r} after wrapped function returned {!r}'.format(action, retval)
            return retval
        return wrapper_func
    return decorator_func
</code></pre>

<p>So <code>audit_action(action='did something')</code> is a decorator factory that returns a scoped <code>decorator_func</code>, which is used to decorate your <code>do_something</code> (<code>do_something = decorator_func(do_something)</code>).</p>

<p>After decorating, your <code>do_something</code> reference has been replaced by <code>wrapper_func</code>. Calling <code>wrapper_func()</code> causes the original <code>do_something()</code> to be called, and then <em>your code in the wrapper func</em> can do things.</p>

<p>The above code, combined with your example function, gives the following output:</p>

<pre><code>&gt;&gt;&gt; do_something('foo')
In wrapper_func, handling action 'did something' after wrapped function returned 'bar'
'bar'
</code></pre>
