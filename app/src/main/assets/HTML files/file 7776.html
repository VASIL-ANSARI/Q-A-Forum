<p>You're close, but you can't just inherit from another entity and change the table like that.  Entity inheritance has to follow one of the provided inheritance models.  It may be for your use case as simple as adding <code>@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)</code> to the superclass.  There are some limitations to this if you have some more complicated mappings with other classes.  Since it won't be able to tell which table a superclass based mapping is actually in, it can't join through it.  And mappings to the superclass will require checking both tables every time.  You also of course need unique ID generation across all the tables in the hierarchy.  You may want to consider using an abstract superclass and having both concrete entities be leaf classes.  Then at least you can always work with just a single table when you know which one it is.  </p>

<p>Alternately you can declare your column mappings in an <code>@MappedSuperclass</code> and each subclass can then be an entity with a table mapping.  That might work better if it's legacy data and you don't have unique IDs across the 'regular' and 'copy' tables.  </p>
