<p>The problem you are facing is that the subclass instance is not constructed completely when you call the abstract (or any overriden) method from the baseclass. The only way to be sure that the object instance is constructed completely is to have finished its constructor.</p>

<p>One way to solve your issue is to use the constructors only for construction of the instances and to leave (dynamic) initialisation to a method. In cases like this you can use methods like:</p>

<pre><code>private boolean initialized = false;

public synchronized boolean init() {
    if (!initialized) {
         // allocate resources, call abstract method(s)
         initialized = true;
    }
    return initialized;
}

public synchronized void cleanup() {
    if (initialized) {
         // free resources, call abstract method(s)
         initialized = false;
    }
}
</code></pre>

<p>calling code can call the <code>init()</code> and <code>cleanup()</code> methods explicitly or leave the calls to <code>init()</code> to a pattern as in:</p>

<pre><code>public void doSomething() {

    if (init()) {
        // go!
    }
}
</code></pre>

<p>Inside your init method you can call the abstract methods and be sure that the complete object instance is constructed correctly.</p>
