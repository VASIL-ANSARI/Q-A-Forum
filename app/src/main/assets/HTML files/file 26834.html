<p>In your program <code>24.321</code> is greater than <code>24.33</code> because length of <code>24.321</code> is greater than length of <code>24.33</code>. </p>

<p>You should stop increasing length when you read <code>.</code>.
Fix:</p>

<pre><code>//UPDATE
while(*curr1=='0') curr1++; 
while(*curr2=='0') curr2++;
//END OF UPDATE
char dot1 = 0, dot2 = 0;
char err1 = 0, err2 = 0;
while(*curr1 || *curr2)
{
    if(*curr1 == '.') ++dot1; //UPDATE2
    if(*curr2 == '.') ++dot2; //UPDATE2
    while(*curr1 == '.')
        curr1++;
    while(*curr2 == '.')
        curr2++;

    if(value == 0)
    {
        value = *curr1 - *curr2;
    }
    if(*curr1)
    {
        if(*curr1 &lt; '0' || *curr1 &gt; '9') err1 = 1;
        curr1++;
        if(!dot1) len1++;
    }
    if(*curr2)
    {
        if(*curr2 &lt; '0' || *curr2 &gt; '9') err2 = 1;
        curr2++;
        if(!dot2) len2++;
    }
}

if(err1 || err2 || dot1 &gt; 1 || dot2 &gt; 1) exit(1); // UPDATE2
</code></pre>

<p>UPDATE:
I updated code. Now before main comparison while only zeros are skipped. Dots will be skipped at the beginning of main while and fix with <code>dot1</code> and <code>dot2</code> will work.</p>

<p>UPDATE2:
To check if numbers are correct you should count dots and check if all chars are dots or digits.
Be aware that for longer bad numbers (more than 255 dots) my code could not work correctly (because dot1 is 1 byte long). If you need to handle these cases you should check if dot1/dot2 are equal to 1 and change err1/err2 to 1 instead of increasing dot1/dot2.</p>
