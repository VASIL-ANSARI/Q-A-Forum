<p>Since I spent half a day with that problem, I thought the simple answer might be useful to someone else.</p>

<p>So what did I try:</p>

<ol>
<li>I decided not to go recursive since I avoid it if I can for obvious reasons and used two nested loops</li>
<li>I wrote unit tests for every case I could think of </li>
<li>Then I tried step by step to make them all green</li>
<li>I banged my head against the table because everytime I made one green another one went red</li>
<li>I asked a colleague</li>
<li>He let me state the problem without showing him my "solution" </li>
</ol>

<p>Here's the magic 15 min solution:</p>

<pre><code>public static LinkedList&lt;Data&gt; merge(final LinkedList&lt;Data&gt; source) {
    final HashMap&lt;Data, Integer&gt; temp = new HashMap&lt;&gt;();

    for (final Data data : source) {
        final int count = data.getCount();
        data.setCount(0);
        if (temp.get(data) == null) {
            temp.put(data, count);
        }
        else {
            temp.put(data, temp.get(data) + count);
        }
    }

    final Set&lt;Entry&lt;Data, Integer&gt;&gt; set = temp.entrySet();
    final LinkedList&lt;Data&gt; result = new LinkedList&lt;&gt;();

    for (final Entry&lt;Data, Integer&gt; entry : set) {
        final Data mergedData = entry.getKey();
        mergedData.setCount(entry.getValue());
        result.add(mergedData);
    }

    Collections.sort(result, new DataComparator());

    return result;
}
</code></pre>
