<p>You can pass it explicitly as a template parameter to <code>vector_expression</code>:</p>

<pre><code>template&lt;class E, class size_type&gt;
class vector_expression ...

template&lt;typename T, class Tuple = std::vector&lt;T&gt;&gt;
class vector
    : public vector_expression&lt;vector&lt;T, Tuple&gt;, 
                               typename Tuple::size_type&gt; ...
</code></pre>

<p><strong>Edit:</strong></p>

<p>It is also possible to turn the problematic function into a member function template, so that it is not instantiated until the full class definition is seen:</p>

<pre><code>template &lt;typename K = E&gt;
auto operator[](typename K::size_type i) const
{
    if (i &gt;= size())
        throw std::length_error("");
    return static_cast&lt;K const&amp;&gt;(*this)[i];
}
</code></pre>
