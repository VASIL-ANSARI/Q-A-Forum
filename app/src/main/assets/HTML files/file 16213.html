<p>If you have a BroadcastReceiver class declared such: </p>

<pre><code>public class NetConnectionBroadcastReceiver extends BroadcastReceiver
{
    @Override
    public void onReceive(Context context, Intent intent)
    {
        final ConnectivityManager cm = (ConnectivityManager) 
            context.getSystemService(Context.CONNECTIVITY_SERVICE);
        final NetworkInfo networkInfo = cm.getActiveNetworkInfo();
        if (networkInfo == null)
            Log.v("CONNECT", "NOT CONNECTED");
        int netType = networkInfo.getType();
        if (netType == ConnectivityManager.TYPE_WIFI)
        {
            Log.v("CONNECT", "CONNECTED TO WIFI");
        }
        else if (netType == ConnectivityManager.TYPE_MOBILE)
        {
            Log.v("CONNECT", "CONNECTED TO MOBILE" + 
                    (networkInfo.isRoaming() ? " ROAMING!" : ""));
        }
    }
}
</code></pre>

<p>you can store an instance of it insinde your activity, and in the <code>onCreate</code> method you can register if for the <code>android.net.conn.CONNECTIVITY_CHANGE</code> event: </p>

<pre><code>private final  NetConnectionBroadcastReceiver receiver = 
        new NetConnectionBroadcastReceiver();
public void onCreate(Bundle savedInstanceState)
{
    // ... your onCreate implementation goes here 
    final IntentFilter intentFilter = 
        new IntentFilter("android.net.conn.CONNECTIVITY_CHANGE");
    this.registerReceiver(this.receiver, intentFilter);
}
</code></pre>

<p>When the data connection changes, you get your receiver's <code>onReceive</code> method called. You can examine from within, what kind of change happened. </p>

<p>For this check you don't need more than the <code>android.permission.ACCESS_NETWORK_STATE</code> permission.</p>
