<p>All you need to do is wrap your UI-accessing code with a <a href="http://msdn.microsoft.com/en-us/library/system.windows.threading.dispatcher.invoke.aspx" rel="nofollow"><code>Dispatcher.Invoke</code></a> call from the background thread. The <code>Dispatcher</code> instance to use may be obtained through the <a href="http://msdn.microsoft.com/en-us/library/system.windows.threading.dispatcherobject.dispatcher.aspx" rel="nofollow"><code>Dispatcher</code></a> property of your <code>UIElement</code>.</p>

<p>Assuming that the method below is defined within your UI elementâs class definition:</p>

<pre><code>private void ProcessItems(IList&lt;Item&gt; items)
{
    Task.Factory.StartNew(() =&gt;
    {
        for (int i = 0; i &lt; items.Count; ++i)
        {
            // Code here runs on background thread.
            this.ProcessItem(items[i]);

            this.Dispatcher.Invoke(DispatcherPriority.Normal, () =&gt;
            {
                // Code here runs on UI thread.
                this.UpdateStatus("Completed " + (i + 1) + " of " + items.Count);
            });
        }
    },
        TaskCreationOptions.LongRunning);
}
</code></pre>
