<p>I do not recommend using Parallel.For. It does not give an satisfactory control of parallelism (you probably don't want to hammer away hundrades of requests which will start to timeout) also it requires unnecessary context switching. </p>

<p>Threads/cores isn't the limiting factor in case http requests.</p>

<p>In the example change </p>

<pre><code>Thread.Sleep(2000)
</code></pre>

<p>to</p>

<pre><code>await Task.Delay(2000)
</code></pre>

<p>and when using real web api calls</p>

<pre><code>await httpClient.PostAsync(...)
</code></pre>

<p>also remember to wait in Main</p>

<pre><code>Console.ReadLine() // or something more sophisticated
</code></pre>

<p>otherwise the program will terminate before the calls have been made.</p>

<p>Then to control the level of parallelism I think the easiest solution is to use a Semaphore to count the number of outstanding calls, waiting in the main loop for the semaphore to be signaled again before issuing new requests.</p>
