<p>The authorization code grant requires two steps.</p>

<p>The first step is the browser redirecting to the identity provider and displaying the logon ui. The authorization code is returned to the browser by the identity provider and then, from the browser to the client application. This step doesn't involve client secret! This is because the end user can debug this part of the flow and she should not learn the value of the client secret.</p>

<p>Then, when the client application has the onetime authorization code, it concacts the token endpoint directly (server-to-server) to exchange the authorization code for authorization token. This is where client id and client secret are used to verify that only legitimate client applications exchange codes for tokens.</p>

<p>The idea behind this flow is to protect the end user from exposing her password to the client application and also protect the client application from exposing its client secret to the end user. </p>

<p>Also note that the authorization code grant flow is the most complicated one as it involves both username/password (provided by the end user) and clientid/client secret (provided by the client application). There are other flows which allow to get the authorization token in slightly different way, namely:</p>

<ul>
<li><p>resource owner grant which involves sending username/password directly by end user to the token endpoint of the identity provider. This flow is suited for desktop/mobile/native apps where the logon ui can be customized (but it also can raise suspicions and users could proably refuse to use it)</p></li>
<li><p>client credentials flow which involves sending clientid/client secret by the client application to the idntity provider. There is no end user but only the client application authenticating in the identity provider.</p></li>
</ul>

<p>More on flows here:</p>

<p><a href="http://aaronparecki.com/articles/2012/07/29/1/oauth2-simplified" rel="nofollow">http://aaronparecki.com/articles/2012/07/29/1/oauth2-simplified</a></p>

<p>As for DNOA, I found it clean and understandable but the docs are lacking. Fortunately, examples are great and although barely documented, you can find almost everything there. Nonetheless, I was able to set up oauth2 identity provider and resource server in three days and support all four oauth2 flows. I am not going to dig deeply into details as this is not what your question is about, however, if you have DNOA specific questions, just ask.</p>

<p><strong>Edit:</strong>: regarding your <code>QueryAccessToken</code> implementation, it seems that you are using the <code>WebServerClient</code> internally. In my code I just initialize its properties:</p>

<pre><code>WebServerClient client = ...

client.ClientIdentifier = "client_id";
client.ClientCredentialApplicator = 
     ClientCredentialApplicator.PostParameter( "client_secret" );
</code></pre>

<p>With these two configured, both <code>client_id</code> and <code>client_secret</code> are sent to the token service with the <code>client_secret</code> passed in POST params.</p>
