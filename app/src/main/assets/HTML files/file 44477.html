<pre><code>elif n &gt; 2:
    is_power(n)
</code></pre>

<p>is missing the <code>return</code>:</p>

<pre><code>def is_power(n):
    n = n/2
    if n == 2:
        return True
    elif n &gt; 2:
        return is_power(n)
    else:
        return False
</code></pre>

<p>thus, the "first" level of <code>is_power</code> returns nothing (or <code>None</code>, depending on how you check), which leads to output of <code>no</code>.</p>

<p>@kaveman correctly pointed out <code>is_power(2)</code> yields the wrong result.
You can fix that by halving 2 in the <code>elif</code> clause:</p>

<pre><code>def is_power(n):
    if not n == int(n):
        return False
    n = int(n)
    if n == 1:
        return True
    elif n &gt; 2:
        return is_power(n/2.0)
    else:
        return False
</code></pre>

<p>EDIT: @will pointed out that I was mixing up python2 with python3 division. Using <code>/2.0</code> fixes that. Also, in comments to the question he pointed out that 1 is a power of 2. Checking against <code>==1</code> instead of <code>==2</code> fixes that issue. Also, I added an <code>int</code> cast, which is not necessary for the power of 2 check (since well, IEEE754 floats are base 2 after all, so powers of 2 are exactly representable), but for non-2 bases, this will make the code portable.</p>
