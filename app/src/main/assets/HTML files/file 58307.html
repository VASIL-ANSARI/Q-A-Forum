<p>Here's an example of limiting the Y axis rotation, you can adapt it for X too. You didn't state what the limit should be based on so here it's based on the rotation of another object (public Transform target), this could be your player or whatever.</p>

<pre><code>public float sensitivity = 16.0f;
public Transform target;

void Update()
{

    if (Input.GetMouseButton(0))
    {
        //Debug.Log(Quaternion.Angle(transform.rotation, target.rotation));
        float angle = Quaternion.Angle(transform.rotation, target.rotation);
        if(angle &lt; 45 || angle &gt; 315)
        {
            Vector3 pos = Camera.main.ScreenToViewportPoint(Input.mousePosition);
            transform.RotateAround(pos, Vector3.up, Time.deltaTime * sensitivity);
        }

    }
}
</code></pre>

<p>If instead you want to limit based on world space just check the rotation of the camera:</p>

<pre><code>public float sensitivity = 16.0f;
//public Transform target;

void Update()
{

    if (Input.GetMouseButton(0))
    {

        float angle = transform.eulerAngles.y;
        Debug.Log(angle);
        if (angle &lt; 45 || angle &gt; 315)
        {
            Vector3 pos = Camera.main.ScreenToViewportPoint(Input.mousePosition);
            transform.RotateAround(pos, Vector3.up, Time.deltaTime * sensitivity);
        }

    }
}
</code></pre>

<p>Note in both cases the use of Time.deltaTime to ensure the rotation appears to happen at the same speed regardless of the players frame-rate. </p>

<p>If you want to reverse the rotation invert the axis argument of RotateAround:</p>

<pre><code>transform.RotateAround(pos, -Vector3.up, Time.deltaTime * sensitivity);
</code></pre>
