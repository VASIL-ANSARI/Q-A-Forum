<p>The easiest way is to capture stdout and stderr and send them to DEVNULL</p>

<p>(I'm using <code>espeak 4; echo 'bye'</code> as a test command; <code>echo</code> prints to stdout and <code>espeak</code>, well, speaks so will have output that isn't captured)</p>

<pre><code>In [14]: p = subprocess.Popen("espeak 4; echo 'bye'", shell=True, \
             stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL).wait()

In [15]: p = subprocess.Popen("espeak 4; echo 'bye'", shell=True).wait()
bye
</code></pre>

<p>The other thing you can do is send everything to <code>/dev/null</code>, if you're on a linux/unix machine</p>

<pre><code>In [16]: p = subprocess.Popen("echo 'bye' &gt; /dev/null 2&gt;&amp;1", shell=True).wait() 
         # note: this is bash. Works for me on zsh as well,
         # but might not work for other variants of sh
         # use command 2&gt; /dev/null if you only want to redirect stderr.
</code></pre>

<p>Addendum: Wait, you're using a pipe, the first command is clearly outputting to stderr</p>

<p>For your script, if I were to do with linux commands alone, I'd write it this way:</p>

<pre><code>subprocess.Popen('shp2pgsql -s 17932 \\storage1\dev1\gis\a.shp asmithe.myTable 2&gt; /dev/null | '
    'psql -U asmithe -h example.org -d inventory -q', shell=True).wait()
     #implicit string concat is awesome for breaking up long lines
</code></pre>
