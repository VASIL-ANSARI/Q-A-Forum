<p>The foreign keys would only be automatically set to null if the currently associated entities have already been loaded into the context. In other words, when <code>b</code> is removed, the associated set of type <code>A</code> would only have their <code>BId</code> property set to null if those entities of type <code>A</code> had already been loaded into the context. Otherwise, EF would not have any knowledge of their existence (unless the EF provider automatically generates SQL set those foreign keys to null...which it doesn't in the SQL Server case).</p>

<p>One option is to do this (if you don't mind loading all those entities):</p>

<pre><code>public void DeleteB(int bId)
{
    var entity = _context.Bs.Single(b =&gt; b.Id == bId);
    _context.Entry(entity).Collection(b =&gt; b.As).Load(); 
    _context.Bs.Remove(entity);
    _context.SaveChanges();
}
</code></pre>

<p>Another option is to write your own SQL statement and run that.</p>
