<p>When you use a function over an indexed column, SQLite cannot use the index, because the function may not preserve the ordering -- i.e. there can be functions such as <code>1&gt;2</code>, but <code>F(1)&lt;F(2)</code>. There are some ways to solve this situation, though:</p>

<ol>
<li>If you want to use indexes to make your query faster, you must save
the value in a fixed case (upper or lower) and then convert only the
query parameter to the same case:</li>
</ol>

<pre class="lang-sql prettyprint-override"><code>SELECT count(*) as 'test'
FROM my_table
WHERE surname = LOWER('Oliver')
</code></pre>

<ol>
<li>You can use the case-insensitive LIKE operator (<strong>I don't know how indexes are affected!</strong>):</li>
</ol>

<pre class="lang-sql prettyprint-override"><code>SELECT count(*) as 'test'
FROM my_table
WHERE surname LIKE 'Oliver';
</code></pre>

<ol>
<li>Or you can create each column as <code>text collate nocase</code> and don't worry about case differences regarding this column anymore:</li>
</ol>

<pre class="lang-sql prettyprint-override"><code>CREATE TABLE my_table (surname text collate nocase, &lt;... other fields here ...&gt;);
SELECT count(*) as 'test'
FROM my_table
WHERE surname ='Oliver';
</code></pre>

<p>You can find more information about the <code>=</code> and <code>LIKE</code> operators <a href="http://www.sqlite.org/lang_expr.html" rel="nofollow">here</a>.</p>
