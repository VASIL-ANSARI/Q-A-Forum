<p>Create a new type which represents the composite key (the name and the number here). You'll need to override <code>hashCode()</code> and <code>equals()</code>, and I'd strongly advise you to make the type immutable. For example:</p>

<pre><code>public final class NameIntPair {
    private final int intValue;
    private final String name;

    public NameIntPair(int intValue, String name) {
        this.intValue = intValue;
        this.name = name;
    }

    @Override
    public int hashCode() {
        int hash = 17;
        hash = hash * 31 + intValue;
        hash = hash * 31 + (name == null ? 0 : name.hashCode());
        return hash;
    }

    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof NameIntPair)) {
           return false;
        }
        if (this == obj) {
           return true;
        }
        NameIntPair other = (NameIntPair) obj;
        return other.intValue == intValue &amp;&amp; Objects.equal(other.name, name);
    }
}
</code></pre>

<p>I'm using <code>Objects.equal</code> from Guava for convenience to avoid explicit nullity checks here - if you're not using Guava, you'd either have to use an equivalent or handle nullity in the code. Alternatively, you may well want to prevent null names, validating this in the constructor.</p>
