<p>The second test, <code>~ec</code> runs into a peculiarity of the name lookup for operators in expressions: [over.match.oper]/3 (from the "ancient" N3797):</p>

<blockquote>
  <p>For a unary operator <code>@</code> with an operand of a type whose cv-unqualified version is <code>T1</code> [...]</p>
  
  <p>The set of non-member candidates is the result of the unqualified
  lookup of <code>operator@</code> in the context of the expression according to the
  usual rules for name lookup in unqualified function calls
  except that all member functions are ignored. <strong>However, if no operand
  has a class type, only those non-member functions in the lookup set
  that have a first parameter of type <code>T1</code> or âreference to (possibly
  cv-qualified) <code>T1</code>â, when <code>T1</code> is an enumeration type</strong> [...] <strong>are
  candidate functions</strong>.</p>
</blockquote>

<p>So the <code>::operator~(const Target&amp;)</code> should not be found/used with a for an expression with a unary operator applied to an operand of type <code>ConvertibleEC</code>.</p>

<hr>

<p>For the first, <code>~t</code>, the operand is of class type and the above exception does not apply.</p>

<p>Both the third and the fourth test do not use operator lookup, but usual unqualified lookup. The usual unqualified lookup finds <code>::operator~(const Target&amp;)</code> (in cases 1 and 3) and <code>anotherFunction</code> (in case 4).</p>
