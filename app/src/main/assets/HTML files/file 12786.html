<p>An effective way to serialize the execution of tasks is to use a mutex (Mutual Exclusion).</p>

<p>Python's <code>threading</code> module has <a href="http://docs.python.org/library/threading.html#threading.Lock" rel="nofollow">a <code>Lock</code> object</a> which can be <a href="http://docs.python.org/library/threading.html#lock-objects" rel="nofollow">used to this effect</a>:</p>

<pre><code># ...
module_lock = threading.Lock() # or make this an attribute in an object with sufficiently-large scope
# ...
def do_interesting_task():
     with module_lock.acquire():
         interesting_task()
</code></pre>

<blockquote>
  <p>"Abandon all hope, ye who enter here."</p>
</blockquote>

<p>Mutexes and semaphores are powerful tools, but used unwisely they will yield deadlocks and occasionally eat your lunch.</p>
