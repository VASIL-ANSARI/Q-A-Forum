<p>To get all possibilities, you could make a map of values:</p>

<pre><code>for (i=a to b) {
 for (j=a to b) {
  map.put(i+j, 1+map.get(i+j))
 }
}
</code></pre>

<p>For a more efficient way to count sums, you could use the pattern
6 7's, 5 6's, 4 5's, 3 4's, 2 3's, 1 two.</p>

<p>The pattern holds for n x n grid, there will be n (n+1)'s, with one less possibility for a sum 1 greater or less.</p>

<p>This will count the possibilities, for example, Count(6, 1/2/3/4/5/6) will give possibilities for sums of dice.</p>

<pre><code>import math
def Count(poss,sumto):
  return poss - math.fabs(sumto-(poss+1));
</code></pre>

<p>Edit: In C this would be:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;;

int count(int poss, int sumto)
{
  return poss - abs(sumto-(poss+1));
}

int main(int argc, char** argv) {
    printf("With two dice,\n");
    int i;
    for (i=1; i&lt;= 13; i++)
    {
        printf("%d ways to sum to %d\n",count(6,i),i);
    }
    return (EXIT_SUCCESS);
}
</code></pre>

<p>gives:</p>

<pre><code>With two dice,
0 ways to sum to 1
1 ways to sum to 2
2 ways to sum to 3
3 ways to sum to 4
4 ways to sum to 5
5 ways to sum to 6
6 ways to sum to 7
5 ways to sum to 8
4 ways to sum to 9
3 ways to sum to 10
2 ways to sum to 11
1 ways to sum to 12
0 ways to sum to 13
</code></pre>
