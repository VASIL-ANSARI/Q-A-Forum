<p>How about the following. Of course <code>createLink</code> cannot not take a const reference so I made it to take a non-const pointer.</p>

<pre><code>class Container {
    const int STRING    = 0x0000001;
    const int INT       = 0x0000002;

    const int LINK      = 0x8000000;

public:
    ...    
    void set(int val){...}
    void set(const std::string &amp;val)
    { 
        if (var.type == LINK) 
        {
            reinterpret_cast&lt;Container*&gt;(var.data)-&gt;set(val);
        }
        else
            ...
    }
    void createLink(Container* val)
    {
        var.data = val;
        var.type = LINK;
    }
private:
    typedef struct VAR {
        int type = 0;
        void *data = NULL;
    };
    VAR var;
};
</code></pre>

<p>There are a some important points to think about - relative lifetimes of the link and the linked is the most obvious one. </p>
