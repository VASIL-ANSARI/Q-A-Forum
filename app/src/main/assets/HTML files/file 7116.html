<p>You can't do that. That's not the way Java works. When you write:</p>

<pre><code>map.put("name", mapTest.name);
</code></pre>

<p>that's putting <em>the current value of <code>mapTest.name</code></em> into the map. After the argument has been evaluated, it's <em>completely independent</em> of the original expression.</p>

<p>If you need to do something <em>like</em> this, you would have some sort of mutable wrapper class - you'd put a reference to the <em>wrapper</em> into the map, and then you can change the value within the wrapper, and it doesn't matter how you get to the wrapper, you'll still see the change.</p>

<p>Sample code:</p>

<pre><code>import java.util.*;

class StringWrapper {
    private String value;

    StringWrapper(String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return value;
    }
}


public class Test {
    public static void main(String[] args) throws Exception {
        Map&lt;String, StringWrapper&gt; map = new HashMap&lt;String, StringWrapper&gt;();

        StringWrapper wrapper = new StringWrapper("Original");
        map.put("foo", wrapper);

        System.out.println(map.get("foo"));

        wrapper.setValue("Changed");

        System.out.println(map.get("foo"));
    }
}
</code></pre>
