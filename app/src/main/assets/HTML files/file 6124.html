<p>Because of perfect forwarding, when the argument to <code>P&amp;&amp;</code> is an lvalue, then <code>P</code> will be deduced to the argument's type plus having a <code>&amp;</code> attached. So you get <code>int &amp; &amp;&amp;</code> with <code>P</code> being <code>int&amp;</code>. If the argument is an rvalue then <code>P</code> will be deduced to only the argument's type, so you <em>would</em> get an <code>int&amp;&amp;</code> argument with <code>P</code> being <code>int</code> if you would pass, for example <code>0</code> directly. </p>

<p><code>int&amp; &amp;&amp;</code> will collapse to <code>int&amp;</code> (this is a semantic view - syntactically <code>int&amp; &amp;&amp;</code> is illegal. But saying <code>U &amp;&amp;</code> when <code>U</code> is a template parameter or a typedef refering to a type <code>int&amp;</code>, then <code>U&amp;&amp;</code> is still the type <code>int&amp;</code> - i.e the two references "collapse" to one lvalue reference). That's why <code>t</code> has type <code>int&amp;</code>. </p>
