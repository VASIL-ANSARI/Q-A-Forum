<p>The compiler cannot infer the return type of the promise from a call to <code>resolve</code>.</p>

<p>This code:</p>

<pre><code>return new Promise((resolve, reject) =&gt; {
</code></pre>

<p>... is a shorthand for:</p>

<pre><code>return new Promise&lt;any&gt;((resolve, reject) =&gt; {
</code></pre>

<p>And then the type <code>any</code> is a way to disable type checking. Your second code compiles but it is wrong.</p>

<p>If you don't want to repeat yourself, you can do this:</p>

<pre><code>let testP = function () {
    return new Promise&lt;string&gt;((resolve, reject) =&gt; {
        resolve("string");
    });
}
</code></pre>

<p>Here, the return type of the function is inferred to <code>Promise&lt;string&gt;</code>.</p>

<hr>

<p>EDIT #1 (To answer to your answer): <code>Promise&lt;any&gt;</code> is compatible with <code>Promise&lt;number&gt;</code>, and <code>"string"</code> is also compatible with <code>any</code>. But <code>Promise&lt;string&gt;</code> is not compatible with <code>Promise&lt;number&gt;</code>. In fact, <code>any</code> allows you to do wrong code. When you use it, it's up to you to know what you are doing.</p>

<hr>

<p>EDIT #2:</p>

<p>About this code:</p>

<pre><code>export interface Dog {
  name: string,
  weight: number,
  age: number
}

function getDogs(): Promise&lt;Dog[]&gt; {
  return this.http.get('/dogs')
    .toPromise()
    .then(response =&gt; response.json())
    .catch(this.handleError);
}
</code></pre>

<p>The TypeScript compiler checks types <em>statically</em>. It can't check the type of a string value returned by the server, because, at run time, on the browser, there is just compiled code without types metadata at all.</p>

<p>TypeScript is like JSDoc. It helps to describe parts of your program. It can't help to check data that your program receives dynamically.</p>
