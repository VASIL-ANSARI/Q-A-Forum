<p>When you use <code>shell=True</code> but pass a list, you're asking Python to merge your list of strings together as if they were separate arguments. That means it may do its own quoting, on top of whatever quoting you did, in hopes that the shell will reverse things properly. This is going to be a nightmare to get right. If you want to use <code>shell=True</code>, just pass a string.</p>

<p>But that raises the question of why you're using <code>shell=True</code> in the first place. If you didn't use this, you could just pass a list of arguments, without having to quote any of them to protect them from the shell. Much easier to write, and easier to debug, and more efficient and more secure to boot. Unless you actually need shell features, or you've got a command line that you worked hard to get working and don't want to spend time breaking down into separate arguments, never use the shell.</p>

<hr>

<p>I'm not actually sure what <code>awk</code> command you're <em>trying</em> to run here. If you give it the double-quotes around <code>$1</code> and <code>$2</code> it's just going to print a literal <code>"$1" "$2"</code>, because that's what quotes mean to awk. Maybe you wanted something like this?</p>

<pre><code>awk '!/&lt;tag&gt;/ {print "\""$1"\"", "\""$2"\""}' test.txt
</code></pre>

<p>In which case:</p>

<pre><code>subprocess.check_output(['awk', r'!/&lt;tag&gt;/ {print "\""$1"\"", "\""$2"\""}', 
                         'test.txt'])
</code></pre>

<p>(Note that I used a raw string so I could pass the <code>"\""</code> literally, without having to backslash the backslash.)</p>

<p>But this still doesn't provide your desired output, because <code>$1</code> is going to be <code>a,</code>, so <code>"\""$1"\""</code> is going to be <code>"a,"</code>.</p>
