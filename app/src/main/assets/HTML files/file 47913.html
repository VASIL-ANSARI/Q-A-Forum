<p>So it turns out I needed to create a custom MessageFormatter and attach it as a behaviour to the client operations.</p>

<p>For anybody else needing to do this you need 3 files;</p>

<p>Firstly you create a custom message class which implements Message. Here in the OnWriteStartEnvelope method you add/define the namespaces you want in the Envelope.</p>

<pre><code>class RoyalMailMessage: Message {
  private readonly Message message;

  public RoyalMailMessage(Message message) {
    this.message = message;
  }
  public override MessageHeaders Headers {
    get {
      return this.message.Headers;
    }
  }
  public override MessageProperties Properties {
    get {
      return this.message.Properties;
    }
  }
  public override MessageVersion Version {
    get {
      return this.message.Version;
    }
  }
  protected override void OnWriteStartBody(XmlDictionaryWriter writer) {
    writer.WriteStartElement("Body", "http://schemas.xmlsoap.org/soap/envelope/");
  }
  protected override void OnWriteBodyContents(XmlDictionaryWriter writer) {
    this.message.WriteBodyContents(writer);
  }
  protected override void OnWriteStartEnvelope(XmlDictionaryWriter writer) {
    writer.WriteStartElement("s", "Envelope", "http://schemas.xmlsoap.org/soap/envelope/");
    writer.WriteAttributeString("xmlns", "v2", null, "http://www.royalmailgroup.com/api/ship/V2");
    writer.WriteAttributeString("xmlns", "v1", null, "http://www.royalmailgroup.com/integration/core/V1");
    writer.WriteAttributeString("xmlns", "xsi", null, "http://www.w3.org/2001/XMLSchema-instance");
    writer.WriteAttributeString("xmlns", "xsd", null, "http://www.w3.org/2001/XMLSchema");

  }
}
</code></pre>

<p>Then you create a custom Class which implements IClientMessageFormatter. This makes use of the Message class we defined above for outgoing requests made by the client;</p>

<pre><code>public class RoyalMailMessageFormatter: IClientMessageFormatter {
  private readonly IClientMessageFormatter formatter;

  public RoyalMailMessageFormatter(IClientMessageFormatter formatter) {
    this.formatter = formatter;
  }

  public object DeserializeReply(Message message, object[] parameters) {
    return this.formatter.DeserializeReply(message, parameters);
  }

  public Message SerializeRequest(MessageVersion messageVersion, object[] parameters) {
    var message = this.formatter.SerializeRequest(messageVersion, parameters);
    return new RoyalMailMessage(message);
  }
}
</code></pre>

<p>We then need to create a custom class which implements IOperationBehavior. This is needed so we can attatch the custom message formatter to the service operations as a behaviour;</p>

<pre><code>class RoyalMailIEndpointBehavior: IOperationBehavior {

  public RoyalMailIEndpointBehavior() {}

  public void ApplyClientBehavior(OperationDescription description, ClientOperation proxy) {
    IClientMessageFormatter currentFormatter = proxy.Formatter;
    proxy.Formatter = new RoyalMailMessageFormatter(currentFormatter);
  }

  public void AddBindingParameters(OperationDescription operationDescription, BindingParameterCollection bindingParameters) {

  }

  public void ApplyDispatchBehavior(OperationDescription operationDescription, DispatchOperation dispatchOperation) {

  }

  public void Validate(OperationDescription operationDescription) {

  }

}
</code></pre>

<p>Finally, we need to add the custom IOperation behaviour to all the service operations generated by WCF;</p>

<pre><code>private shippingAPIPortTypeClient GetProxy() {

  BasicHttpBinding myBinding = new BasicHttpBinding(BasicHttpSecurityMode.Transport);
  myBinding.Security.Transport.ClientCredentialType = HttpClientCredentialType.Certificate;

  shippingClient = new shippingAPIPortTypeClient(myBinding, new EndpointAddress(new Uri(shippingClientSandboxEndpoint), EndpointIdentity.CreateDnsIdentity("api.royalmail.com"), new AddressHeaderCollection()));
  shippingClient.ClientCredentials.ClientCertificate.Certificate = certificate;

  foreach(OperationDescription od in shippingClient.Endpoint.Contract.Operations) {
    od.Behaviors.Add(new RoyalMailIEndpointBehavior());
  }
  return shippingClient;
}
</code></pre>

<p>The namespaces should now be in the SOAP Envelope and the elements all use the correct prefix giving us something like;</p>

<pre><code>&lt;s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/" xmlns:v2="http://www.royalmailgroup.com/api/ship/V2" xmlns:v1="http://www.royalmailgroup.com/integration/core/V1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;s:Header&gt;&lt;/s:Header&gt;
  &lt;s:Body&gt;
    &lt;v2:createShipmentRequest&gt;
      &lt;v2:integrationHeader&gt;
        &lt;v1:dateTime&gt;2015-07-23T20:37:07.937+01:00&lt;/v1:dateTime&gt;
        &lt;v1:version&gt;2&lt;/v1:version&gt;
        &lt;v1:identification&gt;
          &lt;v1:applicationId&gt;SOME RANDOM ID&lt;/v1:applicationId&gt;
          &lt;v1:transactionId&gt;SOME RANDOM ID&lt;/v1:transactionId&gt;
        &lt;/v1:identification&gt;
      &lt;/v2:integrationHeader&gt;
    &lt;/v2:createShipmentRequest&gt;
  &lt;/s:Body&gt;
&lt;/s:Envelope&gt;
</code></pre>
