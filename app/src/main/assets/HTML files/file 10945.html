<p>Your solution should work and if you want to keep it simple it seems to be a good approach. </p>

<h3>Note</h3>

<p>You should load your assemblies in another domain because of the fact that, if you update your application, you gonna load the same types at the same namespaces. This gonna lead to conflicts. The other way is to restart your application.</p>

<h3>Dependencies</h3>

<p>You do not need to package all dependencies as a resource. Use a binary file which is downloaded, unpacked ( zip ) and contains all assemblies.</p>

<p>To do this you can use a simple approach( Pack / Unpack ):</p>

<ul>
<li>Write / Read ( client-side ) the name of the assembly</li>
<li>Write / Read the byte-size of the binary file as Int32</li>
<li>Write the bytes of the assembly into the file / Read the bytes of the assembly and write it to disk or a custom file system</li>
<li>Continue this until each file is packed / unpacked</li>
</ul>

<p>When resolving the dependencies you could use something similarly to this sample: <a href="http://stackoverflow.com/questions/8308312/assembly-loaded-using-assembly-loadfrom-on-remote-machine-causes-securityexcep/8308355#8308355">Assembly loaded using Assembly.LoadFrom() on remote machine causes SecurityException</a></p>

<h3>Updates</h3>

<p>Its also possible to use this system to create update packages for each version update ( e.g. <code>1.0 -&gt; 1.5</code> or <code>1.3 -&gt; 1.5</code> ). This avoids a lot of traffic if you check the deprecated files first and create a package for each version update.</p>
