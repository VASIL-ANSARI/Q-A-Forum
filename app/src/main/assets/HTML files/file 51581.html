<p>Let me explain.</p>

<p>In usual program you can use one of two valid forms of <code>main</code>:</p>

<pre><code>int main()

int main(int argc, char **argv) // arguments' names do not matter here
</code></pre>

<p>The difference between them is that second form allows your program to take command-line arguments.
<hr>
But SDL uses a special <code>main</code> related hack.</p>

<p>SDL has <code>#define main SDL_main</code> somewhere in the headers.<br>
Because of that, preprocessor will replace <code>int main(...)</code> with <code>int SDL_main(...)</code>.</p>

<p>Actual <code>main()</code> is located somewhere in SDL code. It does some initialization and then calls your "<code>main</code>" (which is <code>SDL_main</code>).</p>

<p>Actual <code>main()</code> may look like this:</p>

<pre><code>extern SDL_main(int, char **);

int main(int argc, char **argv)
{
    // SDL initialization
    SDL_main(argc, argv);
}
</code></pre>

<p>It shows why you can's use <code>int main()</code>. SDL source has no prototype for <code>int SDL_main()</code> because C does not support function overloading. There can be only one prototype for <code>SDL_main</code> and SDL developers decided that it should be <code>int SDL_main(int, char **)</code>.</p>

<p>The reasons for this are clear: Many applications need to work with command line arguments. And many programmers are used to work with <code>int main(int, char **)</code> when they want to read a command line arguments.</p>
