<p>No quick solution that comes to mind, no.</p>

<p>If you create the NSData object (rather than it being returned by another API), you might consider subclassing <code>NSData</code> and/or <code>NSMutableData</code> when you really need to avoid the copy -- then you could access the storage (std::vector) directly.</p>

<p>You may also be able to sneak around it in some cases by creating the data with 'your' allocation:</p>

<pre><code>NSData * data([[NSData alloc]
                 initWithBytesNoCopy:vector.data()
                              length:vector.size()
                        freeWhenDone:false]);
</code></pre>

<p>of course, you need to make sure the vector is not resized (or its backing store reallocated) before the <code>NSData</code> object is deallocated.</p>

<p>Sometimes you also need to consider changing the parameter type so that it is not a <code>std::vector</code>. A little container which has a <code>NSData</code> member and a vector-like interface, iterator, or begin+end may be adequate while accommodating other collections types.</p>
