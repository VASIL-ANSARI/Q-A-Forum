<p>Your encryption method is not invertible, and so you cannot reliably decrypt a general binary message with it. The problem occurs because it is possible for two different plaintext values to encrypt to the same ciphertext value, and when this happens there's no way for you to determine when decrypting which was the correct input value.</p>

<p>Example:</p>

<pre><code>if inByte = 100 and keyByte = 100:
    ApplyVernam(100, 100) = 100

if inByte = 0, keyByte = 100:
    ApplyVernam(0, 100) = 100
</code></pre>

<p>It's now impossible to tell whether the original plaintext byte was <code>0</code> or <code>100</code> when trying to decrypt.</p>

<p>I would suggest removing the line: <code>if (inByte == keyByte) { return inByte; }</code> from your <code>ApplyVernam</code> method so that it always <code>XORs</code> the input with the key and so is fully invertible.</p>

<p>As mentioned in my comment, your "key" is the byte at position 1 in the input, but this is also being encrypted, and so when you decrypt, the byte at position 1 is no longer the original key. Changing the following line may resolve the issue:</p>

<p>From:</p>

<pre><code>this.ResBytes[x] = this.ApplyVernam(this.FileBytes[x], this.FileBytes[1]);
</code></pre>

<p>To:</p>

<pre><code>this.ResBytes[x] = x == 1 ? this.FileBytes[x] : this.ApplyVernam(this.FileBytes[x], this.FileBytes[1]);
</code></pre>

<p>This will ensure that the key byte is written unencrypted to the output.</p>
