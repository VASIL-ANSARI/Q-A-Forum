<p>If you use threads, you can't increase efficiency as you wish, because it won't do paarallelization. You need to do multiprocessing. To do that, you can use the mulltiprocessing  module, which works like threading module :</p>

<pre><code>import multiprocessing

class MyProcess(multiprocessing.Process):

    def run(self):
        # new process context
</code></pre>

<p>You won't share the same context so you can't communicate directly by methods calls. I advise you to use some "message queue" system like : multiprocessing.Queue or zeromq (great great lib !).</p>

<p>If you look at "Ventillator" zmq design pattern you'll see it do exactly what you need : paralellize workers.</p>
