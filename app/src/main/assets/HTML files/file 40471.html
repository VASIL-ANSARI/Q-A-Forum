<ol>
<li><p><strong>Create a shared assembly.</strong> This will be loaded into both AppDomains ("Launcher" Domain, "Loaded" Domain) and serve as an entry point of our "Loaded" AppDomain:</p>

<p>Add a new project > Class library > Name: <code>ChildDomainLoader</code></p>

<p>Add the following references to the new project: <code>System.Xaml</code>, <code>WindowsBase</code>, <code>PresentationFramework</code></p>

<p>Add a project reference for <code>ChildDomainLoader</code> in your <code>Launcher</code> project. The <code>Loaded</code> project doesn't have to be modified.</p></li>
<li><p><strong>Add some code to the shared assembly.</strong> We need a MarshalByRefObject that can be called cross-domain and loads our child assembly. Let's call it <code>Runner</code>:</p>

<pre><code>using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Windows;

namespace ChildDomainLoader
{
    public class Runner : MarshalByRefObject
    {
        public static AppDomain RunInOtherDomain(string assemblyPath)
        {
            var ownType = typeof (Runner);
            string ownAssemblyName = ownType.Assembly.FullName;

            // Create a new AppDomain and load our assembly in there.
            var childDomain = AppDomain.CreateDomain(Guid.NewGuid().ToString());
            childDomain.Load(ownAssemblyName);

            // Call Run() in other AppDomain.
            var runner = (Runner) childDomain.CreateInstanceAndUnwrap(ownAssemblyName, ownType.FullName);
            runner.Run(assemblyPath);

            return childDomain;
        }

        public void Run(string assemblyPath)
        {
            // We load the assembly as byte array.
            var otherAssemblyBytes = File.ReadAllBytes(assemblyPath);
            var assembly = AppDomain.CurrentDomain.Load(otherAssemblyBytes);

            AppDomain.CurrentDomain.AssemblyResolve += (sender, args) =&gt;
            {
                throw new NotImplementedException("Probably need to do some work here if you depend on other assemblies.");
            };

            // Set the assembly as ResourceAssembly, as WPF will be confused otherwise.
            Application.ResourceAssembly = assembly;

            // Search for the App class.
            var app = assembly
                .GetExportedTypes()
                .Single(t =&gt; typeof(Application).IsAssignableFrom(t));

            // Invoke its Main method.
            MethodInfo main = app.GetMethod("Main", BindingFlags.Static | BindingFlags.Public);
            main.Invoke(null, null);
        }
    }
}
</code></pre></li>
<li><p><strong>Use it.</strong> Call <code>Runner.RunInOtherDomain</code> from your Launcher application.</p>

<pre><code>var assemblyPath = "path to your loaded.exe";
ChildDomainLoader.Runner.RunInOtherDomain(assemblyPath);
File.Delete(assemblyPath);
</code></pre></li>
</ol>
