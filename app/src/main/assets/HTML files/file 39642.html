<p>If you are using spring mvc you can keep what you're doing and add a contolleradvice something like this:</p>

<pre><code>import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import javax.validation.ConstraintViolationException;

@ControllerAdvice
public class RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler {

    @ExceptionHandler(value = { ConstraintViolationException.class})
    protected ResponseEntity&lt;Object&gt; handleNotAuthenticated(RuntimeException ex, WebRequest request) {

        // String message =  extract violation message from exception

        return handleExceptionInternal(ex, message, 
          new HttpHeaders(), HttpStatus.NOT_ACCEPTABLE, request);
    }

}
</code></pre>

<p>Add logic to extract your message from the exception and change the HttpStatus to the one you like. The message will be returned in your response body.</p>

<p>If you can put your constraints on your DTO you can use the @Valid annotation in your controller, like this:</p>

<pre><code>@RequestMapping(value = "/stepoption", method = RequestMethod.POST)
public String setOption(@Valid ExecutionStepOption  stepoption) {

        return "whatever";

}
</code></pre>

<p>Which will return the custom message.</p>
