<p>A couple of thoughts spring to mind immediately:</p>

<p>1)
    <code>for (int m = 0; m &lt; Cover.length; m++) {
        Cover[m] = mc;
    }
</code></p>

<p>This block starts <code>m</code> over at <code>0</code> every time through the loop. This means you're always writing over the same portion of the <code>Cover</code> array. So effectively, it's only the last frame's data that's stored. You probably meant</p>

<pre><code>for(int m = i * frames.size(); m &lt; (i+1)*frames.size(); i++) {
    Cover[m] = mc;
}
</code></pre>

<p>But this raises a further issue -- you're writing the same value (<code>mc</code>) into the entire area allocated for a whole frame of data. You probably want to merge this loop with the previous loop so that this doesn't happen.</p>

<pre><code>for (int c = 0; c &lt; finMc.length; c++) {
    Cover[i * frames.size() + c] = (int)finMc[c];
 }
</code></pre>

<p>2)  <code>int mc = (int) finMc[c];</code></p>

<p>That line casts the value to an <code>int</code> which truncates the value stored at <code>finMc[c]</code>. If <code>finMc[c]</code> is between <code>0</code> and <code>1</code> this will yield <code>0</code> when the data is copied and casted. This is compounded by the previous issue which ensures that only the last frame's data ever gets copied. This is simply solved by removing the cast and declaring Cover as an array of <code>double</code>s instead of <code>int</code>s.</p>

<p>So in sum, the code might work a bit better if it's written this way:</p>

<pre><code>double[] Cover = new double[frames.size() * nParam];

for (int i = 0; i &lt; frames.size(); i++) {
    double[] finMc = Gos.getVek(frames.get(i));
    for (int c = 0; c &lt; finMc.length; c++) {
        Cover[i * frames.size() + c] = finMc[c];
    }
}
</code></pre>
