<blockquote>
  <p>How do they achieve this in a single scroll area</p>
</blockquote>

<p>It is not a "single scroll area" containing the entire disk. It is a scrollbar and dynamically generated content for whatever disk content you are showing at the time. </p>

<p>Simply calculate the position based on the scroll location (unless your screen is 10000's of pixels tall, however, you will not be able to place the cursor EXACTLY on the disk sector you want). </p>

<blockquote>
  <p>also provide the undo functionality in that....</p>
</blockquote>

<p>Undo functionality, I expect (I haven't looked at the code) is done by holding "address changed, old value" in some sort of container. Pretty much the same way you'd do undo information for any other large dataset. </p>

<blockquote>
  <p>which widget should be used to display such a huge amount of data.????</p>
</blockquote>

<p>One which shows text and allows you to intercept the redraw and provide your own data on each redraw operation. I'm afraid I don't know QT very well, so can't advice on the details. </p>

<p>Obviously, one factor you haven't covered is "how do you open/mount the whole disk in read-write mode when it is already mounted" - I'm not sure if it allows this, but if it does, I expect there is a disk filter driver involved that has "sideways" interfaces to allow updates behind the scenes of the filesystem.</p>

<p>Edit: In answer to the question in the comment:</p>

<p>There are two options, either write to disk whenever the data is changed. In which case the code needs to remember all the original values, and restore them when the user does the <code>undo</code> operation. The alternative, which is approximately the same effort is to store all the edits, ("change value at 1000 to 05"), and then when asked to display some content, process any edits within the displayed range before the actual display operation. </p>

<p>Obviously, if someone decides to play "monkey on keyboard" for many many hours (weeks, months) to fill the ENTIRE disk with rather random content, then that would be a problem to "remember" all that without running out of memory, so you probably need a "I've run out of memory to store undo-information, do you want to save what you have done so far?" type option. </p>

<p>One could also consider a "same value stored in a large section" type compression (e.g. if you have a "fill from A to B with value X", you store simply that "from A to B we have filled with X", rather than store, potentially, many megabytes of "A = X, A+1 = X, A+2 = X ... B-1=X, B=X"). </p>
