<p>One option is to rewrite it to</p>

<pre><code>template &lt;class P, class Q&gt;
class MyClass {
  private:
    P p;
    Q q;
};
</code></pre>

<p>and instead uses like</p>

<pre><code>MyClass&lt;A, B, C, D, E&gt;
</code></pre>

<p>change them to</p>

<pre><code>MyClass&lt;P&lt;A, B&gt;, Q&lt;C, D&gt;&gt;
</code></pre>

<p>This, with correct use of typedefs, <em>may</em> reduce the amount of boilerplate.</p>

<p>Another option is to pay with runtime performance by applying some type erasure (i.e. use less templates).</p>

<p><strong>EDIT:</strong> following your edit, in your concrete code, you can generalize your class to work with any pairs of iterators:</p>

<pre><code>template&lt;class I1, class I2&gt;
class MapWrapper {
  private:
    std::map&lt;I1, I2&gt; _map;

  public:
    void insert_in_map (I1 one, I2 two) {
        _map[one] = two;
    }
};
</code></pre>

<p>Depending on the algorithmic part, this may, or may not, make sense.</p>
