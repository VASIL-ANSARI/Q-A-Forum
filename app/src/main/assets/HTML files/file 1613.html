<p>There's no sequence point with the <code>&lt;&lt;</code> operator so the compiler is free to evaluate either <code>dequeue</code> function first. What is guaranteed is that the result of the second <code>dequeue</code> call (in the order in which it appears in the expression and not necessarily the order in which it is evaluated) is <code>&lt;&lt;</code>'ed to the result of <code>&lt;&lt;</code>'ing the first (if you get what I'm saying).</p>

<p>So the compiler is free to translate your code into some thing like any of these (pseudo intermediate c++). This isn't intended to be an exhaustive list.</p>

<pre><code>auto tmp2 = myQueue.dequeue();
auto tmp1 = myQueue.dequeue();
std::ostream&amp; tmp3 = cout &lt;&lt; tmp1;
tmp3 &lt;&lt; tmp2;
</code></pre>

<p>or</p>

<pre><code>auto tmp1 = myQueue.dequeue();
auto tmp2 = myQueue.dequeue();
std::ostream&amp; tmp3 = cout &lt;&lt; tmp1;
tmp3 &lt;&lt; tmp2;
</code></pre>

<p>or</p>

<pre><code>auto tmp1 = myQueue.dequeue();
std::ostream&amp; tmp3 = cout &lt;&lt; tmp1;
auto tmp2 = myQueue.dequeue();
tmp3 &lt;&lt; tmp2;
</code></pre>

<p>Here's what the temporaries correspond to in the original expression.</p>

<pre><code>cout &lt;&lt; myQueue.dequeue() &lt;&lt; myQueue.dequeue();
|       |               |    |               |
|       |____ tmp1 _____|    |_____ tmp2 ____|
|                       |
|________ tmp3 _________|
</code></pre>
