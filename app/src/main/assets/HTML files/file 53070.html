<p>One of the best available opensource solution is <a href="https://github.com/google/benchmark" rel="nofollow">google benchmark</a> .
You have to create simple wrappers around code you want to benchmar and link either statically or dynamically with the lib. It is often useful to have such micro benchmarks compiled near with your code. For inspiration see <a href="https://www.youtube.com/watch?v=nXaxk27zwlk" rel="nofollow">awesome presentation</a>.</p>

<pre><code>static void BM_F(benchmark::State&amp; state) {
  const auto input1 = state.range_x();
  const auto input2 = state.range_y();

  while (state.KeepRunning()) F(input1, input2);
}

static void BM_D(benchmark::State&amp; state) {
  const auto input1 = state.range_x();
  const auto input2 = state.range_y();

  while (state.KeepRunning()) D(input1, input2);
}

BENCHMARK(BM_F)
    -&gt;ArgPair(1, 10)
    -&gt;ArgPair(10, 100)
    -&gt;ArgPair(100, 1000);

BENCHMARK(BM_D)
    -&gt;ArgPair(1, 10)
    -&gt;ArgPair(10, 100)
    -&gt;ArgPair(100, 1000);
</code></pre>

<p>If you want to measure raw CPU cycles, then your only choice is to use direct CPU instructions. For x86 you can use <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter" rel="nofollow">Time Stamp Counter</a>. But you should be aware, that such measuring will not resist any context switches performed by OS or jumping on CPUs. Your only choice in such situation will be to use algo with single flow of execution, remember ID of CPU and TSC value before enter to test function, and check ID of CPU after test function. Then calculating difference between TSC values. You may also setup CPU affinity for your process to stick process to specific CPU.</p>

<p>Another Linux specific possible way to benchmark functions is to use <a href="https://perf.wiki.kernel.org/index.php/Main_Page" rel="nofollow">perf tool</a>.</p>

<p>But in any way, any measure will add some error level to the result.</p>
