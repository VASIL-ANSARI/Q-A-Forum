<p>Just use <code>str.join</code>, add a <code>_</code> before the ch if the ch/letter is uppercase, else just keep the letter/ch as is:</p>

<pre><code>s=  "HeLLo Capital Letters"

print("".join(["_" + ch if ch.isupper() else ch for ch in s]))
_He_L_Lo _Capital _Letters
</code></pre>

<p>You run into issues because you are calling replace on the whole string each time so the repeated L's for example end up with three <code>_</code>.</p>

<p>If you add a  <code>print value,word</code> at the start of the loop you will see what happens:</p>

<pre><code>HeLLo Capital Letters H
_HeLLo Capital Letters e
_HeLLo Capital Letters L
_He_LLo Capital Letters L # second L
_He__LLo Capital Letters o # after replacing twice we now have double _
 ........................
</code></pre>

<p>Some timings against a regex shows a list comp is the best approach:</p>

<pre><code>In [13]: s = s * 50

In [14]: timeit "".join(["_" + ch if ch.isupper() else ch for ch in s])
10000 loops, best of 3: 98.9 Âµs per loop

In [15]: timeit  r.sub( r'_\1', s)
1000 loops, best of 3: 296 Âµs per loop
</code></pre>
