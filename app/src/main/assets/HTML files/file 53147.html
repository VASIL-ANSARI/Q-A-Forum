<p>Thanks to everyone who commented, I'm unable to give you proper recognition since you solved it here and there in the comments.</p>

<p>I was able to make it work (with numbers staying numbers) by changing <b>two</b> things in my code:</p>

<p>1) <b>Stringify</b> the data before sending it</p>

<p>2) Set <b>contentType</b> to the desired value, in my case "application/json"</p>

<pre><code>var jqXHR = $.ajax({
    url:baseURL+"/"+name,
    contentType:"json",
    crossDomain:true,
    data:data,
    method:method,
    success: function(data,status,xhr){
        busyIndicator.hide();
        console.log("success, status: "+status);
        console.log("--&gt; RESPONSE: "+JSON.stringify(data));
        if (callbackSuccess!="") window[callbackSuccess](data);
    },
    error:function(xhr,status,err){
        busyIndicator.hide();
        console.log("error, status: "+status);
        console.log(err);
        genericFailure("Errore nella chiamata al service: "+err);           
    }
});
</code></pre>

<p>Server-side I could properly access the object without any extra parsing/stringifying e.g.</p>

<pre><code>var dataBaseName = request.body.db;
</code></pre>

<p>Finally, as Kevin B pointed out, you also need to set</p>

<pre><code>dataType: "json"
</code></pre>

<p>in the call, if you expect an object to be returned, otherwise you'll have a stringified one. This is "json" and not "application/json" as it is for contentType.</p>
