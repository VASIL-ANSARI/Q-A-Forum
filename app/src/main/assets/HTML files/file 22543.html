<p>Sure, as long as the object's non-<code>mutable</code> state doesn't change as a result of being moved from.</p>

<p>Perhaps you have an object that corresponds to file content, or a database record.  And it caches that data when accessed, in a <code>mutable</code> member.  Now, you could move that object by stealing its cached data, without actually modifying the object.  So it would make sense (insofar as it makes sense for the object to be movable at all) for that object to have move constructor and move assignment operator that take <code>const Record&amp;&amp;</code>.</p>

<p>This is perfectly legal, section 12.8p3 of the C++11 Standard provides that:</p>

<blockquote>
  <p>A non-template constructor for class <code>X</code> is a move constructor if its first parameter is of type <code>X&amp;&amp;</code>, <strong><code>const X&amp;&amp;</code></strong>, <code>volatile X&amp;&amp;</code>, or <code>const volatile X&amp;&amp;</code>, and either there are no other parameters or else all other parameters have default arguments.</p>
</blockquote>

<p>and p19:</p>

<blockquote>
  <p>A user-declared move assignment operator <code>X::operator=</code> is a non-static non-template member function of class <code>X</code> with exactly one parameter of type <code>X&amp;&amp;</code>, <strong><code>const X&amp;&amp;</code></strong>, <code>volatile X&amp;&amp;</code>, or <code>const volatile X&amp;&amp;</code>.</p>
</blockquote>

<p>In this way, you could move a <code>const</code> object, <code>reopen</code> the new <strike>copy</strike> whatever-you-call-an-instance-created-via-move, thus reusing the buffer space for something else and avoiding a new allocation, while leaving the old object intact and ready to return its content (by hitting the disk or database again) if required.</p>
