<p>In order to be able to get anything done, the standard invented a list of goodness, and the order in which different things would be tried.  There are series of lectures on C9 from STL that go into this in length.</p>

<p>First, the template instantiates a solution for each of the three cases.
The second version picks <code>func(Parent)</code> because it matches exactly, and wins over the template.  The third call takes the templated version over a conversion which is considered "less good".</p>

<p>My only thought on preventing this would be to do some horrible SFINAE that tests for every T that it can't be inherited from <code>Parent</code> using type traits.  Concepts in C++17 might allow for something slightly less convoluted.</p>

<p>See</p>

<p><a href="https://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Core-C-/Stephan-T-Lavavej-Core-C-2-of-n" rel="nofollow">Stephan T. Lavavej: Core C++, 2 of n - Template Argument Deduction</a></p>

<p><a href="https://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Core-C-/Stephan-T-Lavavej-Core-Cpp-3-of-n" rel="nofollow">Stephan T. Lavavej: Core C++, 3 of n - Overload Resolution</a></p>
