<p><code>list()</code> does make a copyâ¦Â but it's a <em>shallow</em> copy. When you call <code>a = list(b)</code>, a is a brand-new list, but it's referring to the same objects as <code>b</code>. If those objects are themselves lists, then you haven't done what you wanted to.</p>

<p>To do a "2-level" copy, you can just use a list comprehension:</p>

<pre><code>a = [list(x) for x in b]
</code></pre>

<p>To do a all-the-way-down copy (which also takes care of tricky cases, like strings being made up of strings), use the <a href="http://docs.python.org/2/library/copy.html#copy.deepcopy" rel="nofollow"><code>deepcopy</code></a> function in the stdlib.</p>

<hr>

<p>For debugging these kinds of things, it helps to use the <code>is</code> operator or the <code>id</code> function. For example:</p>

<pre><code>&gt;&gt;&gt; list1 = [['x', 'y', 0],
...         ['m', 'n', 0],
... ]
&gt;&gt;&gt; dict2 = {'first': list(list1),
...         'second': list(list1),
... }
&gt;&gt;&gt; id(dict2['first'])
4398414856
&gt;&gt;&gt; id(dict2['second'])
4398414920
&gt;&gt;&gt; id(dict2['first'][0])
4378407688
&gt;&gt;&gt; id(dict2['second'][0])
4378407688
</code></pre>

<p>You can easily see that <code>first</code> and <code>second</code> are two different listsâ¦ but they have the same first element.</p>

<hr>

<p>Or, alternatively, run your code in an interactive visualizer, like <a href="http://pythontutor.com/visualize.html#code=list1+%3D+%5B%5B%27x%27,+%27y%27,+0%5D,%0A++++++++%5B%27m%27,+%27n%27,+0%5D,%0A%5D%0A%0Adict2+%3D+%7B%27first%27%3A+list%28list1%29,%0A++++++++%27second%27%3A+list%28list1%29,%0A%7D&amp;mode=display&amp;cumulative=false&amp;heapPrimitives=false&amp;drawParentPointers=false&amp;textReferences=false&amp;showOnlyOutputs=false&amp;py=2&amp;curInstr=4" rel="nofollow">this one</a>.</p>
