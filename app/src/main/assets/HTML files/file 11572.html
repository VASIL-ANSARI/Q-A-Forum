<p>This because the array <code>i[2]</code> is local to the <code>initj()</code> function. Therefore, once the function returns, it is no longer valid. So the pointer <code>j</code> becomes a dangling pointer.</p>

<p>So you have invoked undefined behavior.</p>

<p>As for why these two lines behave the way they do:</p>

<pre><code>Serial.println(j[0]); //111 -&gt; right
Serial.println(j[0]); //768 -&gt; wrong!
</code></pre>

<p>Even though the values are lost, they still happen to be on the stack. So when you access it before you call <code>Serial.println</code>, you get the "right" value. But that function call ends up overwriting the stack. So on the second call, it gives the wrong value.</p>

<p>But in any case, it's still undefined behavior. Anything is allowed to happen.</p>

<hr>

<p>To fix this, you need to put the values in a scope that is visible to the <code>setup()</code> function. You can either declare <code>i[2]</code> globally, or in <code>setup()</code> and pass it into the <code>initj()</code> function.</p>

<p>You can also dynamically allocate the array in heap memory with <code>malloc()</code>. (and be sure to free it later with <code>free()</code>)</p>
