<p>Given the hex-encoded output, we can see how the two strings differ. The first one reads <code>65cc80</code> where the second reads <code>c3a8</code>. This shows that you are a victim of <a href="http://en.wikipedia.org/wiki/Unicode_equivalence" rel="nofollow">non-normalized Unicode strings</a>.</p>

<p>The first sequence corresponds to the two Unicode characters <code>U+0065</code> (<a href="http://www.fileformat.info/info/unicode/char/65/index.htm" rel="nofollow">LATIN SMALL LETTER E</a>) and <code>U+0300</code> (<a href="http://www.fileformat.info/info/unicode/char/300/index.htm" rel="nofollow">COMBINING GRAVE ACCENT</a>). As you can see, concatenating their UTF-8 encoded forms gives the hex-encoded byte sequence <code>0x65cc80</code>.</p>

<p>The second sequence corresponds to the single Unicode character <code>U+00E8</code> (<a href="http://www.fileformat.info/info/unicode/char/e8/index.htm" rel="nofollow">LATIN SMALL LETTER E WITH GRAVE</a>), which encodes to <code>0xc3a8</code>.</p>

<p>What's going on here is that you have two byte sequences which are not bit-identical, but are logically equivalent by the Unicode rules. When you want to compare the strings you need either an encoding- and normalization-aware comparison function <em>or</em> you need to normalize the strings beforehand (you can then use a dumb comparison function such as string equality).</p>

<p>Unfortunately I don't know of any way to do a logical equivalence comparison in PHP, so the solution is to install the intl extension and use the <a href="http://php.net/manual/en/normalizer.normalize.php" rel="nofollow"><code>Normalizer</code></a> class to convert both strings to Normalization Form C with <a href="http://www.php.net/manual/en/normalizer.normalize.php" rel="nofollow"><code>Normalizer::normalize</code></a>.</p>
