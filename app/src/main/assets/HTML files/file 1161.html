<p>Before Java 5 there was only one: the <code>synchronized</code> keyword. This waited for and obtained an exclusive lock on the reference object. When applied to a function:</p>

<pre><code>public synchronized void doStuff() { ... }
</code></pre>

<p>the object being synchronized on is <code>this</code>.</p>

<p>Java 5 added a lot of concurrency utils, one of which was the <a href="http://72.5.124.55/javase/6/docs/api/java/util/concurrent/locks/Lock.html" rel="nofollow"><code>Lock</code></a> object. There are several versions of this including a <a href="http://72.5.124.55/javase/6/docs/api/java/util/concurrent/locks/ReadWriteLock.html" rel="nofollow"><code>ReadWriteLock</code></a>. This is the only thing I can think of that you might be referring to.</p>

<p>The problem with <code>synchronized</code> is that its fairly crude. Done badly it can lead to deadlocks. The Java 5 utils allow non-blocking lock acquisition, timeout on lock acquisition and read/write lock support.</p>
