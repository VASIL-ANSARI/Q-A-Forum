<p>Yes, there are ways to implement the Null object pattern without explicitly using a Java <code>interface</code>. However, you are really doing much the same thing so YMMV. You might find problems if you don't have access to the base class and/or it doesn't allow for some form of extending/overriding.</p>

<ul>
<li><p>Create a class which extends your base class but which does the 'null' operations by overriding them. You would generally hide it behind some kind of static constructor for ease of access.</p>

<pre><code>class Base {
    public void someMethod() {
        // this stuff does the non-null behaviour
    }

    public static Base nullVersion() {
        return new NullOfBase();
    }

    private static class NullOfBase extends Base {
        @Override
        public void someMethod() {
           // this guy does the null version.
        }
    }
}
</code></pre></li>
<li><p>Use an anonymous class on a static 'NULL' class member, which overrides the various operations you need to override.</p>

<pre><code>public class Base {
   public static final Base NULL = new Base() {
        @Override
        public void someMethod() {
           // this guy does the null version.
        }
    }

    public void someMethod() {
        // this stuff does the non-null behaviour
    } 
}
</code></pre></li>
<li><p>Use an abstract class to hold the operations which are common to both the non-null and null implementations, marking those methods as final, all other methods are abstract and implemented in two concrete classes - one for the non-null functionality and another for the null functionality. You might use static constructors to keep common use cases easy to construct and concrete class names hidden from view.</p>

<pre><code>public abstract class Base {
     public final sayHello() {
         System.out.println("Hello world");
     }

     public abstract void someMethod();

     public static Base nonNullVersion() {
         return new NonNullBase();
     }

     public static Base nullVersion() {
         return new NullBase();
     }

     private static final class NonNullBase extends Base {
        @Override
        public void someMethod() {
            // this stuff does the non-null behaviour
        }
     }

     private static final class NullBase extends Base {
        @Override
        public void someMethod() {
            // this stuff does the null behaviour
        }
     }
}
</code></pre></li>
</ul>

<p>Alternatively, sometimes a NULL-object is really just a special case of a particular value (it really depends on what the operations on the class are). In that case you could either have a static member with that value or a static factory which allows you to create it. </p>
