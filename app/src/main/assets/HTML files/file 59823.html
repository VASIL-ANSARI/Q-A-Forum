<p><strong><em>tl;dr:</em> it's a consequence of the relevant constructor being <code>explicit</code>.</strong></p>

<p>When you initialise with <code>=</code>, you invoke copy-initialisation. C++ does not allow copy-initialisation of a <code>shared_ptr</code> from a raw pointer, because it would be too easy to end up with an accidental implicit conversion from some arbitrary raw pointer into a <code>shared_ptr</code> that doesn't actually manage it.</p>

<p>This way, the only way you can "ensnare" a raw pointer into a <code>shared_ptr</code> is very deliberately and very explicitly (as you have correctly done in your second example). Now, only in this initialiser do you have to remember not to do so with a pointer you're already managing elsewhere.</p>

<p>Is there anything actually dangerous about the specific line <code>std::shared_ptr&lt;A&gt; ptr = new A()</code>? No. But what you're seeing is a consequence of various C++ rules working together in concert.</p>
