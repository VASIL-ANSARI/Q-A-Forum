<p>Well, I just wrote up a little test, trying 3 different ways of creating a string from an IEnumerable:</p>

<ol>
<li>using <code>StringBuilder</code> and repeated invocations of its <code>Append(char ch)</code> method.</li>
<li>using <code>string.Concat&lt;T&gt;</code></li>
<li>using the <code>String</code> constructor.</li>
</ol>

<p>10,000 iterations of generating a random 1,000 character sequence and building a string from it, I see the following timings in a release build:</p>

<ul>
<li>Style=StringBuilder
elapsed time is 00:01:05.9687330 minutes.</li>
<li>Style=StringConcatFunction
elapsed time is 00:02:33.2672485 minutes.</li>
<li>Style=StringConstructor
elapsed time is 00:04:00.5559091 minutes.</li>
</ul>

<p><code>StringBuilder</code> the clear winner. I'm using a static <code>StringBuilder</code> (singleton) instance, though. Dunno if that makes much difference.</p>

<p>Here's the source code:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Security.Cryptography;
using System.Text;

namespace ConsoleApplication6
{
  class Program
  {

    static readonly RandomNumberGenerator Random = RandomNumberGenerator.Create() ;

    static readonly byte[] buffer = {0,0} ;

    static char RandomChar()
    {
      ushort codepoint ;
      do
      {
        Random.GetBytes(buffer) ;
        codepoint = BitConverter.ToChar(buffer,0) ;
        codepoint &amp;= 0x007F ; // restrict to Unicode C0 ;
      } while ( codepoint &lt; 0x0020 ) ;
      return (char) codepoint ;
    }

    static IEnumerable&lt;char&gt; GetRandomChars( int count )
    {
      if ( count &lt; 0 ) throw new ArgumentOutOfRangeException("count") ;

      while ( count-- &gt;= 0 )
      {
        yield return RandomChar() ;
      }
    }

    enum Style
    {
      StringBuilder = 1 ,
      StringConcatFunction = 2 ,
      StringConstructor = 3 ,
    }

    static readonly StringBuilder sb = new StringBuilder() ;
    static string MakeString( Style style )
    {
      IEnumerable&lt;char&gt; chars = GetRandomChars(1000) ;
      string instance ;
      switch ( style )
      {
      case Style.StringConcatFunction :
        instance = String.Concat&lt;char&gt;( chars ) ;
        break ;
      case Style.StringBuilder : 
        foreach ( char ch in chars )
        {
          sb.Append(ch) ;
        }
        instance = sb.ToString() ;
        break ;
      case Style.StringConstructor :
        instance = new String( chars.ToArray() ) ;
        break ;
      default :
        throw new InvalidOperationException() ;
      }
      return instance ;
    }

    static void Main( string[] args )
    {
      Stopwatch stopwatch = new Stopwatch() ;

      foreach ( Style style in Enum.GetValues(typeof(Style)) )
      {
        stopwatch.Reset() ;
        stopwatch.Start() ;
        for ( int i = 0 ; i &lt; 10000 ; ++i )
        {
          MakeString( Style.StringBuilder ) ;
        }
        stopwatch.Stop() ;
        Console.WriteLine( "Style={0}, elapsed time is {1}" ,
          style ,
          stopwatch.Elapsed
          ) ;
      }
      return ;
    }
  }
}
</code></pre>
