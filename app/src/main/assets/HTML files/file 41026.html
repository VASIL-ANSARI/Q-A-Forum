<p>Â§13.3.1.2 [over.match.oper]/p3 (emphasis added):</p>

<blockquote>
  <p>for a binary operator <code>@</code> with a left operand of a type whose
  cv-unqualified version is <code>T1</code> and a right operand of a type whose
  cv-unqualified version is <code>T2</code>, three sets of candidate functions,
  designated <em>member candidates</em>, <em>nonmember candidates</em> and <em>built-in
  candidates</em>, are constructed as follows:</p>
  
  <ul>
  <li>[...]</li>
  <li>The set of non-member candidates is the result of the unqualified lookup of <code>operator@</code> in the context of the expression according to
  the usual rules for name lookup in unqualified function calls (3.4.2)
  except that all member functions are ignored. <strong>However, if no operand
  has a class type, only those non-member functions in the lookup set
  that have a first parameter of type <code>T1</code> or âreference to (possibly
  cv-qualified) T1â, when <code>T1</code> is an enumeration type, or (if there is a
  right operand) a second parameter of type <code>T2</code> or âreference to
  (possibly cv-qualified) <code>T2</code>â, when <code>T2</code> is an enumeration type, are
  candidate functions.</strong></li>
  <li>[...]</li>
  </ul>
</blockquote>

<p>In plainer English, if neither operand has a class type, then you need to have an exact match on an enumeration operand for the overload to be considered, which is why <code>my = MyEnum::zero + MyEnum::two;</code> does not work. <code>my = MyEnum::zero + MyEnum(MyEnum::two);</code>, oddly enough, compiles in GCC but not Clang. I can't find anything that makes it not legal, so I'm suspecting that this might be a compiler bug.</p>
