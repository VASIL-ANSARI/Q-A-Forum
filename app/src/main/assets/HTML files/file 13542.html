<p>Yes. For example, there is <a href="http://docs.python.org/reference/datamodel.html#object.__radd__"><code>__radd__</code></a>. Also, <a href="http://docs.python.org/reference/datamodel.html#object.__lt__">there are none</a> for <code>__le__()</code>, <code>__ge__()</code>, etc., but as Joel Cornett rightly observes, if you define only <code>__lt__</code>, <code>a &gt; b</code> calls the <code>__lt__</code> function of <code>b</code>, which provides a workaround.</p>

<pre><code>&gt;&gt;&gt; class My_Num(object):
...     def __init__(self, val):
...         self.val = val
...     def __radd__(self, other_num):
...         if isinstance(other_num, My_Num):
...             return self.val + other_num.val
...         else:
...             return self.val + other_num
... 
&gt;&gt;&gt; n1 = My_Num(1)
&gt;&gt;&gt; n2 = 3
&gt;&gt;&gt; 
&gt;&gt;&gt; print n2 + n1
4
&gt;&gt;&gt; print n1 + n2
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: 'My_Num' and 'int'
</code></pre>

<p>Note that in at least some cases it's reasonable to do something like this: </p>

<pre><code>&gt;&gt;&gt; class My_Num(object):
...     def __init__(self, val):
...         self.val = val
...     def __add__(self, other_num):
...         if isinstance(other_num, My_Num):
...             return self.val + other_num.val
...         else:
...             return self.val + other_num
...     __radd__ = __add__
</code></pre>
