<p>For CPython, there is no good answer for this that doesn't involve writing a Python C extension, since <code>mlock</code> works on pages, not objects. Even if you used <code>ctypes</code> to retrieve the necessary addresses and <code>mlock</code>-ed them all through <code>ctypes</code> <code>mlock</code> calls, you'll have a hell of a time determining when to <code>mlock</code> and when to <code>munlock</code>. You'd need to know the memory address and sizes of all protected data types; since <code>mlock</code> works on pages, you'd have to carefully track how many objects are currently in any given page (because if you just <code>mlock</code> and <code>munlock</code> blindly, and there are more than one things to lock in a page, the first <code>munlock</code> would unlock all of them; <code>mlock/munlock</code> is a boolean flag, it doesn't count the number of locks and unlocks).</p>

<p>Even if you manage that, you still would have a race between data acquisition and <code>mlock</code> during which the data could be written to swap.</p>

<p>You could partially avoid these problems through careful use of the <code>mmap</code> module and <code>memoryview</code>s (<code>mmap</code> gives you pages of memory, <code>memoryview</code> references said memory without copying it, so <code>ctypes</code> could be used to <code>mlock</code> the page), but you'd have to build it all from scratch.</p>

<p>In short, Python doesn't care about swapping or memory protection in the way you want; it trusts the swap file to be configured to your desired security (e.g. disabled or encrypted), neither providing additional protection nor providing the information you'd need to add it in.</p>
