<p>Function <code>memcpy</code> doesn't modify source memory. That means it doesn't require a non-const pointer, it <strong>allows</strong> a const pointer as well as a non-const pointer. This is not a restriction on the parameter nor on the applicability of the function. You may pass any valid data pointer in there.</p>

<p>This is called an implicit conversion by compiler. In your particular case with <code>const</code> it is <a href="http://en.cppreference.com/w/cpp/language/implicit_cast" rel="nofollow">"Qualification conversion"</a>.</p>

<pre><code>unqualified type can be converted to const
</code></pre>

<p>Opposite implicit conversion from a const pointer to a pointer is not allowed. Note word "<em>implicit</em>" here. That means <code>func(void *pointer)</code> is more restrictive than <code>func(void const *pointer)</code>.</p>

<p>If you omit <code>const</code> qualifier you leverage compiler imposed type safety. Compiler will warn you or others that it won't be a good idea to  pass a const pointer in.</p>

<p>If you use <code>const</code> qualifier in a function declaration you make a promise that you won't modify data there. This is a good hint to a programmer and improves readability of your code. However, this is a promise only. A bad function may violate the promise by casting out const-ness inside the function body. This is technically possible but bad.</p>
