<p>The depth buffer stores the "depth" of the topmost pixel that was drawn at that location. When you try to draw another pixel at that location, if it has a depth value <strong>above</strong> the value currently in the buffer, it will get drawn to the colour buffer and its depth value will replace the value in the depth buffer. But if another pixel comes along with a depth value <strong>below</strong> what is in the buffer - it is not drawn and the value in the depth buffer stays the same.</p>

<p>The upshot of this is that <strong>the depth buffer does not work as expected with transparent pixels</strong>. A transparent pixel may only result in a partial change of the colour buffer - but it completely replaces the value in the depth buffer. There is no way to draw "under" it.</p>

<p>There are two ways to solve this problem:</p>

<p>You could use <strong>alpha testing</strong>, which causes transparent pixels not to be rendered at all (and not change the depth buffer). This allows geometry to show through the transparent areas, independent of draw-order. The downside is that this does not work well with anti-aliasing (there is a good discussion of the anti-aliasing options <a href="http://blogs.msdn.com/b/shawnhar/archive/2011/05/06/antialiasing-alpha-cutouts.aspx" rel="nofollow">here</a>).</p>

<p>Or you could <strong>sort your geometry in back-to-front order</strong>. You only have to sort your transparent geometry, if you draw your opaque geometry first.</p>
