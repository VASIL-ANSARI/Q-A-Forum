<p>I think your problem boils down to wanting to pass the arrays of gladiators to another class. That should be fairly easy. If you in your main-class have these two defintions (note you only need one, I recommend the list as it is more versatile, arrays have fixed-length).</p>

<p>You want something like this:</p>

<pre><code>public class Main {
// ....stuff
// This is the main class that keeps the list of gladiators
private List&lt;Gladiator&gt; gladiatorsList;
private Gladiator[] gladiatorsArray;
private MovementAI movementAI;

public Main() {
    // You initialize gladiatorsList and gladiatorsArray as before
    // gladiatorsList = ...
    // gladiatorsArrray = ...
    // Now you want to pass this list/array to another class (the AI), you
    // can do this in the constructor of that class like so:
    movementAI = new MovementAI(gladiatorsList);
}

// ...stuff as before

}
</code></pre>

<p>The AI</p>

<pre><code>public class MovementAI {

private List&lt;Gladiator&gt; gladiators;

// Giving the class the list-reference, this list will be the same as the
// list in main, when main-list changes so does this one, they point to the
// same list-object, so the reference is only needed once.
public MovementAI(List&lt;Gladiator&gt; gladiatorsList) {
    this.gladiators = gladiatorsList;
}

// The class already has a reference to the list from its constructor so it
// doesn't need the list again as a parameter
public void moveAI() {

}

// If you don't want to keep a reference to the list in this class but only
// use it in a method (I would not recommend this)
public MovementAI() {

}

// You need to pass it gladiatorsList everytime you call this method.
public void moveAI(List&lt;Gladiator&gt; gladiators) {

}

}
</code></pre>

<p>I see in your last comment that you have decided to let the AI decide to repaint if it meets a criteria, that is not recommended, you should keep responsibilities separate in your classes, less error-prone and better development. It is recommended to let the AI change the list of gladiators (move them, kill them etc) and the rendererclass simply paint every gladiator.</p>

<p>It also seems you want to have every gladiator be able to hold another gladiator as a target, it is better for them to hold the target as an Object, this way you don't have to search the entire list to find out which gladiator the gladiatornumber refers to and you don't have to think about ordering in the list. Something like this:</p>

<pre><code>public class Gladiator {
// ..other stuff

private Gladiator target;
public Gladiator getTarget() {
    return target;
}

public void setTarget(Gladiator target) {
    this.target = target;
}
}
</code></pre>
