<p>How about:</p>

<pre><code>from numpy.core.umath_tests import inner1d
Z = inner1d(X,Y)
</code></pre>

<p>For example:</p>

<pre><code>X = np.random.normal(size=(10,5))
Y = np.random.normal(size=(10,5))
Z1 = inner1d(X,Y)
Z2 = [np.dot(X[k],Y[k]) for k in range(10)]
print np.allclose(Z1,Z2)
</code></pre>

<p>returns <code>True</code></p>

<p><strong>Edit</strong> Correction since I didn't see the 3D part of the question</p>

<pre><code>from numpy.core.umath_tests import matrix_multiply
X = np.random.normal(size=(10,5,3))
Y = np.random.normal(size=(10,3,5))
Z1 = matrix_multiply(X,Y)
Z2 = np.array([np.dot(X[k],Y[k]) for k in range(10)])
np.allclose(Z1,Z2)  # &lt;== returns True
</code></pre>

<p>This works because (as the docstring states), <code>matrix_multiply</code>provides</p>

<blockquote>
  <p>matrix_multiply(x1, x2[, out]) matrix</p>
  
  <p>multiplication on last two dimensions</p>
</blockquote>
