<p><a href="http://docs.python.org/reference/expressions.html#summary" rel="nofollow"><code>and</code> has a higher precidence than <code>or</code></a>, so the <code>and</code>s are evaluated first, then the <code>or</code>, meaning that the logic you have described in text is not the logic you have described in code.</p>

<p>If you want the first <code>or</code> to be treated as a single case, then use brackets around it.</p>

<pre><code>if (len(content_tags) &gt;= 1 or tags_irrelevant == 'yes')\
   and lengthproblem == 0\
   and guess_language.guessLanguage(testlanguage) == 'en'\
   and len(sentences) &gt;= 3:
</code></pre>

<p>That said, you haven't given us a detailed explanation of the logical behaviour you <em>want</em> from this, so I'd suggest sitting down and working that out properly.</p>

<p>If you need to test your logic, then use a simple test function that prints out so you know what gets evaluated and when.</p>

<pre><code>&gt;&gt;&gt; def test(bool):
...    print(bool)
...    return bool
... 
&gt;&gt;&gt; if test(1) or test(2) and test(3) and test(4) and test(False):
...    print("Success")
... 
1
Success
&gt;&gt;&gt; if (test(1) or test(2)) and test(3) and test(4) and test(False):
...     print("Success")
... 
1
3
4
False
</code></pre>

<p>You can clearly see the first thing evaluated is the first <code>and</code>, then it tries to evaluate the left hand side of the <code>and</code> and so gets the <code>or</code>. It tries to evaluate this, gets <code>True</code> for the first value, and so short-circuits, returning <code>True</code> to the <code>and</code>, which also short circuits, returning <code>True</code> (well, actually 1, but <code>True</code> for the purposes of this example). When the brackets are there, it is evaluated in the way you wanted.</p>
