<p>Template function definitions like that can't be defined in a separate translation unit. This is an annoying limitation of how C++ templates work. There is an <code>export</code> keyword that is supposed to help, but it doesn't actually do what it seems like it's supposed to.</p>

<p>Either put the definition of the <code>operator&lt;&lt;</code> into the header file directly (this is fine and will not cause multiple symbol definition errors, again because of how templates work), or put it there indirectly by <code>#include</code>ing it from another file (don't give it a <code>.cpp</code> file ending, for organizational purposes - although the compiler doesn't really care about your file extensions; by convention, most people use <code>.i</code> or <code>.inl</code> for such a file).</p>

<p>By the way, the type <code>std::string</code> does not come from <code>&lt;string.h&gt;</code>. That is a C header. It comes from <code>&lt;string&gt;</code>. If it's working for you, it's only by coincidence (many implementations of <code>&lt;iostream&gt;</code> include <code>&lt;string&gt;</code>. Also, consider using <code>&lt;iosfwd&gt;</code> instead of <code>&lt;iostream&gt;</code> in header files to improve compile times (although that won't really help you here, since you need the full <code>&lt;iostream&gt;</code> header for the template implementation).</p>
