<p>You could disable the input element until data is available, An <a href="http://knockoutjs.com/documentation/extenders.html" rel="nofollow">Extender</a> can do this.</p>

<p>The markup:</p>

<pre><code>&lt;select data-bind="serviceMethod:getOptions, options: options, enable:options.enable&gt;&lt;/select&gt;
</code></pre>

<p>The viewmodel:</p>

<pre><code>function viewModel(){
    this.options=ko.observableArray().extend( { enabled:false});       
}
</code></pre>

<p>The binding handler:</p>

<pre><code>ko.bindingHandlers.serviceMethod = {
     init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
        var getOptionsFunction=valueAccessor();
        // deferred implemented as a callback
        getOptionsFunction(function(r){
           allBindings().options(r);               
           // call extender observable to enable the input
           allBindings().options.enabled(true); 
        } );
    },
    update:function (element, valueAccessor, allBindings, viewModel, bindingContext) {
    }    
</code></pre>

<p>The extender:</p>

<pre><code>ko.extenders.enabled = function(target, option) {
    target.enabled=ko.observable(option);
    return target;
};
</code></pre>

<p>The <a href="http://jsfiddle.net/9Cd76/" rel="nofollow">fiddle</a></p>

<p><strong>note</strong>: I would move the logic to the view model, in our project we made mistakes to put too much coding in binding handlers that should go to viewModels.</p>
