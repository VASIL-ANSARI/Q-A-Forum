<p>I'm not too familiar with Jison's inner workings, so I don't know any method that would do it.</p>

<p>But in case you're interested in a little bruteforce to solve this problem, try this:</p>

<p>First, create an object to hold the AST</p>

<pre><code>function jisonAST(name, x) { this.name = name; this.x = x; }

// return the indented AST
jisonAST.prototype.get = function(indent){
  // create an indentation for level l
  function indentString(l) { var r=""; for(var i=0;i&lt;l;i++){r+="  "}; return r }

  var r = indentString(indent) + "["+this.name+": ";
  var rem = this.x;
  if( rem.length == 1 &amp;&amp; !(rem[0] instanceof jisonAST) ) r += "'"+rem[0]+"'"; 
  else for( i in rem ){ 
      if( rem[i] instanceof jisonAST ) r += "\n" + rem[i].get(indent+1);
      else { r += "\n" + indentString(indent+1); r += "'"+rem[i]+"'"; }
    }
  return r + "]";
}
</code></pre>

<p>Add a little helper function for Jison's BNF</p>

<pre><code>function o( s ){
    r = "$$ = new yy.jisonAST('"+s+"',[";
    for( i = 1; i &lt;= s.split(" ").length; i++ ){ r += "$"+i+"," }
    r = r.slice(0,-1) + "]);";
    return [s,r];
}
</code></pre>

<p>With this, continue to the example code (slight modification):</p>

<pre><code>var Parser = require("jison").Parser;

// a grammar in JSON
var grammar = {
    "lex": {
        "rules": [
           ["\\s+", "/* skip whitespace */"],
           ["[a-f0-9]+", "return 'HEX';"]
        ]
    },
    "bnf": {
        // had to add a start/end, see below
        "start" : [ [ "hex_strings", "return $1" ] ],
        "hex_strings" :[ 
            o("hex_strings HEX"), 
            o("HEX") 
        ]
    }
};

var parser = new Parser(grammar);
// expose the AST object to Jison
parser.yy.jisonAST = jisonAST
</code></pre>

<p>Now you can try parsing:</p>

<pre><code>console.log( parser.parse("adfe34bc e82a 43af").get(0) );
</code></pre>

<p>This will give you:</p>

<pre><code>[hex_strings HEX: 
  [hex_strings HEX: 
    [HEX: 'adfe34bc']  
    'e82a']  
  '43af']
</code></pre>

<p><em>Small note</em>: I had to add a "start" rule, in order to only have one statement that returns the result. It is not clean (since the BNF works fine without it). Set it as an entry point to be sure...</p>
