<p>Let <code>j = k - 1</code>, and let <code>unset_bit</code> be the lowest power of two such that <code>(j &amp; unset_bit) == 0</code>.</p>

<p>If <code>(j | unset_bit) &lt;= n</code>, then we pick <code>a = j</code> and <code>b = j | unset_bit</code> for the optimal value of <code>(a &amp; b) == j</code>.</p>

<p>If <code>(j | unset_bit) &gt; n</code>, then no possible choice of <code>a</code> and <code>b</code> will give us <code>(a &amp; b) == j</code>. We simply don't have two numbers to pick with all the necessary bits set. Since an even <code>j</code> would have given us <code>(j | unset_bit) == j+1 &lt;= n</code>, we must have <code>j</code> odd. Then picking <code>a = j - 1</code> and <code>b = j</code> gives us <code>(a &amp; b) == j - 1</code>, the highest possible value.</p>

<hr>

<p>The code you saw on HackerRank implements this idea. In the code you found, their <code>a</code> is our <code>j</code>, and their <code>b</code> is our <code>unset_bit</code>, computed through some bit twiddling tricks. I've used <code>j</code> and <code>unset_bit</code> instead of <code>a</code> and <code>b</code> because you've already used those letters for other meanings.</p>
