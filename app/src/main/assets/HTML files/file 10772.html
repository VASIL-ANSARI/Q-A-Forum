<p>Not tested, but it seems like it would work...</p>

<pre><code>void conv(const double v1[], size_t n1, const double v2[], size_t n2, double r[])
{
    for (size_t n = 0; n &lt; n1 + n2 - 1; n++)
        for (size_t k = 0; k &lt; max(n1, n2); k++)
            r[n] += (k &lt; n1 ? v1[k] : 0) * (n - k &lt; n2 ? v2[n - k] : 0);
}
</code></pre>

<h3>Tip: <em>If it takes less time to reinvent a wheel than to find one, do consider the former.</em></h3>
