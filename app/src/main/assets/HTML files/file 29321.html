<p>Part of the design the test-driven-development should drive you towards in dependency injection. Often when you find something hard to unit-test, it is because you need to rethink your design.</p>

<p>In this case, your subject-under-test probably should be reasonable for creating <code>SomeObject</code>. Instead it should be provided to it someone. Perhaps it is something that should be provided when the class you're testing it is first instantiated, perhaps it is something that should be  provided when you call the method. For example:</p>

<pre><code>public class ClassBeingTested
{    
  public ClassBeingTested(SomeObject so)
  {
    // Inject class dependency when instantiated the class
  }

  void MethodIAmTesting(SomeObject so)
  {
    // Passing things needed for a function to complete its work
  }   
}
</code></pre>

<p>Also, you'll most likely want to create an interface for SomeObject. Then you can create a stub for it and easily test what calls are made on it, stub behavior/properties, etc. When you do things this way, it becomes much easier to test things. For example, let's consider how you might write a test to ensure that <code>_someService</code> is provided with <code>SomeObject</code>:</p>

<pre><code>void EnsureSomeObjectPassedToService()
{
   // arrange
   SomeObject so = new SomeObject()
   // act
   _mainClass.MethodIAmTesting(so);
   // assert
   _someObject.AssertWasCalled(x =&gt; x.AnotherMethodCall(so));
}
</code></pre>

<p>That's it! Very easy when you do things right.</p>
