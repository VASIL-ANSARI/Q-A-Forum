<p>This <em>type</em> of problem is pretty common due to how <code>BinaryFormatter</code> stores the underlying type data, which can cause problems if that they doesn't resolve to <strong>exactly</strong> the same <code>BasketItem</code> that you had in mind. Most frequently, this hurts when changing the version of your application / library, or when there are different servers with different states.</p>

<p>My <strong>strong advice</strong> here is: don't let it use <code>BinaryFormatter</code> to store the state! It is <strong>not</strong> very version friendly, in both this regard and a few other issues <em>within</em> a type. If it is possible, I urge you to consider strong <em>contract-based</em> data instead (meaning: virtually anything other than <code>BinaryFormatter</code> / <code>NetDataContractSerializer</code>). Examples:</p>

<ul>
<li>you could use <code>JavaScriptSerializer</code> and store a basic <code>string</code> of the data</li>
<li>you could use <code>XmlSerializer</code> and store a basic <code>string</code> of the data</li>
<li>if you want binary, you could use protobuf-net and strore a <code>byte[]</code> of the data</li>
</ul>

<p>You would obviously then use helper methods to store/retrieve your data, normally with a generic <code>void Store&lt;T&gt;(string key, T object)</code> and <code>T Retreive&lt;T&gt;(string key)</code>, using <code>typeof(T)</code> internally as-necessary. The advantage of this is that the stored data is now neutral of any particular implementation, and can be consumed by other versions of your application (since nothing is type-dependent), and even by other platforms (Java, php, etc) if necessary.</p>

<p>I appreciate this is a side-step <em>around</em> the problem rather than a direct solution - but: it works.</p>
