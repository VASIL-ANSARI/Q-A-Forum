<p>I have written a small test case for what you want and I cannot reproduce, that <code>std::this_thread::sleep_for()</code> does not give the expected result.</p>

<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;

int main() {
        std::this_thread::sleep_for(std::chrono::seconds(2));
        return 0;
}
</code></pre>

<p>This will give me (compiled using <code>g++ -o slow slow.cpp -std=c++11</code>) when run with <code>time ./slow</code>:</p>

<pre><code>real    0m2.001s
user    0m0.000s
sys     0m0.000s
</code></pre>

<p>Thus giving the expected time of about 2 seconds.</p>

<p>Please notice that <code>std::this_thread::sleep_for</code> will block the current thread for <strong>at least</strong> the given duration. So it might block a few milliseconds longer than expected. See <a href="http://en.cppreference.com/w/cpp/thread/sleep_for" rel="nofollow">here</a>:</p>

<blockquote>
  <p>Blocks the execution of the current thread for at least the specified
  sleep_duration.</p>
  
  <p>A steady clock is used to measure the duration. This function may
  block for longer than sleep_duration due to scheduling or resource
  contention delays.</p>
</blockquote>
