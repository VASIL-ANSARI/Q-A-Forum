<p>The behaviour of <code>*(UINT32 *)&amp;Book1</code> is <em>undefined</em> in C++. This is because the types are <em>unrelated</em>. It would be particularly fragile on a 64 bit platform where pointers are larger than 32 bit.</p>

<p>You <em>could</em> get away with a cast to and from <code>void*</code>, but that's not really how things ought to be done in C++.</p>

<p>Why not move <code>printBook</code> <em>inside</em> the <code>books</code> <code>struct</code>? You can do that in C++: C++ <code>struct</code>s can accommodate member <em>functions</em> as well as member <em>data</em>. (And the C-style <code>typedef</code> idiom around your <code>struct</code> is not needed in C++).</p>

<p>Lastly, <code>#define UINT16 int</code> followed by <code>typedef unsigned int UINT32;</code> is just bizarre. Consider using the standard fixed sizes (e.g. <code>std::uint32_t</code>) if your compiler supports it.</p>
