<p>The first solution implies a recursive constructor call and will never work :</p>

<pre><code>Matrix&lt;T&gt;::Matrix(const Matrix&lt;T&gt;&amp; rhs) {
    Matrix&lt;T&gt; temp(rhs);
        ^^^^^^^^^^^^^^
    // Recursive call here
    this.swap(temp);
}
</code></pre>

<p>As for any potential performance difference, always use a profiler on a decent set of test cases. If your swap is correctly implemented, you will see with any decent compiler that the creation of the temporary for the swap has a negligible cost compared to the allocation/filling of the matrix.</p>

<p><strong>Note:</strong></p>

<p>As your links show, the copy-and-swap idiom is implemented by the assignment operator (which calls the copy constructor), not the copy constructor itself.</p>
