<p>You can still code in an object oriented style in C , simply using struct's as classes, and 'methods' are just functions that take a pointer to a class. I would create a general purpose 'ring-buffer' 'class' in C as follows..</p>

<pre><code>typedef struct RingBuffer {
  int elemSize;
  int headIndex; // index to write
  int tailIndex; // index to read
  int maxIndex;
  void* buffer; 
}
RingBuffer;
// initialize a new ring-buffer object
void RingBuffer_Init(RingBuffer* rb, int elemSize, int maxNum)  {
  rb-&gt;elemSize=elemSize; rb-&gt;headIndex = 0; rb-&gt;tailIndex=0; rb-&gt;buffer = malloc(elemSize*maxNum);
  rb-&gt;maxIndex=maxNum;
}
void RingBuffer_Read(RingBuffer* rb,  void* dstItem){ // copy into buffer, update index
   void* src=rb-&gt;buffer + rb-&gt;tailIndex*rb-&gt;elemSize;
   memcpy(dstItem,src,rb-&gt;elemSize);
   rb-&gt;tailIndex++; ....//wrapround, assert etc..
}
void RingBuffer_Write(RingBuffer* rb, const void * srcItem) {  // copy from buffer,update indices
}// etc..
</code></pre>

<p>you'd have to take care of allocating the RingBuffer structs of course, some people might do that with some macro if they adopt a consistent naming scheme for 'init'(equiv of c++ constructor) and 'shutdown'/'release' functions</p>

<p>Of course there are many permutations.. it would be very easy to make a ring buffer into which you can read/write variable sized elements, perhaps writing the element size into the buffer at each point. it would certainly be possible to resize on the fly aswell, even change the element size.</p>

<p>Although the language support for creating data structures is more primitive in C than in C++, sometimes re-working a problem to use simple data structures can have performance benefits. Also treating data structures as simple blocks of memory with size passed as a parameter may cause less compiler inlining: compact code can have advantages as the default method to use outside of inner loops (i-cache coherency).</p>

<p>it would be possible to combine the 'Buffer Header' structure and the array data into one allocation, (just assume the buffer data follows the header structure in memory), which reduces the amount of pointer-dereferencing going on.</p>
