<p>Well, according to the docs which I read, there doesn't seem to be an actual method that mirrors the functionality of the <code>FluentWait</code>. Instead, this snippet can be used to change poll frequency and it escapes almost all the exceptions (almost all).</p>

<pre><code>def wait_until(predicate, timeout_seconds, period=0.25, show_log=True):
    """
    @summary Call repeatedly the predicate until it returns true or timeout_seconds passed.
    @param predicate: a condition, modelized as a callable,  that will valued either as True or False
    @param timeout_seconds: the timeout in second
    @param period: the time to sleep between 2 calls to predicate. Defaults to 0.25s.
    @return True if a call to predicate returned True before timeout_seconds passed, else False
    """
    if show_log:
        myLogger.logger.info("waiting until predicate is true for {end} seconds".format(end=timeout_seconds))
    ultimatum = time.time() + timeout_seconds
    while time.time() &lt; ultimatum:
        myLogger.logger.debug("checking predicate for wait until : {spent} / {end}".format(spent=str(time.time() - (ultimatum - timeout_seconds)), end=timeout_seconds))
        try:
            if predicate():
                return True
            time.sleep(period)
        except Exception as e:
            myLogger.logger.warn("Exception found: {}".format(e))
    return False
</code></pre>

<p>Consequently, the predicate can be <code>lambda</code> that you pass which validates the state of the WebElement under question.</p>
