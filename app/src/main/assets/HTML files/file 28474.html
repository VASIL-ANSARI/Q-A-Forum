<p>First, Let's make a corrections on your code so that it works, thank I'd give some <code>Asynchronous Socket</code> tutorials which is a lot easier than <code>Synchronous</code>.</p>

<p>Your problem is in this line:</p>

<pre><code>public void ReceiveData()
{
    while (true)
    {
        var Client = Soc.Accept();
        ClientList.Add(Client);
        label3.Text = ClientList.Count.ToString() + "/" + MaxClients;
        textBox2.Text += " Client Located At Ip : " + Client.RemoteEndPoint.ToString().Split(':')[0].ToString() + " Is Now Connected To Server " + Environment.NewLine;
        while (true)
        {
            byte[] ReceivedBytes = new byte[1024];
            int ReceivedDataLength = Client.Receive(ReceivedBytes, 0, ReceivedBytes.Length, SocketFlags.None);
            string MessageFromClient = Encoding.Default.GetString(ReceivedBytes, 0, ReceivedDataLength);
            textBox2.Text += " Message Sent to Server : " + MessageFromClient + Environment.NewLine;
        }
    }
}
</code></pre>

<p>This is because of 2 reasons:
1) You must listen to incoming connection to a separate thread.
2) You must listen to each client in a separate thread too, so they don't block each other. In your example second <code>while(true)</code> which is listening for client is blocking server socket from accepting other clients. Refactor it to:</p>

<pre><code>public void ReceiveData()
    {
        new Thread(() =&gt;
        {
            while (true)
            {
                var Client = Soc.Accept();
                ClientList.Add(Client);
                label3.Text = ClientList.Count.ToString() + "/" + MaxClients;
                textBox2.Text += " Client Located At Ip : " + Client.RemoteEndPoint.ToString().Split(':')[0].ToString() + " Is Now Connected To Server " + Environment.NewLine;

                new Thread(() =&gt;
                {
                    while (true)
                    {
                        byte[] ReceivedBytes = new byte[1024];
                        int ReceivedDataLength = Client.Receive(ReceivedBytes, 0, ReceivedBytes.Length, SocketFlags.None);
                        string MessageFromClient = Encoding.Default.GetString(ReceivedBytes, 0, ReceivedDataLength);
                        textBox2.Text += " Message Sent to Server : " + MessageFromClient + Environment.NewLine;
                    }
                }).Start();
            }
        }).Start();
    }
</code></pre>

<p>This approach uses separate thread for each client to process received data from client.</p>

<p>I also added code for client app:</p>

<pre><code>public void ReceiveData()
    {
        new Thread(() =&gt;
        {
            while (true)
            {
                byte[] ReceivedBytes = new byte[1024];
                int ReceivedBytesLength = Client.Receive(ReceivedBytes, 0, ReceivedBytes.Length, SocketFlags.None);
                string ReceivedMessage = Encoding.Default.GetString(ReceivedBytes, 0, ReceivedBytesLength);
                textBox1.Text += " Received Message From Server Is : " + ReceivedMessage + Environment.NewLine;
            }
        }).Start();
    }
</code></pre>

<p>In the future have a look <code>Asynchronous Sockets</code> and you will no more need handling multithreading issues.
<a href="http://msdn.microsoft.com/en-us/library/fx6588te.aspx" rel="nofollow">http://msdn.microsoft.com/en-us/library/fx6588te.aspx</a>
<a href="http://msdn.microsoft.com/en-us/library/bbx2eya8.aspx" rel="nofollow">http://msdn.microsoft.com/en-us/library/bbx2eya8.aspx</a></p>

<p><em>EDIT</em> Updated client/ser</p>
