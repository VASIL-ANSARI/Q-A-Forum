<p>Change</p>

<pre><code>kernel.at&lt;uchar&gt;(k,l)
</code></pre>

<p>to:</p>

<pre><code>kernel.at&lt;double&gt;(k,l)
</code></pre>

<p>The point is that the default data type for the kernel is CV_64F, which corresponds to double (<a href="http://docs.opencv.org/modules/imgproc/doc/filtering.html#Mat%20getGaussianKernel%28int%20ksize,%20double%20sigma,%20int%20ktype%29" rel="nofollow">documentation</a>).</p>

<p>Also, check that your input image is strictly in grayscale. To support color, you will have to detect the image type in the beginning and differentiate your code. To create the color version of the function, you will have to start by using <code>.at&lt;cv::Vec3b&gt;</code> in place of <code>.at&lt;uchar&gt;</code> (and this of course won't be the only necessary modificatin).</p>

<p>I suggest also that you change your function declaration to:</p>

<pre><code>void filter(const Mat&amp; src, Mat&amp; dst, const Mat&amp; kernel) {
</code></pre>

<p>The rest of the algorithm looks ok, apart that it might be pretty slow, it would be much faster if you avoided using the <code>at</code> method, and constrained the for cycles so not to have to check if you are going to touch the image border, and if you stored in some local const variable your different <code>cv::Mat</code> sizes and use them in your loops. Finally, <code>sum(kernel)</code> is constant and therefore you can also precompute that value.</p>
