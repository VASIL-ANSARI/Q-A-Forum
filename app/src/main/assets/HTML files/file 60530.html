<p>You can convert the result to an object list, or you can pass in a type parameter rather than the <code>List</code> class.</p>

<pre><code>String jsonString = "[{\"id\": \"0\", \"ip\": \"123\", \"mac\": \"456\"}, {\"id\": \"1\", \"ip\": \"111\", \"mac\": \"222\"}]";
</code></pre>

<h3>With <code>Object</code></h3>

<pre><code>List&lt;Object&gt; items = objectMapper.readValue(
    jsonString,
    objectMapper.getTypeFactory().constructParametricType(List.class, Object.class)
);
</code></pre>

<h3>With <code>SlaveEntity</code></h3>

<pre><code>List&lt;SlaveEntity&gt; items = objectMapper.readValue(
    jsonString,
    objectMapper.getTypeFactory().constructCollectionType(List.class, SlaveEntity.class)
);
</code></pre>

<hr>

<h1>Update</h1>

<p>This is what I have come up with, and it works.</p>

<h3>EntityTest</h3>

<pre><code>import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.databind.ObjectMapper;

public class EntityTest {
    public static void main(String[] args) {
        String json = "[{\"id\": \"0\", \"ip\": \"123\", \"mac\": \"456\"}, {\"id\": \"1\", \"ip\": \"111\", \"mac\": \"222\"}]";

        for (SlaveEntity entity : jsonToSlaveEntity(json)) {
            System.out.println(entity);
        }
    }

    public static List&lt;SlaveEntity&gt; jsonToSlaveEntity(String json) {
        ObjectMapper objectMapper = new ObjectMapper();

        try {
           return objectMapper.readValue(
                   json,
                objectMapper.getTypeFactory().constructCollectionType(List.class, SlaveEntity.class)
            );

        } catch (IOException e) {
            e.printStackTrace();
        }
        return new ArrayList&lt;SlaveEntity&gt;();
    }
}
</code></pre>

<h3>BaseEntity</h3>

<pre><code>public class BaseEntity {
    private long id;

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }
}
</code></pre>

<h3>SlaveEntity</h3>

<pre><code>import java.util.List;

import javax.persistence.CascadeType;
import javax.persistence.FetchType;
import javax.persistence.OneToMany;

import com.fasterxml.jackson.annotation.JsonProperty;

public class SlaveEntity extends BaseEntity {
    private String ip;

    @JsonProperty("mac")
    private String macAddress;

    private String status;

    @OneToMany(mappedBy = "slave", targetEntity = PositionEntity.class, fetch = FetchType.EAGER, cascade = CascadeType.ALL)
    private List&lt;PositionEntity&gt; positions;

    public String getIp() {
        return ip;
    }

    public void setIp(String ip) {
        this.ip = ip;
    }

    public String getMacAddress() {
        return macAddress;
    }

    public void setMacAddress(String macAddress) {
        this.macAddress = macAddress;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public List&lt;PositionEntity&gt; getPositions() {
        return positions;
    }

    public void setPositions(List&lt;PositionEntity&gt; positions) {
        this.positions = positions;
    }

    @Override
    public String toString() {
        return String.format(
                "SlaveEntity [id=%d, ip=%s, mac=%s, status=%s, positions=%s]",
                getId(), ip, macAddress, status, positions);
    }
}
</code></pre>

<h3>PositionEntity</h3>

<pre><code>public class PositionEntity {
    // ?
}
</code></pre>

<h3>Result</h3>

<pre><code>SlaveEntity [id=0, ip=123, mac=456, status=null, positions=null]
SlaveEntity [id=1, ip=111, mac=222, status=null, positions=null]
</code></pre>
