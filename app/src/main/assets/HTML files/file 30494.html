<p>Whether your queries affect concurrency or not have to do with the types of queries. Having many read queries won't affect concurrency in MyISAM or InnoDB (besides performance issues).</p>

<p>Inserts (to the end of an index with InnoDB, or the end of a table with MyISAM) also don't impact concurrency.</p>

<p>However, as soon as you have an update query, rows get locked in InnoDB, and with MyISAM, it's the entire table that gets write locked. When you try to update a record (or table) that has a write lock, you must wait until the lock is released before you can proceed. In MyISAM, updates are served before reads, so you have to wait until the updates are processed.</p>

<p>MyISAM can be more performant because table locks are faster than record locks (though record locks are fast). However, when you start making a significant number of updates, InnoDB is generally preferred because different users are generally not likely to contend for the same records. So, with InnoDB, many users can work in parallel without affecting each other too much, thanks to the record level locking (rather than table locks).</p>

<p>Not to mention the benefit of full ACID compliance that you get with InnoDB, enforcement of foreign key constraints, and the speed of clustered indexes.</p>

<p>Snapshots (log entries) are kept long enough to complete the current transaction and are discarded if they are rolled back or committed. The longer a transaction runs, the more likely it is that other updates will occur, which grows the number of log entries required to roll back.</p>

<p>There will be no "cross-over" due to locking. When there is write contention for the same records, one user must wait until the other commits or rolls back.</p>

<p>You can read more about <a href="http://dev.mysql.com/doc/refman/5.1/en/innodb-transaction-model.html" rel="nofollow">The InnoDB Transaction Model and Locking</a>.</p>
