<p>I'd suggest you to use a <code>ISet&lt;T&gt;</code> instead of a <code>List&lt;T&gt;</code>, which makes elements unique for you. You can then decide whether or not to add an element by an <code>if</code>.</p>

<pre><code>var mySet = new SortedSet&lt;string&gt;();

while(dbReader.Read())
{
  if(dbReader["GenSubject"] != DBNull.Value)
  {
    var generalSubject = (string)dbReader["GenSubject"];
    if(!generalSublject.Equals("No related topics"))
    {
      mySet.Add(generalSubject); // returns false if already in Set
    }
    else
    {
      // do nothing
    }
}
</code></pre>

<p>Did this help you and answer your question? I hope I got you right and helped you with a simplified version of the code that focuses on the problem only. It has a few implications though:</p>

<ul>
<li>An <code>ISet</code> - typical implementations are <code>SortedSet</code> (tree based) and <code>HashSet</code> (hash based) - does not guarantee a particular <em>order</em> of the elements, but it does guarantee they're <em>unique</em>.</li>
<li>You can do a <code>Contains</code> on an <code>ISet</code> with (more or less) logarithmic rather than linear effort (might speed up your program measurably, depending on the number of elements).</li>
<li>You might also go for an SQL <code>DISTINCT</code> to make elements unique if suitable. However, this requires you to refactor the query.</li>
</ul>
