<p>Yikes!  The obvious answer is to refactor the library to <b>not do it like that</b>.  If that's impossible, you could design a class that stores all the parameter types (hopefully with more descriptive names!).</p>

<pre><code>class QPGenSparseWrapper
{
    // Only store params if you want to manage their memory.
    double* Param1;

public:
    QPGenSparseWrapper(const double* param1, const int param2 /* , ... */, param16 = 22) :
        Param1(param1),
    {
        newQpGenSparse(&amp;Param1, param2 /* , ... */, param16);
    }

    virtual ~QPGenSparseWrapper()
    {
        freeQpGenSparse(/* params */);

        // If no corresponding free, use smart pointers or manual delete.
    }

    void Run(/* more params?!? */)
    {
        // I hope you know what goes here.
    }
};
</code></pre>

<p>It almost goes without saying that you should provide sane defaults to as many of these parameters as possible in order to spare such heartache to future users.</p>
