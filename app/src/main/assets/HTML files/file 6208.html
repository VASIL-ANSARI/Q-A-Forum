<p>This doesn't work because of how closures work. </p>

<p>I'd do it like this:</p>

<pre><code>var makeAnimateStarter = function(point) {
  return function() {
     animateOn(point);
  };
};

for (var i = 0; i &lt; this.plotted.length; i++)
{
  var point = this.plotted[i];

  setTimeout(makeAnimateStarter(point), 700);
}
</code></pre>

<p>And it's not a problem from a stack point of view. Every time a timeout is executed, it's in a new call stack. That's why you require <code>_this</code>. <code>setTimeout()</code> is not suspending the thread at that point and then resuming it's executing the function fresh.</p>
