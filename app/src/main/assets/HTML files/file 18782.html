<p>WARNING: DO NOT DO THIS. YOU HAVE BEEN WARNED.</p>

<p>You can achieve this using operator overloading, but it is a very bad idea, as I'll explain later.</p>

<p>I'll assume class <code>Mat</code> has a constructor that takes a <code>Mat_&lt;int&gt;</code>.</p>

<p>I'll assume class template <code>Mat_&lt;T&gt;</code> has a method, <code>Insert()</code>, that knows how to insert a single element into a matrix. I'll let you work this out, but it'll need a way to know where to insert it.</p>

<p>Using this method it is easy to overload <code>operator&lt;&lt;</code>:</p>

<pre><code>template&lt;typename T&gt;
Mat_&lt;T&gt;&amp; operator&lt;&lt;(Mat_&lt;T&gt;&amp; mat, const T&amp; el)
{
  mat.Insert(el);
  return mat;
}
</code></pre>

<p>And we can overload <code>operator,</code> to call this overloaded <code>operator&lt;&lt;</code>:</p>

<pre><code>template&lt;typename T&gt;
Mat_&lt;T&gt;&amp; operator,(Mat_&lt;T&gt;&amp; mat, const T&amp; el)
{
  return mat &lt;&lt; el;
}
</code></pre>

<p>Everything works fine and you can use your syntax. Now I will explain why this is a bad idea.</p>

<p>Overloading <code>operator&lt;&lt;</code> this way is perfectly sensible. This is the insertion operator and our overload inserts an element into the matrix. This is what anybody would expect; so far, so good.</p>

<p>But overloading <code>operator,</code> is not. The meaning of this operator is "evaluate two expressions, then return the last one"; this is clearly not what our overloaded operator does. Unwary users will try to use operator <code>,</code> in the standard way (for instance, in a <code>for</code> loop) and will not understand why their code does not work. You should never overload an operator to do a non-standard operation unless you want to be hated by whoever uses your code; probably yourself sometime later.</p>

<p>In fact, while the standard allows overloading <code>operator,</code>, this is something you should probably never do, because it is impossible to write code that does the standard operation. You can consider this a mistake in the standard that is kept for backward compatibility.</p>

<p>And, in case you were considering overloading <code>operator,</code> to take two <code>int</code> and somehow bundle them together, not only the drawbacks are even more serious: it is illegal to overload an operator when all operands are built-in types.</p>

<p>So, in summary: you can do it, but it is a bad idea and will cause bugs in unexpected places of your code.</p>
