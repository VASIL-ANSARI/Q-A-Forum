<p><a href="https://msdn.microsoft.com/en-us/library/dd997364(v=vs.110).aspx" rel="nofollow">Cancellation is cooperative</a>. So, you should pass the <code>CancellationToken</code> down through your methods:</p>

<pre><code>private async Task&lt;bool&gt; myTask0(CancellationToken token) {
   var val2 = await myTask2(token);
   var val3 = await myTask3(token);            
   return true;
}

private async Task&lt;bool&gt; myTask1(CancellationToken token) {
   //run some tasks in paralell
   var myParallel= arrayValues.Select(fileBEanListItem =&gt; manageSrcFilesDownload(token).ToList();
   return true;
}

private async Task&lt;bool&gt; myTask2(CancellationToken token) {
    return await myTask3(token);
}
</code></pre>

<p>And so on, until you either pass the token to APIs that can take it (e.g., file download), or until you have your own code that uses <code>CancellationToken.ThrowIfCancellationRequested</code> or <code>CancellationToken.Register</code> to respond to cancellation.</p>

<p>On a side note, <a href="http://blog.stephencleary.com/2013/08/startnew-is-dangerous.html" rel="nofollow"><code>StartNew</code> is an anti-pattern</a>. As I explain on my blog, you should use <code>Task.Run</code> instead. In particular, <a href="http://blog.stephencleary.com/2015/03/a-tour-of-task-part-9-delegate-tasks.html" rel="nofollow">the <code>CancellationToken</code> parameter (for both <code>StartNew</code> and <code>Run</code>) only cancels the <em>scheduling</em> of the delegate</a>; they won't <em>abort</em> your code. For proper cancellation support, you have to write code that responds to a <code>CancellationToken</code>.</p>
