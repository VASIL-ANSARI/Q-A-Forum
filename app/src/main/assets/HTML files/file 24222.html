<p>The problem you're facing is called <a href="http://en.wikipedia.org/wiki/Parsing#Programming_languages" rel="nofollow">parsing</a> and there are numerous solutions to it. First, you can write your own "interpreter" for your mini-language, including lexer (which splits the string into tokens), parser (which builds a tree structure from a stream of tokens) and executor, which walks the tree and computes the final value. Or you can use a parser generator like <a href="http://pegjs.majda.cz/" rel="nofollow">PEG</a> and have the whole thing built for you automatically - you just provide the rules of your language. Finally, you can utilize javascript built-in parser/evaluator <code>eval</code>. This is by far the simplest option, but eval only understands javascript syntax - so you'll have to translate your language to javascript before eval'ing it. And since eval can run arbitrary code, it's not for use in untrusted environments.</p>

<p>Here's an example on how to use eval with your sample input:</p>

<pre><code>expr = "#VAR#&gt;=2AND$VAR2$==1OR@VAR3@&lt;=3"

vars = {
    "#": {"VAR":5},
    "$": {"VAR2":1},
    "@": {"VAR3":7}
}

expr = expr.replace(/([#@$])(\w+)(\1)/g, function($0, $1, $2) {
    return "vars['" + $1 + "']." + $2;
}).replace(/OR/g, "||").replace(/AND/g, "&amp;&amp;")

result = eval(expr) // returns true
</code></pre>
