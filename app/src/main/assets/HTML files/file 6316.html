<p>Just a guess here, but I wonder if this is a capture/closure issue. Try this:</p>

<pre><code>    public ObservableCollection&lt;PlumFile&gt; FoundFiles
    {
        get
        {
            ObservableCollection&lt;PlumFile&gt; searchResults = new ObservableCollection&lt;PlumFile&gt;();

            // get the data source
            IEnumerable&lt;PlumFile&gt; query = PlumData.GetFiles();

            foreach (FilterConstraint filter in filters)
            {
                var localFilter = filter;
                // debugging
                IList&lt;PlumFile&gt; oldQuery = query.ToList();

                switch (filter.QueryCombiningRule)
                {
                    case FilterConstraint.QueryRule.And:
                        query = query.Where(file =&gt; filter.Fits(file));
                        break;
                    case FilterConstraint.QueryRule.Or:
                        query = query.Concat(PlumData.GetFiles().Where(file =&gt; localFilter.Fits(file)));
                        break;

                    // is this really how I want to do 'not'?
                    case FilterConstraint.QueryRule.Not:
                        query = query.Where(file =&gt; !localFilter.Fits(file));
                        break;
                }

                // debugging
                IList&lt;PlumFile&gt; currQuery = query.ToList();

            }

            query = query.Distinct();

            foreach (PlumFile file in query)
            {
                searchResults.Add(file);
            }

            return searchResults;
        }
    }
</code></pre>
