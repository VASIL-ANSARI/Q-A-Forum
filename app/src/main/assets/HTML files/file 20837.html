<p>Pointers to <code>vector</code> elements can be invalidated when you call <code>vector::resize()</code>. This is because the entire data may have to be moved around in order to find a contiguous memory block that fits the new size. In other words: As soon as you call <code>resize</code>, all your <code>location</code> data suddenly becomes useless garbage.</p>

<p>Possible solutions:</p>

<ul>
<li>Let <code>location</code> store the index of the required element in <code>ctarr</code> as its value rather than a pointer. (This will certainly not change the semantics of your program.)</li>
<li>Let <code>location</code> store the actual <code>unsigned int</code>  value instead of a pointer. Depending on your program logic and how you change and access this data, this may not be what you want.</li>
</ul>

<p>Also note that although the segfault occurs in <code>hashtable_policy.h</code>, this bug has nothing to do with the implementation of <code>unordered_map</code> (or <code>vector</code>) - it is entirely your fault for not reading the reference for <code>vector::resize()</code> ;-) : <a href="http://www.cplusplus.com/reference/vector/vector/resize/" rel="nofollow">http://www.cplusplus.com/reference/vector/vector/resize/</a> (section 'Iterator validity') </p>

<hr>

<p>The other thing I noticed about your code is that you use <code>operator[]</code> for accessing your <code>vector</code> elements. This disables out-of-bounds checking. If I came across an error like yours in my code (hard to trace back because it occurs somewhere far from my erroneous code), my first course of action would be swapping <code>operator[]</code> for <code>vector::at()</code> (actually, I always start with <code>at()</code> and only switch if I can prove beyond reasonable doubt that bounds checking is a performance bottleneck for this particular purpose). This would not have helped with your problem, but is often an invaluable help in spotting mistakes.</p>
