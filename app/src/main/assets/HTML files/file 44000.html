<p>Couple of things. First, if you're using something like choice() that's imported from a wildcard import (from random import *), it would be useful to include that, because otherwise we're just guessing where you got that function from. Also, <a href="http://stackoverflow.com/questions/3615125/should-wildcard-import-be-avoided">wildcard imports are considered bad practice anyway</a>.</p>

<p>The problem is that the remove() method of a list returns None. You cannot choose something from None, because None is not an iterable. That is to say that the remove() method does not support chaining.
Try changing:</p>

<pre><code>if len(neighboor) != 0: new = choice(neighboor.remove(new)) # Passes None to choice() which raises an error
</code></pre>

<p>to</p>

<pre><code>if len(neighboor) != 0:
    neighboor.remove(new) # removes the element from neighboor
    new = choice(neighboor) # Chooses from the list as you intended
</code></pre>

<p>You could have other errors, but that's the one that came from the traceback you posted.</p>

<p>For the future, I recommend familiarizing yourself with Python's traceback, because it is telling you exactly what is going wrong. <a href="http://cbio.ufs.ac.za/live_docs/nbn_tut/understanding_errors.html" rel="nofollow">Here's a resource</a>.</p>

<p>As an aside, do you mean neighbor instead of neighboor?</p>
