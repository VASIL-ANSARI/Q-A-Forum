<p>I see here two tasks. The first is a refactoring where static dependencies have to be replaced with interfaces. The second task is to register your stuff in IoC container.</p>

<p>For the first task a minimum you need is to replace all references to <code>Database</code> in your <code>UserSearchService</code> with <code>IDatabase</code> interface (so that it can also be mocked) and allow it to be passed to constructor (constructor injection). To be able to provide an instance of <code>IDatabase</code> to the service you have to create the same dependency for the controller (again constructor injection). Then register the <code>IDatabase</code> implementation as shown in <a href="http://www.dotnet-tricks.com/Tutorial/dependencyinjection/632V140413-Dependency-Injection-in-ASP.NET-MVC-4-using-Unity-IoC-Container.html" rel="nofollow">this post</a>.</p>

<p><strong>Update</strong></p>

<p>I agree that dependency has to be removed from the controller. As you @Topojijo have suggested a factory for the <code>UserSearchService</code> can be used in this case. Guessing you have several cervices you need to make a factory for each and there may be an overhead if their count is large. In such case it's better to <a href="http://msdn.microsoft.com/en-us/library/ff664762%28v=pandp.50%29.aspx" rel="nofollow">resolve the service directly</a> from Unity container and move the <code>searchParams</code> to <code>Search</code> method:</p>

<pre><code>public Users[] GetUsers(string name) {
    Company.SearchParameters searchParams = new Company.SearchParameters(name);
    Company.UserSearchService searchService = container.Resolve&lt;Company.UserSearchService&gt;();

    return searchService.Search(searchParams);
}
</code></pre>
