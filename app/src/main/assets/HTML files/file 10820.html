<p>There is no sibling combinator that looks backward or around, only the adjacent and general sibling combinators that look forward.</p>

<p>The best you can do is determine a way to limit selection only to these <code>p</code> elements with the same parent, and then select the <code>p</code> children that are <code>:not(.green_guys)</code>. If the parent element has an ID of <code>#parent</code>, for example, you can use this selector:</p>

<pre class="lang-css prettyprint-override"><code>#parent &gt; p:not(.green_guys) {
    /* selects all &lt;p&gt; children of #parent that are not .green_guys */
}
</code></pre>

<p>However the above will still match your <code>p</code> elements even if <em>none</em> of them have the class. It is currently not possible to select the siblings of an element only given the <em>existence</em> of said element (which is the purpose of a sibling combinator â to establish a relationship between <em>two</em> sibling elements).</p>

<hr>

<p><a href="http://dev.w3.org/csswg/selectors-4/#relational" rel="nofollow">Selectors 4's <code>:has()</code></a> will hopefully rectify this without the need for a preceding-sibling combinator, resulting in the following solution:</p>

<pre class="lang-css prettyprint-override"><code>p:has(~ .green_guys), .green_guys ~ p {
    /* selects all &lt;p&gt; elements that are siblings of .green_guys */
}
</code></pre>

<p>This will not match anything if none of the children of the parent element have the class.</p>
