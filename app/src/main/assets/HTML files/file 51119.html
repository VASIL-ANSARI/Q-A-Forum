<p>In order to get the automatic alert asking the user for permission to use their location, then you will need to add the <code>NSLocationAlwaysUsageDescription</code> and/or <code>NSLocationWhenInUseUsageDescription</code> keys to your <code>Info.plist</code>, of course depending on which location update type you will make use of. It could look like the following:</p>

<pre><code>&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt;
&lt;string&gt;We need to know your location because it makes it easier to stalk you&lt;/string&gt;
&lt;key&gt;NSLocationAlwaysUsageDescription&lt;/key&gt;
&lt;string&gt;We need to know your location because it makes it easier to stalk you&lt;/string&gt;
</code></pre>

<p>===</p>

<h1>UPDATE 1</h1>

<p>OP provided more details about the problem</p>

<p>===</p>

<p>To make a POST request then you can either make use of <code>NSURLSession</code> or some popular third party networking library. Many people makes use of either <code>AFNetworking</code> (Obj-C) or <code>Alamofire</code> (Swift) to make their lives easier and code prettier. You can install both of these through CocoaPods.</p>

<p>The following example will be based on <code>Alamofire</code>, but the code will be very similar for <code>AFNetworking</code>. <code>NSURLSession</code> is a different case, which sometimes is needed in complex multi-threading apps or whenever you wanna provide better background support.</p>

<p><em>NOTE:</em> This code is simply a demo and is all contained in the same <code>UIViewController</code> which is bad practice. You will need to refactor it yourself into seperate models for better code. Also, the <code>NSDateFormatter</code> in the <code>NSDate</code> extension is highly inefficient. Also, this test makes use of HTTP, so ATS is turned off.</p>

<pre><code>//
//  ViewController.swift
//  LocationUpload
//
//  Created by Stefan Veis Pennerup on 13/11/15.
//  Copyright Â© 2015 Kumuluzz. All rights reserved.
//

import UIKit
import CoreLocation
import Alamofire

class ViewController: UIViewController, CLLocationManagerDelegate {

    // MARK: - Properties

    private let locationManager = CLLocationManager()
    private var tenSecTimer = NSTimer()
    private var sixtySecTimer = NSTimer()
    private var savedLocations = [CLLocation]()

    // MARK: - Storyboard outlets

    @IBOutlet weak var startButton: UIButton!

    // MARK: - Lifecycle methods

    override func viewDidAppear(animated: Bool) {
        super.viewDidAppear(animated)
        requestLocationAuthorization()
    }

    // MARK: - Storyboard actions

    @IBAction func startButtonClicked(sender: UIButton) {
        let buttonText = startButton.titleLabel?.text!
        let shouldTurnUpdatesOn = buttonText == "STARTA"
        toggleLocationUpdates(shouldTurnUpdatesOn)
    }

    // MARK: - Authorization

    private func requestLocationAuthorization() {
        self.locationManager.requestAlwaysAuthorization()
        if CLLocationManager.locationServicesEnabled() {
            locationManager.delegate = self
            locationManager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters
        }
    }

    // MARK: - Helper methods

    private func toggleLocationUpdates(toggle: Bool) {
        if toggle {
            tenSecTimer = NSTimer.scheduledTimerWithTimeInterval(10,
                target:self,
                selector: Selector("tenSecTimer:"),
                userInfo: nil, repeats: true)
            sixtySecTimer = NSTimer.scheduledTimerWithTimeInterval(60,
                target: self,
                selector: Selector("sixtySecondsTimer:"),
                userInfo: nil, repeats: true)
            locationManager.startUpdatingLocation()
            startButton.setTitle("STOPPA", forState: UIControlState.Normal)
            startButton.backgroundColor = UIColor.redColor()
        }
        else {
            tenSecTimer.invalidate()
            sixtySecTimer.invalidate()
            locationManager.stopUpdatingLocation()
            startButton.setTitle("STARTA", forState: UIControlState.Normal)
            startButton.backgroundColor = UIColor.greenColor()
        }
    }

    // MARK: - CLLocationManagerDelegate

    func locationManager(manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        print("\(self.dynamicType), locationManager:didUpdateLocations")
        savedLocations += locations
    }

    // MARK: - Callback methods

    func sixtySecondsTimer(timer : NSTimer) {
        print("\(self.dynamicType), sixtySecondsTimer")
        uploadLocationsToBackend(savedLocations)
    }

    func tenSecTimer(timer : NSTimer) {
        print("\(self.dynamicType), tenSecTimer")
    }

    // MARK: - Parsers

    private struct JsonConstants {
        static let Locations = "locations"
        static let Timestamp = "timestamp"
        static let Latitude = "latitude"
        static let Longitude = "longitude"
    }

    private func parseLocationsToDictionary(locations: [CLLocation]) -&gt; [String: AnyObject] {

        var locationsDictionaries = [[String: AnyObject]]()

        for loc in locations {
            let locDict: [String: AnyObject] = [
                JsonConstants.Timestamp: loc.timestamp.toISO8601(),
                JsonConstants.Latitude: loc.coordinate.latitude,
                JsonConstants.Longitude: loc.coordinate.longitude
            ]
            locationsDictionaries += [locDict]
        }

        return [JsonConstants.Locations: locationsDictionaries]
    }

    // MARK: - Network

    private func uploadLocationsToBackend(locations: [CLLocation]) {
        let url = "http://httpbin.org/post"
        let params = parseLocationsToDictionary(locations)
        Alamofire.request(.POST, url, parameters: params, encoding: .JSON, headers: nil)
            .responseJSON { response in
            print("\(self.dynamicType) response: \(response)")
        }
    }
}

extension NSDate {

    func toISO8601() -&gt; String {
        let iso8106Formatter = NSDateFormatter()
        iso8106Formatter.timeZone = NSTimeZone(name: "UTC")
        iso8106Formatter.locale = NSLocale(localeIdentifier: "en_US_POSIX")
        iso8106Formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"
        return iso8106Formatter.stringFromDate(self)
    } 
}
</code></pre>
