<p>If you change your MyScreen class to</p>

<pre><code>public class MyScreen implements MyScreenView
{
    private presenter;

    public MyScreen()
    {
        presenter = new Presenter();
    }

    public MyScreen(Presenter p) 
    {
        presenter = p;
    }

    public OnResume()
    {
        presenter.OnResume();
    }
}
</code></pre>

<p>then you have a production constructor which creates a new Presenter and a convenience constructor for testing so you can instantiate it with a Mock presenter. I prefer Mockito (code from memory so...)</p>

<pre><code>Presenter mockP = Mock(Presenter.class);
MyScreen target = new MyScreen(mockP);
target.OnResume();
verify(mockP).doA();
verify(mockP).doB();
verify(mockP).doC();
</code></pre>

<p>Here you create a new MyScreen with a Mock Presenter. When you call verify on the various methods your test will fail if that method was never called on the mock. So you are in effect writing a test that asserts if you call OnResume on the MyScreen class the effect is to call doA, doB and doC on its presenter field.</p>

<p>You can specify what arguments you expect when you verify the method was called. And you can stub the methods of mockP so that it will return known results in particular scenarios.</p>

<hr>

<p>Incidentally</p>

<pre><code>public OnResume()
    {
        presenter.OnResume();
    }
</code></pre>

<p>is IMHO the better choice of your two options because then you can change what the <code>presenter.OnResume()</code> method does without having to change the MyScreen class.</p>
