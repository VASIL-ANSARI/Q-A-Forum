<p>Wish I could add a comment instead of an answer. Anyhow:</p>

<p>masked_array is <em>not</em> for making masks. It's for including only the data outside the mask in calculations such as sum, mean, etc.. scientific statistical applications. It's comprised of an array and the mask for the array.
It's probably NOT what you want.</p>

<p>You probably just want a normal boolean mask, as in:</p>

<pre><code>mask = diff&gt;1
</code></pre>

<p>Then you'll need to modify the shape so numpy broadcasts in the correct dimension, then broadcast it into the 3rd dimension:</p>

<pre><code>mask.shape = mask.shape + (1,)
mask = np.broadcast_arrays(img1Array, mask)[1]
</code></pre>

<p>After that, you can just add the pixels:</p>

<pre><code>img1Array[mask] += img2Array[mask]
</code></pre>

<p>A further point of clarification:</p>

<pre><code>imgResult=img1Array+img2Array[mask]
</code></pre>

<p>That could never work. You are saying 'add some of the pixels from img2Array to <em>all</em> of the pixels in img1Array' 6_9</p>

<p>If you want to apply a ufunc between two or more arrays, they must be either the same shape, or broadcastable to the same shape.</p>
