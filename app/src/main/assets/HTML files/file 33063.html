<p>In your case, your DBManager is very near a repository pattern in itself.  In the world of Domain Driven Design a Repository is typically created for each Aggregate root that you find your domain as in the explanation by Martin Fowler. <br/></p>

<p><a href="http://martinfowler.com/bliki/DDD_Aggregate.html">http://martinfowler.com/bliki/DDD_Aggregate.html</a> <br/></p>

<p>For each Entity/Aggregate root that you deal with in your domain you would create a Repository that would handle the CRUD operations (Create, Read, Update, and Delete).  So in your case you could have a Customer Repository.  </p>

<p><strong>Edit</strong>: The benefit is that the implementation of how the data is touched and how it works is abstracted from the rest of your code.  Then you can simply call the methods on your repository to make the code easier to read.  Also, if you implement your Repository as an interface, you can start to use things like Dependency Injection, which will make your code more maintainable, testable, and other *ables.  ;-)</p>

<p>A typical Repository interface in C# would look something like this (obviously can be a little different depending on your needs.</p>

<pre><code>public interface ICustomerRepository : IDisposable
{
    IEnumerable&lt;Customer&gt; GetCustomers();
    Customer GetCustomerByID(int customerId);
    void InsertCustomer(Customer customer);
    void DeleteCustomer(int customerId);
    void UpdateCustomer(Customer customer);
    void Save();
}
</code></pre>

<p>A good resource for learning more about this can be found on MSDN.  The example is using MVC and Entity Framework, but that can obviously be tweaked for your application. <br/></p>

<p><a href="http://www.asp.net/mvc/tutorials/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application">http://www.asp.net/mvc/tutorials/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application</a></p>
