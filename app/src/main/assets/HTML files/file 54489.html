<p>The reason your code doesn't work is that the <code>FXMLLoader</code> injects references to elements in the FXML with <code>fx:id</code> attributes into fields in the controller with matching names. So when you load the FXML file the first time, the <code>FXMLLoader</code> sets the field <code>myButton</code> to be a reference to the button it creates when it loads the FXML. Since you use the exact same controller instance the second time you load the FXML, the <code>FXMLLoader</code> now sets that same field (in the same controller instance) to be a reference to the button it creates when the FXML file is loaded again. In other words, <code>buttonController.myButton</code> now refers to the second button created, not the first. So when you call <code>myButton.setStyle(...)</code> it updates the style of the second button.</p>

<p>Basically, you always want one controller instance per view instance. What you need is for both controllers to access the same shared state.</p>

<p>Create a model class that stores the data. In a MVC architecture, the View observes the model and updates when the data in the model changes. The controller reacts to user interaction with the view and updates the model.</p>

<p>(Arguably, FXML gives you more of a MVP architecture, which is similar. There are variants of this too, but generally the presenter will observe the model and update the view when data in the model changes, as well as update the model in response to user interaction.)</p>

<p>So your model might look like:</p>

<pre><code>import javafx.beans.property.BooleanProperty;
import javafx.beans.property.SimpleBooleanProperty;

public class Model {

    private final BooleanProperty red = new SimpleBooleanProperty();

    public final BooleanProperty redProperty() {
        return this.red;
    }


    public final boolean isRed() {
        return this.redProperty().get();
    }


    public final void setRed(final boolean red) {
        this.redProperty().set(red);
    }


    public void toggleRed() {
        setRed(! isRed() );
    }
}
</code></pre>

<p>Your ButtonPanel.fxml doesn't change:</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;?import javafx.scene.control.ScrollPane?&gt;
&lt;?import javafx.scene.layout.VBox?&gt;
&lt;?import javafx.scene.control.Button?&gt;

&lt;ScrollPane xmlns:fx="http://javafx.com/fxml/1" fx:controller="ButtonPanelController"&gt;
    &lt;VBox &gt;
        &lt;Button fx:id="myButton" text="Click Me" onAction="#buttonClickedAction" /&gt;
    &lt;/VBox&gt;
&lt;/ScrollPane&gt;
</code></pre>

<p>Your controller has a reference to the model. It can use bindings or listeners on the model properties to update the UI, and the handler methods just update the model:</p>

<pre><code>import javafx.beans.binding.Bindings;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.scene.control.Button;

public class ButtonPanelController {

    @FXML
    Button myButton;

    boolean isRed = false;

    private Model model ;

    public ButtonPanelController(Model model) {
        this.model = model ;
    }

    public void initialize() {

        myButton.styleProperty().bind(Bindings.
                when(model.redProperty()).
                then("-fx-background-color: red;").
                otherwise("")
        );
    }

    public void buttonClickedAction(ActionEvent event) {
        model.toggleRed();
    }
}
</code></pre>

<p>Finally, you keep everything synchronized because the views are views of the same model. In other words you just create one model and hand its reference to both controllers. Since I made the model a constructor parameter in the controller (which is nice, because you know you have a model as soon as the instance is created), we need a controller factory to create the controller instances:</p>

<pre><code>import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;
import javafx.util.Callback;

public class TestApp extends Application {

    @Override
    public void start(Stage stage) throws Exception {
        // 1st Stage
        stage.setTitle("1st Stage");
        stage.setWidth(200);
        stage.setHeight(200);
        stage.setResizable(false);

        // The one and only model we will use for both views and controllers:
        Model model = new Model();

        /* Override the ControllerFactory callback to create 
         * the controller using the model:
         */
        Callback&lt;Class&lt;?&gt;, Object&gt; controllerFactory = type -&gt; {
            if(type == ButtonPanelController.class) {
                return new ButtonPanelController(model);
            } else {
                try {
                    return type.newInstance();
                } catch(Exception e) {
                    throw new RuntimeException(e);
                }
            }
        };

        // Load FXML
        FXMLLoader loader = new FXMLLoader(
                ButtonPanelController.class.getResource("ButtonPanel.fxml"));
        loader.setControllerFactory(controllerFactory);

        Parent root = (Parent) loader.load();

        // Show 1st Scene
        Scene scene = new Scene(root);
        stage.setScene(scene);
        stage.show();

        // 2nd Stage
        Stage stage2 = new Stage();
        stage2.setTitle("2nd Stage");
        stage2.setWidth(200);
        stage2.setHeight(200);
        stage2.setResizable(false);

        // Load FXML
        FXMLLoader loader2 = new FXMLLoader(
                ButtonPanelController.class.getResource("ButtonPanel.fxml"));
        // Set the ControllerFactory before the load takes place
        loader2.setControllerFactory(controllerFactory);
        Parent root2 = (Parent) loader2.load();

        // Show 2nd Scene
        Scene scene2 = new Scene(root2);
        stage2.setScene(scene2);
        stage2.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
</code></pre>
