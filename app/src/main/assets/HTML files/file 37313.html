<p>If you wish to have threads block until something happens, you can pair a <a href="http://en.cppreference.com/w/cpp/thread/mutex" rel="nofollow"><code>std::mutex</code></a> (with its lock held by a <a href="http://en.cppreference.com/w/cpp/thread/unique_lock" rel="nofollow"><code>std::unique_lock&lt;std::mutex&gt;</code></a>) with a <a href="http://en.cppreference.com/w/cpp/thread/condition_variable" rel="nofollow"><code>std::condition_variable</code></a>.</p>

<p>You use the <a href="http://en.cppreference.com/w/cpp/thread/condition_variable/wait" rel="nofollow"><code>wait</code></a> member of the <code>std::condition_variable</code>, pass it the <code>std::unique_lock&lt;std::mutex&gt;</code>, and a functor which returns <code>true</code> when the condition for the thread to awaken is met.  As the thread waits on the <code>std::condition_variable</code>, it surrenders the lock.  When the condition is met, and <a href="http://en.cppreference.com/w/cpp/thread/condition_variable/notify_one" rel="nofollow"><code>notify_one</code></a> (assuming the thread-in-question is the thread selected for notification) or <a href="http://en.cppreference.com/w/cpp/thread/condition_variable/notify_all" rel="nofollow"><code>notify_all</code></a> is called on the <code>std::condition_variable</code>, it wakes up, reacquires the lock, checks the condition, and returns (with the lock still held) when/if it's true.</p>
