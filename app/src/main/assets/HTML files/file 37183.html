<p>From <code>man scanf</code>:</p>

<blockquote>
  <p>â¢ An optional 'm' character. This is used with string conversions (%s,
  %c, %[), and relieves the caller of the need to allocate a
  corresponding buffer to hold the input: instead, scanf() allocates a
  buffer of sufficient size, and assigns the address of this buffer to
  the corresponding pointer argument, which should be a pointer to a
  char * variable (this variable does not need to be initialized before
  the call). The caller should subsequently free(3) this buffer when it
  is no longer required.</p>
</blockquote>

<p>this however is a POSIX extension (as noted by fiddling_bits). </p>

<p>To be portable I think that in your usage case I would prepare a function like the following:</p>

<pre><code>char *alloc_answer() {
  char buf[1000];
  fgets(buf,sizeof(buf),stdin);
  size_t l = strlen(buf);
  if (buf[l-1]=='\n') buf[l]=0; // remove possible trailing '\n'
  return strdup(buf);
}
</code></pre>

<p>even if this solution will break lines longer than 1000 characters (but it prevents buffer overflow, at least).</p>

<p>A fully featured solution would need to read input in chunks and realloc the buffer on every chunk...</p>
