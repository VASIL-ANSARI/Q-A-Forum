<p>Option #1: Override <code>onSaveInstanceState()</code> of your <code>Activity</code> and put whatever information you want in the supplied <code>Bundle</code>. Your new activity instance will receive that <code>Bundle</code> in <code>onRestoreInstanceState()</code> (or <code>onCreate()</code>). <a href="https://github.com/commonsguy/cw-android/tree/master/Rotation/RotationOne">Here is a sample project demonstrating this</a>.</p>

<p>Option #2: Override <code>onRetainNonConfigurationInstance()</code> of your <code>Activity</code> and return some object that represents your state. Your new activity instance can call <code>getLastNonConfigurationInstance()</code> to retrieve that object, so the new activity can apply that information. Be careful, though, not to have the old activity return something in the object that holds a reference back to the old activity (e.g., a widget, an instance of a regular inner class). <a href="https://github.com/commonsguy/cw-android/tree/master/Rotation/RotationTwo">Here is a sample project demonstrating this</a>.</p>

<p>Option #3: Convert this activity to a fragment. Have the fragment call <code>setRetainInstance(true);</code> on itself during its initial setup. Add the fragment dynamically to some activity via a <code>FragmentTransaction</code>. Now, when the configuration changes, the fragment is retained, so all your widgets and state are retained. <a href="https://github.com/commonsguy/cw-advandroid/tree/master/Honeycomb/WeatherFragment">Here is an overly-complex sample application demonstrating this</a>.</p>

<p>Those are the three recommended approaches nowadays.</p>
