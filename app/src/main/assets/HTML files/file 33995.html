<p>Once you have collected your data in <code>CommonViewController</code> call a method such as <code>[self processData:receivedData];</code> where <code>receivedData</code> is the structure you want to process in the child - I will just use an <code>NSData</code> instance for this example.</p>

<p>You can <em>simulate</em> an abstract method by having the following in your <code>commonViewController</code> implementation of <code>processData</code>:</p>

<p>CommonViewController.m:</p>

<pre><code>-(void) processData:(NSData *)receivedData
{
   NSAssert(NO,@"Override processData in your subclass");
}
</code></pre>

<p>Then in each of your subclasses, override the method to perform whatever is required:</p>

<p>FoodsViewController.m:</p>

<pre><code>-(void) processData:(NSData *)receivedData
   {
       //TODO put the data into the right controls
   }
</code></pre>

<p><strong>Update</strong></p>

<p>If the mapping of data to the visual controls is the same (i.e. there is always a "title Label" and a "item picture" for example, but their placement on the screen changes, then you can define the control properties in your superclass.h -</p>

<pre><code>@property (weak,nonatomic)  IBOutlet UILabel *titleLabel;
@property (weak,nonatomic)  IBOutlet UIImageView *itemPicture;
</code></pre>

<p>Then when you create use a subclass as your UIViewController in InterfaceBuilder you can just drag the connection from the control to the IBOutlet.  If you are creating your controls programatically rather than in IB, then you can just assign them to the property in the subclass -</p>

<pre><code>  [self.view addSubView:myTitleLabel];
  self.titleLabel=myTitleLabel;
</code></pre>

<p>In this case you can omit the IBOutlet</p>
