<ol>
<li><p>When you annotate a method with <code>@RequestMapping</code>, a  <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.html" rel="nofollow"><code>RequestMappingHandlerAdapter</code></a> will <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-ann-methods" rel="nofollow">register built-in argument resolvers</a>. </p></li>
<li><p>The arguments of the handler method will be scanned, and based on the type or annotation an appropriate argument resolver will kick-in. For example, for the <code>@RequestParam</code> annotation, an <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/method/annotation/RequestParamMethodArgumentResolver.html" rel="nofollow"><code>RequestParamMethodArgumentResolver</code></a> will be called</p></li>
<li><p>An argument resolver guides further the conversion and binding if applicable. The conversion is handled by an appropriate implementation of the <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/convert/converter/package-summary.html" rel="nofollow"><code>Converter</code></a> or <a href="https://docs.oracle.com/javase/7/docs/api/java/beans/PropertyEditor.html" rel="nofollow"><code>PropertyEditor</code></a>. The binding is handled by an appropriate instance of <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/validation/DataBinder.html" rel="nofollow"><code>DataBinder</code></a>. For the case of <code>RequestParamMethodArgumentResolver</code> and e.g. <code>@RequestParam("age")</code>, a <code>NumberEditor</code> guides the conversion, and a <code>WebDataBinder</code> guides the binding.</p></li>
</ol>

<p>Different cases that you have in your example, are all a subject of the above flow, but different argument resolvers kick in e.g. <code>ModelAttributeMethodProcessor</code>, different converters of editors kick in (you can register custom ones for custom types, or for the <code>User</code> a default constructor will be called etc.)</p>

<p>About the singleton dilemma, it refers to a single instance of the component, and it concerns only the instance variables of the component. Methods, and arguments within are OK to be new instance it plays no role from the singleton perspective</p>
