<p>First, you can't <code>println</code> current node, since you don't know if it is on the <strong>right</strong> path. That means you should rather collect the visited nodes in a <code>list</code> and print it once you reach your <strong>target node</strong>.</p>

<p>Also I highly doubt that the output you've shown was produced by your program - your program doesn't check for the <em>target node</em>, it traverses the <strong>whole</strong> child sub-tree.</p>

<p>You could implement this by defining a helper recursive function which would need an additional parameter - <code>list</code> of visited nodes. For example:</p>

<pre><code>public boolean fa(NodeArbre inicial, NodeArbre fi, List&lt;NodeArbre&gt; visited) {
  if (inicial == null)
    return false;
  visited.add(inicial);
  if (inicial == fi || inicial.contingut.equals(fi.contingut)) { // depends on how you want to determine node equality  
    // print list of visited?
    return true;
  }
  if (fa(inicial._esq, fi, visited))
    return true;
  else if (fa(inicial._dret, fi, visited))
    return true;
  visited.remove(inicial);
  return false;
}
</code></pre>

<p>Which you'd call from the original method <code>fa</code></p>

<pre><code>public void fa(NodeArbre inicial, NodeArbre fi) {
  // assign the list to a variable if you want to do something with it...
  // fa will return true if it found the path
  fa(inicial, fi, new LinkedList());
}
</code></pre>

<p>Note: I made an assumption that <code>_esq</code> points to the left child and <code>_dret</code> to the right child or vice-versa.</p>

<p>For the non-believers - I have tested it: <a href="http://ideone.com/U1sI7t" rel="nofollow">http://ideone.com/U1sI7t</a></p>
