<p>What you want is to see a smaller (say 200 pixel) window onto a larger (say 500 pixel) gradient.  To do that you just need to compute the colors of four corners colors based on the location of your window in the overall gradient, and then draw just that.  (So don't think about drawing the entire background, but about figuring out how to draw just the part that you need.)</p>

<p>Since you're just moving smoothly between the two colors (between 0 and 500), you're doing a "linear interpolation" (that is a straight-line estimation) between the colors based on where the Window is.  Libgdx supports this via the <a href="http://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/Color.html#lerp-com.badlogic.gdx.graphics.Color-float-" rel="nofollow"><code>lerp()</code> methods on <code>Color</code></a>.</p>

<p>Assuming the window is travelling along the Y axis, something like this should give what you want:</p>

<pre><code>Color baseColor = lightBlue;
Color topColor = darkBlue;

int skyHeight = 500;
int windowHeight = 200;
int windowLocation = ...; // something betweeen 0 and skyHeight - windowHeight;
Color windowBottomColor = baseColor.copy().lerp(topColor, windowLocation / skyHeight);
Color windowTopColor = baseColor.copy().lerp(topColor, (windowLocation + windowHeight) / skyHeight);
</code></pre>

<p>Now <code>windowBottomColor</code> and <code>windowTopColor</code> should be suitable for calling filledRect:</p>

<pre><code>shapeRenderer.filledRect(x, y, width, height, 
                         windowBottomColor, windowBottomColor, windowTopColor, windowTopColor);
</code></pre>

<p>Note that the "copy()" calls create a new Color object for each invocation, so you might want to optimize that to avoid the allocation.</p>

<p>Disclaimer: I haven't tried this code, so it probably has some stupid bugs in it, but hopefully it gives you the right idea.</p>
