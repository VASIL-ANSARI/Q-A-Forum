<p>Your queue <code>q</code> holds the nodes you haven't yet visited. You should only add to your queue <code>q</code> nodes that haven't already been visited. That way it will become empty, nodes that you have already explored will not reenter the list.</p>

<p>Using your image as an example, you will start <code>q</code> only with the node <code>A</code>. You'll mark <code>A</code> as visited. This is how you start.</p>

<p>Your loop will consist of removing the first node on the queue <code>q</code>, in this case <code>A</code>, and add all of the nodes that are connected to <code>A</code> and haven't been visited yet. In other words, you'll traverse the line of the matrix for <code>A</code> and find that <code>B</code>, <code>C</code> and <code>D</code> are connected to <code>A</code>. For each of them, if <code>visited()</code> returns false, you'll add them to <code>q</code> and mark as visited. In this pass, <code>q</code> will have <code>B</code>, <code>C</code> and <code>D</code>, and all of <code>A-D</code> will have visited() as true.</p>

<p>In the next iteration, the first node on <code>q</code> will be <code>B</code>. You'll dequeue it and see that it is connected to <code>A</code>, <code>E</code> and <code>F</code>. Since <code>A</code> returns <code>true</code> when you call <code>visited()</code>, you will not add it to <code>q</code>. <code>E</code> and <code>F</code> will be added and marked as visited.</p>

<p>If you continue, you will dequeue <code>C</code>, <code>D</code>, <code>E</code> and <code>F</code>, without adding anything to <code>q</code>, since all the nodes have already been visited. After that, <code>q.isEmpty()</code> will return <code>true</code> and your loop is over.</p>
