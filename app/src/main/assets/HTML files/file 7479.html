<p>Basically, don't do that. It is somewhat obscure, esoteric, hard to read and very limited, as you have noticed yourself. The <a href="http://www.pythonware.com/products/pil/" rel="nofollow">Python Imaging Library</a> offers text rendering to PNG and JPEG using Freetype2, which is a much saner and feature-complete approach.</p>

<p>Now we have that out of the way, the representation is quite simple and by the way also explained in the <a href="http://packages.python.org/pypng/png.html" rel="nofollow">documentation of the png module</a> in the standard library:</p>

<blockquote>
  <p>There is a fourth format, mentioned
  because it is used internally, is
  close to what lies inside a PNG file
  itself, and has some support from the
  public API. This format is called
  packed. When packed, each row is a
  sequence of bytes (integers from 0 to
  255), just as it is before PNG
  scanline filtering is applied. When
  the bit depth is 8 this is essentially
  the same as boxed row flat pixel;
  [...] This format is used by the
  <code>Writer.write_packed()</code> method.</p>
</blockquote>

<p>Basically, the bits in the integer value ranging from 0-255 specify if a given pixel in that row is on/off. Using the <code>char</code> function out of the very same code, try visualizing it by executing something like this in your favorite Python shell:</p>

<pre><code>for row in char("A"):
    print bin(row[0])[2:].zfill(8)
</code></pre>

<p>You should end up with output like the following:</p>

<pre><code>00000000
00111000
01000100
01111100
01000100
01000100
01000100
00000000
</code></pre>

<p>...which is more visible in a monospaced terminal font, but still should be pretty obvious.</p>
