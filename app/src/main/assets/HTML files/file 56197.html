<p>You're returning the address of a local variable. When control leaves the block containing the variable definition (in this case, your function), the variable gets destroyed, and you're left with an invalid pointer.</p>

<p>Your code has undefined behavior.</p>

<p>You should also check if your compiler has warning options for this case. E.g. gcc has <code>-Wreturn-local-addr</code> (which I believe is enabled by default), which warns you about this situation.</p>

<hr>

<p>To solve this problem, you could have your function take a pointer to a struct to write the results into. This would make it the caller's responsibility to manage the memory associated with the struct.</p>

<p>You could also return a struct by value, which would copy it to the caller (behind the scenes this probably compiles to something like solution #1; functions returning structs are usually implemented by making them take a hidden pointer argument anyway).</p>

<p>Or you could <code>malloc</code> a struct dynamically. Then you have to check for errors (a <code>NULL</code> return from <code>malloc</code>) and it becomes the caller's responsibility to <code>free</code> the returned pointer.</p>

<p>Finally, you could make the function return nothing (<code>void</code>) and instead use a global variable to communicate values back to the caller. This is usually not recommended because global variables can lead to some hard to understand program logic (and hard to find bugs).</p>
