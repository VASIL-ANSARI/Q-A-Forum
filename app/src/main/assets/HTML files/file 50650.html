<p>I think letting a markerclass inherit from old class would be bad usage of inheritance. <code>NewClass</code> is not a special Type of <code>OldClass</code>. In fact <code>OldClass</code> should be removed and only lives on for the sake of compatibility which might be given up at some point in the future. Therefore <code>NewClass</code> actually isn't meant to specialize <code>OldClass</code>, but replace it. </p>

<h2>Composition and Delegation</h2>

<pre><code>public class NewClass 
{ 
    // [...]
    public void SomeThing()
    {
        // you move all your stuff to the new class
    }
    // [...]
}

[Obsolete("Is obsolete, please use NewClass instead")]
public class OldClass 
{
    private NewClass newClass = new NewClass();

    // [...]
    public void SomeThing()
    {
        // and delegate your old class calls to that.
        this.newClass.SomeThing();
    }
    // [...]
}
</code></pre>

<h2>Why</h2>

<p>Because otherwise you cannot safely remove it at some point in the future without knowing that nobody did something in the means of </p>

<pre><code>NewClass myObject = new OldClass();
</code></pre>

<h2>Even better: Extract an <code>interface</code></h2>

<p>For the Future, think about providing <code>interface</code>s for your public API and returning those whereever possible. This makes swapping implementations way easier:</p>

<pre><code>public interface ISomeClass
{
    void SomeThing();
}

public class NewClass : ISomeClass
{ 
    // [...]
    public void SomeThing()
    {
        // you move all your stuff to the new class
    }
    // [...]
}

[Obsolete("Is obsolete, please use NewClass instead")]
public class OldClass : ISomeClass
{
    private NewClass newClass = new NewClass();

    // [...]
    public void SomeThing()
    {
        // and delegate your old class calls to that.
        this.newClass.SomeThing();
    }
    // [...]
}
</code></pre>

<p>This is kind of a mix of your solution and the way I would prefer, since <code>NewClass</code> and <code>OldClass</code> have to share a common API but do not inherit from each other (they are on the same level of the Inheritance-Hierarchy).</p>
