<p>Maybe the problematic behavior you encountered was due to an older version of Swift, but in my experience &amp;var should actually work.</p>

<p>Make sure that CreateCompressionSession() and VTCompressionSessionRef (and whatever type it points to if it's a pointer type) are available to the Swift code via a C header included in the bridging header.  See what the Swift signature is of CreateCompressionSession() as it is imported into Swift and how VTCompressionSessionRef is imported.    Work in your Swift code in terms of the imported structures.  You can write convenience wrappers around them if you wish.</p>

<p>See this question for some additional info: <a href="http://stackoverflow.com/questions/33424316/swift-converts-cs-uint64-t-different-than-it-uses-its-own-uint64-type/33428437#33428437">Swift converts C&#39;s uint64_t different than it uses its own UInt64 type</a></p>

<p>Here is also an article that might help: <a href="http://www.swiftprogrammer.info/callback_void.html" rel="nofollow"><a href="http://www.swiftprogrammer.info/callback_void.html" rel="nofollow">http://www.swiftprogrammer.info/callback_void.html</a></a></p>

<p>Sorry if this is not very helpful, since I'm not familiar with all the details of what you are trying to do, but hopefully this helps.</p>
