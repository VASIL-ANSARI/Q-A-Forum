<p>I don't think it's possible to do this in less than <code>O(N)</code>, where <code>N</code> is the number of items in all arrays. Your current solution is less efficient, since <code>indexOf</code> is <code>O(N)</code> for each array, and you could run through all of them for each item in the shortest array.</p>

<p>I think a map-based option would be <code>O(N)</code>:</p>

<pre><code>var counts = {};
var keys = Object.keys(obj);
var arr, el;
for (var k = 0; k &lt; keys.length; k++) {
    arr = obj[keys[k]];
    for (var i = 0; i &lt; arr.length; i++) {
        el = arr[i];
        if (counts[el] === undefined) {
            // new value, start counting
            counts[el] = 1;
        } else {
            // increment count for this value
            counts[el]++;
            // if we have as many values as keys, we're done
            if (counts[el] === keys.length) {
                return el;
            }
        }
    }
}
</code></pre>

<p>Some caveats here:</p>

<ul>
<li><p>This assumes that the elements can be used as object keys (i.e. they can be uniquely converted to strings), and that you don't have some nasty edge cases like <code>1</code> and <code>"1"</code> in different arrays.</p></li>
<li><p>This assumes the array values are unique for each array.</p></li>
<li><p>This assumes there's only one element in the intersection.</p></li>
</ul>

<p><a href="https://jsfiddle.net/xzfa75og/" rel="nofollow">https://jsfiddle.net/xzfa75og/</a></p>
