<p>The Data Protection API (DPAPI) does exactly what you want.  It provides symmetric encryption of arbitrary data, using the credentials of the machine or (better) the user, as the encryption key.  You don't have to worry about managing the keys; Windows takes care of that for you.  If the user changes his password, Windows will re-encrypt the data using the user's new password.</p>

<p>DPAPI is exposed in .NET with the System.Security.Cryptography.ProtectedData class:</p>

<pre><code>byte[] plaintextBytes = GetDataToProtect();
byte[] encodedBytes = ProtectedData.Protect(plaintextBytes, null, DataProtectionScope.CurrentUser);
</code></pre>

<p>The second parameter of the Protect method is an optional entropy byte array, which can be used as an additional application-specific "secret".</p>

<p>To decrypt, use the ProtectedData.Unprotect call:</p>

<pre><code>byte[] encodedBytes = GetDataToUnprotect();
byte[] plaintextBytes = ProtectedData.Unprotect(encodedBytes, null, DataProtectionScope.CurrentUser);
</code></pre>

<p>DPAPI works correctly with roaming profiles (as described <a href="http://support.microsoft.com/kb/309408">here</a>), though you'll need to store the encrypted data in a place (network share, IsolatedStorage with <a href="http://msdn.microsoft.com/en-us/library/zzdt0e7f%28VS.71%29.aspx">IsolatedStorageScope.Roaming</a>, etc.) that your various machines can access.</p>

<p>See the ProtectedData class in MSDN for more information.  There's a DPAPI white paper <a href="http://msdn.microsoft.com/en-us/library/ms995355.aspx">here</a>, with more information than you'd ever want.</p>
