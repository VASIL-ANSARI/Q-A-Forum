<p>So, summarizing points I posted as comments.</p>

<p>In your case, generating all subsets of sets is definitely not an option since number of such subsets will be ~2<sup>N</sup>. For N = 50 it is more than the Earth exists in nanoseconds.</p>

<p>I assume to switch from <em>subsets of sets</em> to <em>subsets of their items</em>. Say, <code>M</code> subsets have <code>N</code> distinct items, and merge threshold is <code>T</code>. So you need to try just ~N<sup>T</sup> <a href="https://en.wikipedia.org/wiki/Combination#Number_of_k-combinations" rel="nofollow">k-combinations</a> of size <code>T</code> looking which subsets could be merged through that combination of items, which for small <code>T</code> is acceptable.</p>

<p>Algorithm will be the following:</p>

<pre><code>let D - collection of initial sets
let S - collection of distinct elements in sets across D

for each k-combination c over S {
   M = new M(c)          // merge object, which stores subset of merged sets and k-combination by which they are merged
   for each (s in D) {
      if (s.containsAll(c))
         M.sets.add(s)
   }
   if (M.sets.size &gt; 0)  // some sets was merged through c
       merges.add(M)
} 
</code></pre>

<p>After that, taking all possible pairs of merges, remove those that are fully covered by other merges:</p>

<pre><code>for each m in merges {
    for each m1 in merges {
        if (m.sets.containsAll(m1.sets))
            m1.markDeleted()
    }
}
</code></pre>
