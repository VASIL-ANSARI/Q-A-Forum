<p>ViewModels can be comunicated through the EventAggregator. You need to create the events and tell at the listening viewmodels the events that they expect. I usually make a "Events" folder to put it.</p>

<p>Take a look at the <a href="http://caliburnmicro.codeplex.com/wikipage?title=The%20Event%20Aggregator&amp;referringTitle=Documentation" rel="nofollow">Documentation</a>.</p>

<p>Example:</p>

<p><strong>The event:</strong></p>

<pre><code>    public class FooEvent
        {
           public FooEvent(bool foo) 
           {
               Foo = foo;
           }

         public bool Foo { get; private set; }
        }
</code></pre>

<p><strong>The first screen</strong></p>

<pre><code>public class FirstViewModel : Screen
{
    private readonly IEventAggregator _events;

    [ImportingConstructor]
    public FirstViewModel(IEventAggregator events)
    {

       DisplayName = "First screen";
       _events = events;
    }


   public void PublishFooEvent()
   {
       _events.Publish(new FooEvent(true));
   }
</code></pre>

<p><strong>The second screen</strong></p>

<pre><code>public class SecondViewModel : Screen, IHandle&lt;FooEvent&gt;
    {

    private readonly IEventAggregator events;

    [ImportingConstructor]
    public SecondViewModel(IEventAggregator events)
    {
        DisplayName = "Second screen";
        this.events = events;
        events.Subscribe(this);
    }

    public bool Bar{get;set;}

    public void Handle(FooEvent message)
    {
        Bar = message.Foo;
    }
}
</code></pre>

<p>Hope it helps.</p>
