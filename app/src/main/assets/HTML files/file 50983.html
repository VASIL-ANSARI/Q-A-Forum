<p>Different implementations often use different definitions of the Discrete Fourier Transform (DFT), with correspondingly different results. The correspondence between implementations is usually fairly trivial (such as a scaling factor).</p>

<p>More specifically, your implementation is based on the following definition of the DFT:</p>

<p><a href="http://i.stack.imgur.com/Idfd0.png" rel="nofollow"><img src="http://i.stack.imgur.com/Idfd0.png" alt="OP&#39;s DFT definition"></a></p>

<p>On the other hand, Wolfram alpha by default uses <a href="https://reference.wolfram.com/language/tutorial/FourierTransforms.html#30397" rel="nofollow">a definition</a>, which after adjusting to 0-based indexing looks like:</p>

<p><a href="http://i.stack.imgur.com/mVYuS.png" rel="nofollow"><img src="http://i.stack.imgur.com/mVYuS.png" alt="Wolfram alpha default DFT definition"></a></p>

<p>Correspondingly, it is possible to transform the result of your implementation to match Wolfram alpha's with:</p>

<pre><code>void toWolframAlphaDefinition(ref Complex[] f)
{
  float scaling = (float)(1.0/Math.Sqrt(f.Length));
  for (int i = 0; i &lt; f.Length; i++)
  {
    f[i] = scaling * Complex.Conjugate(f[i]);
  }
}
</code></pre>

<p>Now as far as computing the inverse DFT using the forward transform, a direct implementation of the formula </p>

<p><img src="http://i.stack.imgur.com/FUOic.png" alt="OP&#39;s inverse formula"></p>

<p>you provided would be:</p>

<pre><code>void inverseFt(ref Complex[] f)
{
  for (int i = 0; i &lt; f.Length; i++)
  {
    f[i] = Complex.Conjugate(f[i]);
  }
  ft(f.Length, ref f);
  float scaling = (float)(1.0 / f.Length);
  for (int i = 0; i &lt; f.Length; i++)
  {
    f[i] = scaling * Complex.Conjugate(f[i]);
  }
}
</code></pre>

<p>Calling <code>ft</code> on the original sequence <code>0.6, 0.7, 0.8, 0.9</code> should thus get you the transformed sequence <code>3, -0.2+0.2j, -0.2, -0.2-0.2j</code>.</p>

<p>Further calling <code>inverseFt</code> on this transform sequence should then bring you back to your original sequence <code>0.6, 0.7, 0.8, 0.9</code> (within some reasonable floating point error), as shown in <a href="https://ideone.com/SheAor" rel="nofollow">this live demo</a>.</p>
