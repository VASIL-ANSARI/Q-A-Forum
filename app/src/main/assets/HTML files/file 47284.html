<p>Assuming that the <code>Employee</code> and the <code>Manager</code> classes both extend the <code>User</code> class, then yes, this is a good solution. If you want to prevent duplicates, however, you can use a Set:</p>

<pre><code>private Set&lt;User&gt; _usrs = new HashSet&lt;&gt;();
/*
 *  function that I use before I get the current user set, preventing getting a outdated version of it
 */
public void refreshUserList() {
    this._usrs.addAll(_employees); //add all employees to user set
    this._usrs.addAll(_managers);  //add all managers to user set
}
</code></pre>

<p>You don't need to call <code>clear();</code>, since Sets do not add duplicate elements.</p>

<p>This way, you will lose the special variables/methods that appear only for  Managers or Employees, since all you will have will be the variables/methods available for Users. However, if you cast each <code>User</code> instance of your <code>_usrs</code> Set to <code>Manager</code> or <code>Employee</code>, then you can still get those special elements/methods:</p>

<pre><code>for (User user : _usrs) {
    if (user instanceof Manager) {
        Manager mng = (Manager) user;
        mng.manage(); // or whatever managers do that employees don't
    } else { //if no other classes extend the User class
        Employee emp = (Employee) user;
        emp.work(); // or whatever employees do that managers don't :P
    }
}
</code></pre>
