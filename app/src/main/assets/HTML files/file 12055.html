<p>The response can be found here: <a href="http://social.msdn.microsoft.com/Forums/en/parallelcppnative/thread/85a84373-4c3d-4862-bff3-9a21ffe82493" rel="nofollow">http://social.msdn.microsoft.com/Forums/en/parallelcppnative/thread/85a84373-4c3d-4862-bff3-9a21ffe82493</a></p>

<p>For one core machines, this is expected "default" behavior. This can be changed.</p>

<p>By default, number of tasks that can run in parallel = number of hardware threads (num of cores). This improves the raw throughut and efficiency of completing tasks. </p>

<p>However, there are a number of situations where a developer would want many tasks running in parallel, regardless of the number of cores. In this case you have two options:</p>

<ol>
<li>Oversubsribe locally.</li>
</ol>

<p>In your example above, you would use</p>

<pre><code>void lengthyTask()

{

    Context::Oversubscribe(true)

         ...do a lengthy task  (//OR a blocking task)

    Context::Oversubscribe(false)

}
</code></pre>

<ol>
<li><p>Oversubcribe the scheduler when you start the application.</p>

<p>SchedulerPolicy policy(1, MaxConcurrency, GetProcessorCount() * 2);</p>

<p>SetDefaultSchedulerPolicy(policy);</p></li>
</ol>
