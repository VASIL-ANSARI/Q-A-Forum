<p><code>memmove()</code> is fine. It will figure out the direction of the move on its own by comparing the two pointers â an implementation might look something like:</p>

<pre><code>void * memmove(void *dst, const void *src, size_t len)
{
    intptr_t dsti = dst;
    intptr_t srci = src;
    if (src &gt; dst) {
        return _memmove_up(dst, src, len);
    } else {
        return _memmove_down(dst, src, len);
    }
 }
</code></pre>

<p>On most CPUs, this will compile to perhaps a half dozen extra instructions, which are only executed once when the function is called â there is no benefit to bypassing this.</p>

<p>(In theory, there is no reason why <code>memcpy()</code> should not be able to do a similar comparison itself to remove the distinction between it and <code>memmove()</code>. However, for some unfortunate historical reason, the authors of the C standard library did not decide to make this simplification, so we're stuck with these two functions.)</p>
