<p>Using recursion algorithm, is pretty much like <a href="https://en.wikipedia.org/wiki/Mathematical_induction" rel="nofollow">mathematical induction</a>. First you need to deal with the base case, and then find the sub-problem pattern.</p>

<p>For factorial, define the problem as <code>F(n)</code> factorial of <code>n</code>.</p>

<ol>
<li>base case, <code>F(0)=1</code></li>
<li>sub-problem pattern, <code>F(n)=n!=n*(n-1)!=n*F(n-1)</code></li>
</ol>

<p>And for permutations, define <code>P(E)</code> as all permutation of set <code>E</code>.</p>

<ol>
<li>base case, <code>P({}) = {{}}</code></li>
<li>sub-problem pattern. Consider the process of permutation, let's say I have chosen the first element <code>x</code>, then we got a sub-problem, <code>P(E-x)</code>, then for each <code>p in P(E-x)</code>, and <code>x</code> to the front, we got all permutations starting with element <code>x</code>, iterate <code>x</code> you got all the permutations, aka <code>P(E)</code>.</li>
</ol>

<p>In C++, you can use <a href="http://en.cppreference.com/w/cpp/algorithm/next_permutation" rel="nofollow"><code>next_permutation</code></a>.</p>

<p>And the example code from the above thought is like:</p>

<pre><code>// generate permutation of {a[st], a[st+1], ..., a[ed]}
void P(char a[], int st, int ed) {
    if (st &gt; ed) { puts(a); return; } // nothing to generate
    for (int i=st; i&lt;=ed; ++i) {
        swap(a[st], a[i]);            // enumerate first element
        P(a, st+1, ed);
        swap(a[st], a[i]);            // recover
    }
}
</code></pre>

<p>Check it on <a href="http://ideone.com/zbawY2" rel="nofollow">http://ideone.com/zbawY2</a>.</p>
