<p>Your function <code>interpret()</code> references <code>$fileline</code>, which is a global variable, but does not use the <code>global</code> keyword.</p>

<p>Instead, pass <code>$fileline</code> to <code>interpret()</code> as an argument:</p>

<pre><code>// Argument reference &amp;$fileline
function interpret(&amp;$fileline) {
  for ($count=1;!empty($fileline[$count]);$count++) {
    if (strpos($fileline[$count],"//")===0) {
        $fileline[$count]="&lt;div class=\"comment\"&gt;".$fileline[$count]."&lt;/div&gt;";
    }
  }
}

// Later, your function call...
$fileline = explode("`",$filedata);
interpret($fileline);
</code></pre>

<p>Note that above <code>interpret()</code> receives its argument by reference.  I'm not crazy about this, and you could also <code>return $fileline</code> at the end of the function and assign it with the call:</p>

<pre><code>function interpret($fileline) {
  for ($count=1;!empty($fileline[$count]);$count++) {
    if (strpos($fileline[$count],"//")===0) {
        $fileline[$count]="&lt;div class=\"comment\"&gt;".$fileline[$count]."&lt;/div&gt;";
    }
  }
  // Return the argument instead
  return $fileline;
}

// Later, your function call...
$fileline = explode("`",$filedata);
$fileline = interpret($fileline);
</code></pre>
