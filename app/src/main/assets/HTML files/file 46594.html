<p>There's an additional rule when it comes to resolving ambiguity between function overloads that are instantiations of a function template: <em>partial ordering of overloaded function templates</em> (<strong>[temp.func.order]</strong>).</p>

<p>This is usually used to resolve ambiguity in favor of more specialized overloaded function templates:</p>

<pre><code>template&lt;typename T&gt; void f(T) { ... }
template&lt;typename T&gt; void f(T*) { ... } // specialization for pointers
void g() { int i; f(&amp;i); }   // calls f&lt;int&gt;(int*), not f&lt;int*&gt;(int*)
</code></pre>

<p>However, because of the way the rules are set out (<strong>[over.match.best]</strong>/1) function template partial ordering applies even when the template parameter (here <code>T := A</code>) was not deduced from the arguments by template argument deduction, even if it was supplied by explicit specialization:</p>

<blockquote>
  <p>[...]<br/>
  â <code>F1</code> and <code>F2</code> are function template specializations, and the function template for <code>F1</code> is more specialized
  than the template for <code>F2</code> according to the partial ordering rules described in 14.5.6.2.</p>
</blockquote>

<p>Here <code>bar(A::value_type *)</code> is considered more specialized than <code>bar(A *)</code> (under <strong>[temp.func.order]</strong>), so the former is preferred and there is no ambiguity.</p>
