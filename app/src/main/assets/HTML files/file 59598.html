<p>You're 90% there. As you stated, the foreach will iterate over the <code>folders</code> array and <code>$data</code> will be the current item in the array.</p>

<p><strong>Picking up the value for chosenFolderId</strong></p>

<p>The click binding which calls <code>goToFolder</code> will pass the item it was bound to as an argument, so the <code>chosenFolderId</code> value will be set to the folder item corresponding to the clicked &lt;li&gt; element.</p>

<p>For example: clicking on the 'Archive' element will fire the click event for the item bound to <code>folders[1]</code> thereby calling <code>goToFolder</code> with the <code>folders[1]</code> value.</p>

<p><strong>Initial value</strong></p>

<p>The initial value of <code>$root.chosenFolderId()</code> will be <code>undefined</code> since you declared it with no argument. On initial view no folders appear selected, if you had:</p>

<pre><code>self.folders = ['Inbox', 'Archive', 'Sent', 'Spam'];
self.chosenFolderId = ko.observable(self.folders[0]);
</code></pre>

<p>then the 'Inbox' would be initially selected.</p>

<p><strong>Memory location</strong></p>

<p>You asked if <code>$data</code> and <code>$root.chosenFolderId()</code> point to the same memory location. That's mostly correct - if your folders were an array of objects then they would contain the same reference (for the selected item). Technically strings are also references in JS (see explanation <a href="http://stackoverflow.com/a/51193/625200">http://stackoverflow.com/a/51193/625200</a>) but its simpler to think of primitives (strings, numbers, booleans) in JS as values and not references.</p>
