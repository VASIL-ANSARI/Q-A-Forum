<p>You have to declare <code>B::C</code> before using it. The following might work.</p>

<p><em>Update:</em> Ignoring a usable demonstration as requested, here's a way of structuring this (minus the definitions of member functions) that could work, but bear in mind that everything is private as it stands.</p>

<pre><code>class A;

class B
{
  int geti(A * ap);

public:
  class C
  {
    int geti(A * ap);
  };
};

class A
{
  friend class B;    // fine
  friend class B::C; // fine too
  int i;
};
</code></pre>

<p>Then define the getter functions elsewhere:</p>

<pre><code>int B::geti(A * ap) { ... }
int B::C::geti(A * ap) { ... }
</code></pre>

<hr>

<p>Alternative: forward-declare the nested class <code>B::C</code> and save one external definition:</p>

<pre><code>class A;

class B
{
  int geti(const A * ap) const; // we cannot use A yet!

public:
  class C;
};

class A
{
  friend class B;    // fine
  friend class B::C; // fine too
  int i;
};

int B::geti(const A * ap) const { return ap-&gt;i; }

class B::C
{
  inline int geti(const A * ap) const { return ap-&gt;i; }
};
</code></pre>
