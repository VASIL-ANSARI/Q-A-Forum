<h1>Quick Update</h1>

<p>In the latest versions of TypeScript you <em>can</em> nest a class inside an IIFE:</p>

<pre><code>(() =&gt; {
    class Example {

    }
})();
</code></pre>

<p>The resulting output is:</p>

<pre><code>(function () {
    var Example = (function () {
        function Example() {
        }
        return Example;
    }());
})();
</code></pre>

<h1>Original Answer</h1>

<p>You can avoid adding to the global scope using a module pattern such as AMD or CommonJS. When you use either of these, each TypeScript file is considered an external module and is kept out of global scope.</p>

<p>This example removes Angular for the purposes of the example, but while RequireJS adds the <code>define</code> method to global, none of your code is placed in this scope.</p>

<p>MyModule.ts</p>

<pre><code>export class myController {
    constructor($scope) {
        $scope.myNewProperty = "Bob";
    }
}
</code></pre>

<p>app.ts</p>

<pre><code>import MyModule = require('MyModule');

var controller = new MyModule.myController('');
</code></pre>

<p>HTML</p>

<pre><code>&lt;script src="Scripts/require.js" data-main="app.js"&gt;&lt;/script&gt;
</code></pre>

<p>What app.js looks like:</p>

<pre><code>define(["require", "exports", 'MyModule'], function (require, exports, MyModule) {
    var controller = new MyModule.myController('');
});
</code></pre>

<p>Alternatively... as you know... you can still implement it all using the JavaScript you are already using if you wish - you'll still get auto-completion and type checking, which are major benefits even if you aren't getting classes.</p>
