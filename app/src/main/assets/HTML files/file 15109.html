<p>Your <code>newBuffer</code> function should accept the first parameter by reference so that changes made to it inside the function are visible to the caller:</p>

<pre><code>void newBuffer(char*&amp; outBuffer, size_t sz) {
    outBuffer = new char[sz];
}
</code></pre>

<p>As it is now, you assign the result of <code>new char[sz]</code> to the local variable <code>outBuffer</code> which is only a <em>copy</em> of the caller's <code>foo</code> variable, so when the function returns it's as if nothing ever happened (except you leaked memory).</p>

<p>Also you have a problem in that you are allocating the buffer to the size of the length of <code>ABCD</code> which is 4. That means you can hold up to 3 characters in that buffer because one is reserved for the NUL-terminator at the end. You need to add <code>+ 1</code> to the length somewhere (I would do it in the call to the function, not inside it, because <code>newBuffer</code> shouldn't be specialised for C-strings). <code>strncpy</code> only NUL-terminates the buffer if the source string is short enough, so in this case you are only lucky that there happens to be a <code>0</code> in memory after your buffer you allocated.</p>

<p>Also don't forget to <code>delete[] foo</code> in <code>main</code> after you're done with it (although it doesn't really matter for a program this size).</p>
