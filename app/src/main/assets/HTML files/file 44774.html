<p>The rule is very simple: if you think that other programs will use your <code>IDisposables</code>, then do not destroy them. Otherwise, do it.</p>

<p>For example: <code>GetProcesses()</code> returns other processes being potentialy used by other programs, so <strong>you shouldn't dispose</strong> them.</p>

<p>From other side, files you've opened should be released for other processes in OS, so you should close and dispose wrapper streams above them (say, <strong>you should dispose</strong> steam returned by <code>File.Open</code> method).</p>

<p><strong>Update</strong>:<br>
<a href="https://msdn.microsoft.com/en-us/library/b1yfkh5e.aspx" rel="nofollow">From MSDN</a>:</p>

<blockquote>
  <ul>
  <li><strong>DO</strong> implement the Basic Dispose Pattern on types containing
  instances of disposable types. See the Basic Dispose Pattern section
  for details on the basic pattern.   If a type is responsible for the
  lifetime of other disposable objects, developers need a way to dispose
  of them, too. Using the containerâs Dispose method is a convenient way
  to make this possible.<br>
  <ul>
  <li><strong>DO</strong> implement the Basic Dispose Pattern
  and provide a finalizer on types holding resources that need to be
  freed explicitly and that do not have finalizers.<br>
  For example, the pattern should be implemented on types storing unmanaged memory buffers. The Finalizable Types section discusses guidelines related to
  implementing finalizers.  </li>
  <li><strong>CONSIDER</strong> implementing the Basic Dispose Pattern on classes that themselves donât hold unmanaged resources or disposable objects but are likely to have subtypes that do.  </li>
  </ul></li>
  </ul>
</blockquote>
