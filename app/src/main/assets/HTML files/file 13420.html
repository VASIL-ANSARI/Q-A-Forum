<p>Instead of just using animated:YES, did you try putting it into something like:</p>

<pre><code>[UIView animateWithDuration:.25 delay:0 options:UIViewAnimationOptionBeginFromCurrentState animations:^{
    [Singlescroll setContentOffset:maximumOffsetPoint]; //spin all the way up?
}completion:^(BOOL finished){
    if (finished)
        //kick off another animation, to spin it back down:
        [UIView animateWithDuration:.25 delay:0 options:UIViewAnimationOptionBeginFromCurrentState animations:^{
            [Singlescroll setContentOffset:CGPointMake(jumpX, jumpY+randShuffle*sepValue)];
        }completion:nil];
    }
}];
</code></pre>

<p>I don't know if this answers your question, but completion blocks are super handy and might be what you need.  Within the completion block, the second animation will only get called at the end of the first animation. </p>

<p>Also, there are several animateWithDuration: methods on UIView, but in my experience this one is more reliable for animating properties such as contentOffset and zoomToRect of scroll views.</p>
