<p>You must terminate all COM activity (specifically: release all COM interface pointers) on the thread before calling <code>CoUninitialize</code>, you don't do it.</p>

<p>See, for example, <a href="https://github.com/leixiaohua1020/simplest_directshow_example/blob/master/simplest_directshow_player_custom/simplest_directshow_player_custom.cpp" rel="nofollow">this code</a> and its <code>Release</code> calls at the <code>_tmain</code> bottom.</p>

<p>It makes sense to use more recent version of Visual Studio (2013, 2015), where free community edition already includes ATL and you can enjoy automatic COM interface reference management using <code>CComPtr</code> and friends. This is the first advise to those who uses raw COM interface pointers and experience issues managing them incorrectly.</p>

<p>See also:</p>

<ul>
<li><a href="http://stackoverflow.com/questions/18136445/not-releasing-filter-com-object-causing-a-crash">Not releasing filter com object causing a crash</a></li>
<li><a href="http://stackoverflow.com/questions/12295434/unreleased-directshow-csource-filter-makes-program-crash-at-process-shutdown/12364905#12364905">Unreleased DirectShow CSource filter makes program crash at process shutdown</a></li>
<li><a href="http://stackoverflow.com/questions/2653797/why-does-couninitialize-cause-an-error-on-exit">Why does CoUninitialize cause an error on exit?</a></li>
</ul>

<p><strong>UPDATE</strong>: Using raw pointers inaccurately, you keep having leaks:</p>

<pre><code>    hr = pGraph-&gt;Connect(pPinOut, pPinIn);
    // ...
    hr = pEnumPins-&gt;Next(1, &amp;pPinOut, &amp;fetched);
</code></pre>

<p><code>IEnumPin::Next</code> call overwrites <code>pPinOut</code> pointer and leaks a reference.</p>
