<blockquote>
  <p>why do I have to bind the push method to apply?</p>
</blockquote>

<p>It's the other way round: You have to bind the apply method to the Array push function - you can bind it to other functions as well! Otherwise <code>apply</code> doesn't know <em>which</em> method to apply with the arguments.</p>

<p><code>Function.prototype.apply.bind(Array.prototype.push);</code> does call the <code>bind</code> function <em>on</em> the <code>apply</code> function with <code>push</code> as the argument, the argument <em>on</em> which <code>apply</code> is then bound. The resulting function <code>pushAll</code> will, when called, invoke <code>apply</code> <em>on</em> the <code>push</code> function, and pass it's argument (the array and the arguments array) to it.</p>

<blockquote>
  <p>Shouldn't Array.prototype.push.apply already be bound to apply?</p>
</blockquote>

<p>Nope. JavaScript is designed to bind the context at the call of a function, not already when it's being referred to as a property - <strong>there is no implicit binding on property access</strong>. Otherwise <code>Array.prototype.push</code> would already be bound to <code>Array.prototype</code>, before you could call any Function methods like bind/apply on it and try to use it with a different context.</p>

<blockquote>
  <p>Why does calling it under a different name result in calling it on an unbound context?</p>
</blockquote>

<p>It's not so much different name, but different style. (Unbound) Functions do get their <code>this</code> value set to the object when they are called <em>as a method</em> on it, i.e. when the reference to the called function is a property access: <code>destination.push()</code>.</p>

<p>This allows for great flexibility, you can "borrow" functions from an object and call them on other objects, still being the same (unbound) function. This is rather impossible in languages where function objects are no first-class objects.</p>

<p>If functions (even though they were meant to be methods) are called as plain functions (<code>pushAll()</code>), their <code>this</code> value will be <code>undefined</code> (unless in sloppy mode). Read more on the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="nofollow"><code>this</code> keyword</a> at MDN.</p>
