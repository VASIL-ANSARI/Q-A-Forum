<p>When executing functions that use the <code>yield</code> keyword, they actually return a generator. Generators are a type of iterators. While MATLAB does not provide the syntax for either, you can implement the <a href="http://www.python.org/dev/peps/pep-0234/">"iterator interface"</a> yourself. Here is an example similar to <code>xrange</code> function in python:</p>

<pre><code>classdef rangeIterator &lt; handle
    properties (Access = private)
        i
        n
    end

    methods
        function obj = rangeIterator(n)
            obj.i = 0;
            obj.n = n;
        end

        function val = next(obj)
            if obj.i &lt; obj.n
                val = obj.i;
                obj.i = obj.i + 1;
            else
                error('Iterator:StopIteration', 'Stop iteration')
            end
        end

        function reset(obj)
            obj.i = 0;
        end
    end
end
</code></pre>

<p>Here is how we use the iterator:</p>

<pre><code>r = rangeIterator(10);
try
    % keep call next() method until it throws StopIteration
    while true
        x = r.next();
        disp(x);
    end
catch ME
    % if it is not the "stop iteration" exception, rethrow it as an error
    if ~strcmp(ME.identifier,'Iterator:StopIteration')
        rethrow(ME);
    end
end
</code></pre>

<p>Note the when using the construct <code>for .. in ..</code> in Python on iterators, it internally does a similar thing.</p>

<p>You could write something similar using regular functions instead of classes, by using either <code>persistent</code> variables or a closure to store the local state of the function, and return "intermediate results" each time it is called.</p>
