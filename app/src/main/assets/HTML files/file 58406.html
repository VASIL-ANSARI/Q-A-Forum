<p>You can't do this with a normal <code>NSTimer</code> as there is no support for backgrounding. It is however achievable very easily using another method.</p>

<p>In your AppDelegate you have two methods. <code>applicationWillResignActive</code> and <code>applicationDidBecomeActive</code>. In the resign method you simply need to persist the current <code>NSDate</code> into the <code>NSUserDefaults</code> and in the active method, retrieve it and compare it against the current <code>NSDate</code> to get the amount of time the app was inactive for.</p>

<p>Code examples:</p>

<pre><code>func applicationWillResignActive(application: UIApplication) {
    let date = NSDate()
    NSUserDefaults.standardUserDefaults().setObject(date, forKey: "DateTimer")
}

func applicationDidBecomeActive(application: UIApplication) {
    if let persistedDate = NSUserDefaults.standardUserDefaults().objectForKey("DateTimer") as? NSDate {
        let difference = NSCalendar.currentCalendar().components([.Second], fromDate: persistedDate, toDate: NSDate(), options: [])
        let differenceSeconds = difference.second
    }
}
</code></pre>
