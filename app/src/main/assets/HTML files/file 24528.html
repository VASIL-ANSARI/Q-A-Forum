<p>Normally, <code>EscapedString es2 = es;</code> will call the copy constructor, however you explicitly told it not to by making the copy constructor <code>explicit</code>:</p>

<pre><code>explicit EscapedString(const EscapedString &amp;strEscaped)
</code></pre>

<p>A constructor marked <code>explicit</code> can never be called by means of automatic type conversions.  It can only be called, well... explicitly, which you have done here:</p>

<pre><code>EscapedString es(EscapedString("Abc?def"));
</code></pre>

<p>Here's what happens when the compiler encounters <code>EscapedString es2 = es;</code>.</p>

<p>First the compiler sees if it can use the copy constructor and finds that it can't, because it was marked <code>explicit</code>.  So it looks for another constructor to call.  Since <code>EscapedString</code> is derived from <code>std::string</code>, the compiler is able to cast <code>es</code> as a <code>const std::string&amp;</code> and call:</p>

<pre><code>EscapedString &amp;operator=(const std::string &amp;strUnEscaped)
</code></pre>
