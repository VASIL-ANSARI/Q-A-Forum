<p>Functionality deference is sure -- <code>CMutex</code> maps directly to Win32 mutex type while <code>std::mutex</code> is way more basic, likely implemented using win32 <code>CRITICAL_SECTION</code> removing the recursive  nature and <code>std::recursive_mutex</code> wrapping <code>CRITICAL_SECTION</code>. Those would work similar to <code>CCriticalSection</code>.</p>

<p><code>CMutex</code> is a heavyweight that in practice is used to create named mutexes for interprocess communication. You should not use it intraprocess.</p>

<p>If your question stand comparing <code>recursive_mutex</code> vs <code>CCriticalSection</code>, I'd bet on practically same performance.  Interface-wise <code>CSingleLock</code> has completely braindead interface (it takes a second argument that defaults to <code>FALSE</code> instead of <code>TRUE</code>), so in practice I never used it directly only through macro to avoid mistake.</p>

<p>In new code I'd first try to solve things using <code>std::future</code>, and fiddle with locks only as last resort. The C++11 threading makes perfect sense to use, so until you need <code>CMultiLock</code> functionality it is better. I did not yet explore how to cover the latter case, but would be surprised if it can't be done easily.</p>
