<p>Recursion is very useful if the problem at hand is recursive as well. One such problem is traversing a tree-like datastructure. Any computer program that is being compiled results in such a structure called the syntax tree. The compiler goes through the tree and generates code for the branches it finds. I know this in itself doesn't help you to comprehend recursion, but it's just to make clear that recursion is a very practical concept. Only the examples given are mostly rather artificial, since the 'real' examples need too much prior knowledge.</p>

<p>As for your example, some prints should make clear what's going on:</p>

<pre><code>def digit(n):
    print ('Entering "digit" with n == {}'.format (n))

    if n &lt; 10:
        print ('In the "if" now')
        return 1
    else:
        print ('In the "else" now')
        return 1 + digit(n/10)

print (digit (10000))
</code></pre>

<p>Following modified code makes it even more clear, try to follow execution step by step:</p>

<pre><code>def digit(n):
    print ('\nCalling "digit" with n == {}'.format (n))

    if n &lt; 10:
        print ('In the "if" now for n == {}'.format (n))
        result = 1
        print ('Exiting "digit" from the "if" with n == {}, result now is {}'.format (n, result))
        return result
    else:
        print ('In the "else" now for n == {}'.format (n))
        result = 1 + digit(n/10)
        print ('Exiting "digit" with n == {}, result now is {}'.format (n, result))
        return result


print ('Nr of digits is: {}'.format (digit (10000)))
</code></pre>

<p>It prints:</p>

<pre><code>D:\aaa&gt;call C:\Python35\python.exe so.py 

Calling "digit" with n == 10000
In the "else" now for n == 10000

Calling "digit" with n == 1000.0
In the "else" now for n == 1000.0

Calling "digit" with n == 100.0
In the "else" now for n == 100.0

Calling "digit" with n == 10.0
In the "else" now for n == 10.0

Calling "digit" with n == 1.0
In the "if" now for n == 1.0
Exiting "digit" from the "if" with n == 1.0, result now is 1
Exiting "digit" with n == 10.0, result now is 2
Exiting "digit" with n == 100.0, result now is 3
Exiting "digit" with n == 1000.0, result now is 4
Exiting "digit" with n == 10000, result now is 5
Nr of digits is: 5
</code></pre>

<p>What also helps is the following: With each call of the function, a new chunk of local data is piled upon something in memory called the stack. In this case that chunk of data is just parameter n which is stored as a local variable. And with each exit of a call (so at one of the returns), this chunk of data is taken off the stack and thrown away. In neat terms: each function call has its own stack frame.</p>

<p>Take some pieces of paper, and for each call (see output), write n on it and put it on a stack. Then for each exit throw away the top paper. While this is no magic bullet it may help your imagination.</p>

<p>Bottom line: it may take you considerable time before a "click" is made in your brain. But it's really worth while. Don't be amazed if it takes a week or longer. That's normal, although not all programmers will admit it. Try to follow program execution step by step, using the output in my answer and a pile of paper notes. After a while: click... Don't stare the problem for longer than a quarter if you get dizzy, try again next day (from experience...).</p>

<p>Note to Python specialists: The 'stack' model in Python is only conceptually, while in e.g. C++ it is real. But it's a good model for the behavior of recursion.</p>
