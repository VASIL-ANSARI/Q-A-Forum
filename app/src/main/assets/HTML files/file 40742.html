<p>With <code>pow(100, 0)</code> <code>pow(100, 1)</code> and <code>pow(100, 2)</code> the compiler replaces the function calls with constants (<code>1, 100, 10000</code>), but with <code>pow(100, i)</code> it has to actually call the function at runtime (because of the variable <code>i</code> being passed as argument), resulting with two results of <code>pow</code> in the form <code>0.99999999</code> and <code>99.999999</code> instead of <code>1</code> and <code>100</code> (or any 2 of the 3). When truncating to int after the multiply you "lose" two units.</p>

<p>This is another example of why converting to <code>int</code> from <code>double</code> is just <strong>pure evil</strong>: very hard to find subtle bugs in your program (not compiler bugs).</p>

<p>Btw, I am surprised that the compiler with <code>O2</code> didn't unroll the loop, propagate the constants and reach the same optimization (replacing the function call with constant results).</p>

<p>Btw2 Scratch that, I am surprised that the compiler didn't just replace all you code with only two calls to <code>printf</code>.</p>
