<p>You don't even try to register a member function pointer. That would have to be specified as <code>&amp;MemMgrUser::GetManagedMemSize</code>. You can't use the plain name of a member function, except in an expression that calls it.</p>

<p>But even if you had a member function pointer, it cannot be used in the same way as a plain function pointer of the same apparent signature. Calling a member function always requires an object to call it on. The <code>this</code> pointer available in the function is an additional, hidden parameter.</p>

<p>If you can use features of the C++11 standard library, you could <code>typedef std::function&lt;size_t (void)&gt; MemSizeFunc;</code> instead of the current typedef. That allows you to store various kinds of functions and function objects that are callable with that signature as a <code>MemSizeFunc</code>. In particular you could register your <code>GetManagedMemSize</code> member function bound to a suitable <code>MemMgrUser</code> object, for example as:</p>

<pre><code>MemMgrUser()
{
   MemMgr::GetInst().Register(std::bind(&amp;MemMgrUser::GetManagedMemSize, *this));
}
</code></pre>
