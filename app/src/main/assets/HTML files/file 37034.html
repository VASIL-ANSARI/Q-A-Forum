<p>So I decided to help you create a class to do. It returns a generator which you can iterate over to build your final file.</p>

<pre><code>import csv
class DataFile(object):
    empty = ''  # use this if col does not have value

    def __init__(self, filename):
        f = open(filename, 'r')
        self.reader = csv.reader(f)
        # set first line as header
        self.header = [x.strip() for x in self.reader.next()]

    def get_header(self):
        return self.header

    def with_header(self, headers):
        """ Returns a generator for specified headers"""
        header_dict = dict([(a, i,) for i, a in enumerate(self.header)])

        for line in self.reader:
            li = []
            for h in headers:
                if h in header_dict:
                    li.append(line[header_dict[h]])
                else:
                    li.append(self.empty)
            yield li
</code></pre>

<p>You can use it to join files: <code>file1.csv</code> and <code>file2.csv</code> thus:</p>

<pre><code>&gt;&gt;&gt; one = DataFile('file1.csv')
&gt;&gt;&gt; two = DataFile('file2.csv')
&gt;&gt;&gt; one.get_header()
['a', 'b', 'd', '']
&gt;&gt;&gt; comb = set(one.get_header() + two.get_header())
&gt;&gt;&gt; final = list(one.with_header(comb)) + list(two.with_header(comb))
&gt;&gt;&gt; final
[['1', '', '', ' 2', '', ' 3'], ['4', '', ' 6', ' 5', ' 7', '']]
</code></pre>

<p>You can then use <code>comb</code> and <code>final</code> to build your new csv file (with the csv writer etc). Also, you can build a function that takes in multiple files and just returns the new generator with all columns from all files etc.  Modify the char being set when value is not in file by modifying the <code>empty</code> attribute. I think it's easy to follow</p>
