<p>You should describe your problem more clearly if you want to get quick response here. Even after Neil asked you about the checksum, you didn't describe clearly how your checksum algorithm worked.</p>

<p>It <strong>SEEMS</strong> the way to get your checksum is</p>

<ol>
<li><p>Break the packet into bytes</p>

<p><code>"\x01\x01\x00\x00\x00\x01\x23"</code> => <code>[1, 1, 0, 0, 0, 1, 35]</code></p></li>
<li><p>Compute the sum of all bytes => <code>38</code>, i.e. <code>0x26</code></p></li>
<li>Negate the sum as a signed byte => <code>0xDA</code></li>
</ol>

<p>Here may be a solution:</p>

<pre><code>packet = "\x01\x01\x00\x00\x00\x01\x23"
bytes = packet.bytes
sum = bytes.reduce(:+)
checksum = [ -sum ].pack('c')
packet_with_checksum = packet + checksum
</code></pre>

<p>You may need <code>packet.force_encoding('ASCII-8BIT')</code> (or on <code>checksum</code>) if you get an encoding error at the concatenation step.</p>
