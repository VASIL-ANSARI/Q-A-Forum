<p>I don't think it is. If the <code>ObservableCollection</code> should be a member of the <code>Singleton</code> class, instantiate it in the <code>Singleton's</code> private constructor. If it shouldn't, I don't see why you doing it this way. What happens when you call <code>Singleton.list</code> BEFORE <code>Singleton.Instance</code>? <code>NullReferenceException</code>. And since its setter is public, it can be set from outside as well which is probably not what you want.</p>

<p>I would modify your code like this:</p>

<pre><code>public sealed class Singleton
{
   private static volatile Singleton instance;
   private static object syncRoot = new Object();

   public ObservableCollection&lt;MyData&gt; list {get; private set;}

   private Singleton() {
       list = new ObservableCollection&lt;MyData&gt;();
   }

   public static Singleton Instance
   {
      get 
      {
         if (instance == null) 
         {
            lock (syncRoot) 
            {
               if (instance == null)
               {
                  instance = new Singleton();
               }
            }
         }

         return instance;
      }
   }
}
</code></pre>
