<p>If you can use any standard library container, then I would advice to use a vector of vectors.  This way you can loop via an index and use that index on the adjacent vectors.  If you can fill the vectors right before the algorithm then you could make all vectors of the same size and fill them first with all non-spaces (zero's?) and then fill them with the content of your linked lists.</p>

<p>With fixed sized vectors, it basically should be 2 nested loops (from the second to the last but one entry) just checking for spaces and adjacent spaces. </p>

<p>Not tested:</p>

<pre><code>bool isSpace(char c) { return c == ' '; } // std::isspace tests for all whitespaces

int countSurroundedSpaces(const std::vector&lt;std::vector&lt;char&gt; &gt;&amp; vecs)
{
  int count = 0;
  for (int v = 1; v &lt; vecs.size()-1; ++v)
  {
    for (int i = 1; i &lt; vecs[v].size()-1; ++i)
    {
      if (isSpace(vecs[v][i]) 
          &amp;&amp; isSpace(vecs[v-1][i]) &amp;&amp; isSpace(vecs[v][i-1]) 
          &amp;&amp; isSpace(vecs[v][i+1]) &amp;&amp; isSpace(vecs[v+1][i]))
      {
        ++count;
      }
    }
  }
  return count;
}
</code></pre>
