<p>An Adapter is usually used to bridge between two <a href="http://en.wikipedia.org/wiki/Adapter_pattern" rel="nofollow">incompatible interfaces</a>. That doesn't seem to be your problem here. In fact, I don't really see any problem -- as object languages are by nature hierarchical, you should be able to use a mostly 1-to-1 mapping between a class and a tree node. </p>

<p>Perhaps by "Adapter" you just mean a class that wraps a Node or whatever particular Object type that describes your tree nodes, and I'd agree. There should be fairly obvious parent-child relationships that you can describe by having your node classes own or somehow return an array of child node/classes, and the attributes as getters/setters. Any needed validation could be done by the setters, or if need be during construction as a class inspects a given node and its child nodes. Something like the following:</p>

<pre><code>public class NodeFu {

    private Node node;

    public NodeFu(Node node){
        this.node = node;
        // perhaps traverse and validate node data here
    }

    public String getNodeAttribute(String attrName){
        // pardon the offense, Demeter, only for demonstration...
        return node.getAttributes().getNamedItem(attrName).toString();
    }

    public void setNodeAttribute(String attrName, attrValue){
        node.setAttributeValue(attrName, attrValue);
    }

    public ArrayList&lt;NodeFu&gt; getChildren(){
        ArrayList&lt;NodeFu&gt; children = new ArrayList&lt;NodeFu&gt;();
        for (Node childNode : node.getChildNodes()){
            children.add(new NodeFu(childNode));
        }
        return children;
    }
} 
</code></pre>

<p>I'm assuming you have more business logic to add to this class that will manipulate the data on the Node itself, otherwise the Node class would suffice and you could just use it directly.</p>
