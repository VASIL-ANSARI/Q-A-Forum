<p>You could solve this by using several methods.</p>

<ul>
<li>Pass the shared instance into the constructor</li>
<li>Singleton pattern/static could help, but is more restricted.</li>
</ul>

<p>Reminder is, if you use the class on different thread, you need to care about thread safety.</p>

<hr>

<p>Normally I avoid a static object that can be readed/writed by multiple threads. I advise you to try to get rid from this.</p>

<p>But... you need to be sure, that the object/reference types are not accessible from the outside.</p>

<p>like:</p>

<pre><code>// you could create the locking in this class, but the class1 property is a
// reference type, so just locking in the property is not enought, it
// goes wrong when the Class1 has properties itself. (then these will be
// altered outside the lock..
// I choose to wrap the whole object and only returning value types

public class RequiredData
{
    public Class1 class1 { get; set; }
    public int value1 {get; set;}
}

abstract class BaseCommand : ICommand
{
    // protected.. should not be accessable from the outside..!
    protected static RequiredData RequiredData = new RequiredData();

    public int GetValue()
    {
        lock(RequiredData)
            return RequiredData.value1;
    }

    public void SetValue(int value)
    {
        lock(RequiredData)
            RequiredData.value1 = value;
    }

// or you could wrap this in a property

    public int Value
    {
        get { return lock(RequiredData) RequiredData.value1; }
        set { lock(RequiredData) RequiredData.value1 = value; }
    }


    public string GetSomething()
    {
        // try to avoid returning reference types, but the can be referenced from outside the object.
        lock(RequiredData)
            return RequiredData.Class1.something;
    }
}
</code></pre>

<p>So the locking should be inside the <code>BaseCommand</code>. And the <code>BaseCommand</code> should be responsible for communicating with the RequiredData. <em>(so no other object could have a reference to the RequiredData)</em></p>

<p>Like I said: Multithreading / static read/writer = playing with fire.</p>

<hr>

<p>If you have many readers/writers you should have a look at the ReaderWriterLock(Slim). Because multiple threads can read simultaneously and only one writer is active.</p>
