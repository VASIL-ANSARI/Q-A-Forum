<p>1) If you have already generated WCF client code with async ("Begin..."/"End...") methods - than you can use TPL's task API to work with WCF (ContinueWith etc.) via Task.Factory.FromAsync (<a href="http://stackoverflow.com/questions/21481210/how-to-call-wcf-service-asynchronously">example</a>) - good for dealing with legacy IAsyncResult ("Begin..."/"End...") methods/APIs (simple though, you can see source with reflector);</p>

<p>2) Tool-generated client code is not good approach - instead you can write your own universal client-proxy with true-async support (not just using background thread). 
<a href="http://www.dotnetobject.com/Thread-programmatically-consume-wcf-service-async" rel="nofollow">Here</a> is good example how to start, you need wrap "Begin..."/"End..." methods with task based methods (use same Task.Factory.FromAsync) and use expression trees to get rid string based service method calls (I can't share my class source). </p>

<p>Or you can use existing solutions like <a href="https://github.com/Vadimyan/Rikrop.WcfExample" rel="nofollow">this</a>.</p>

<p>3) Don't forget about <a href="http://blog.stephencleary.com/2012/07/dont-block-on-async-code.html" rel="nofollow">ConfigureAwait</a>.</p>

<p>Edit:</p>

<p>You don't have to generate task-based operations, it's enough to generate WCF client code with async service operation methods ("Begin..."/"End..."). Or you can even have only synchronous WCF contract! (see links). TPL available in .NET 4 (without async/await syntactic sugar - which is CSharp 5.0 language feature). Use it (ContinueWith instead await + WhenAny, WhenAll). I used it even in 3.5 via Microsoft Reactive Extensions v1.0.2856.0. AFAIK Reactive Extensions was the initial version which than was included in BCL. <a href="http://blogs.msdn.com/b/pfxteam/archive/2010/04/04/9990342.aspx" rel="nofollow">ParallelExtensionsExtras</a> may be useful as well</p>
