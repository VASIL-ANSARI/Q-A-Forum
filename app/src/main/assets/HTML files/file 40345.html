<p>Forward declarations work for member references and pointers.  When declaring instances of classes or structures in another class / structure, you need the full declaration.  </p>

<p>Your question sounds like you have an issue with your design / architecture.<br>
A <code>Rook</code> is-a <code>Chess_Piece</code>.  Fine, sounds good.</p>

<p>The class <code>Pieces</code> sounds ambiguous.<br>
Do you need a specialized type for containing pieces or can you use <code>std::vector&lt;Chess_Piece*&gt;</code>?  </p>

<p>A <code>Chessboard</code> should <em>contain</em> zero or more instances of <code>Chess_Piece</code>.  A common implementation is a 2d array of pointers to <code>Chess_Piece</code>.  The pointers help support polymorhphism.  </p>

<p>Another implementation could be a vector of .  This is of the view that a chess board has pieces at different locations on the board.  </p>

<p><strong>Edit 1:  Allocation of pieces</strong><br>
I suggest having a <em>factory</em> which returns pointers to the pieces.  Since the quantity of pieces is known and won't change, they can be allocated as static, automatic variables.</p>

<pre><code>class Piece_Factory
{
  static std::vector&lt;Pawn&gt; white_pawns;
  static std::vector&lt;Pawn&gt; black_pawns;
  static Queen             white_queen(white);
  static Queen             black_queen(black);
public:
  Piece_Factory()
  {
    Pawn wp(white);
    Pawn bp(black);
    for (unsigned int i = 0; i &lt; 8; ++i)
    {
      white_pawns.push_back(wp);  // Append a copy to the vector.
      black_pawns.push_back(bp);
    }
  }
  Chess_Piece * get_white_pawn(unsigned int index)
  {
    return &amp;white_pawn[index];
  }
  Chess_Piece * get_white_queen(void)
  {
    return &amp;white_queeen;
  }
};
</code></pre>
