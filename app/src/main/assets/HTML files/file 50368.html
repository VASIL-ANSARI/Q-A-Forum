<p>You shouldn't create <code>@property</code> for the <code>insert()</code> function here (neither for the <code>inorder()</code> in this case). </p>

<p>Properties should be used to manage the attributes of a class with getters setters and deleters. The <code>getter</code> (which you create with the <code>@property</code> decoration and invoke when accesing a property via <code>bst.insert</code>) must take a <em>single</em> argument <code>self</code>. Then, it (normally) returns the attribute it is assigned to. </p>

<p>Instead, use it like a plain <code>method</code> and add elements without decorating it, note how I have added <code>self</code> to your <code>insert()</code> calls:</p>

<pre><code> def insert(self, node, key):
    if node is None:
        return BSTNode(key)
    elif key &lt; node.key:
        node.left = self.insert(node.left, key)
    elif key &gt; node.key:
        node.right = self.insert(node.right, key)
    return node
</code></pre>

<p>Now your insertions work just fine and return the new node objects: </p>

<pre><code>bst.insert(root, 30)
# returns &lt;__main__.BSTNode at 0x7fd9f74a8668&gt;
</code></pre>

<hr>

<p>The reason this is happening is because the (<code>__get__</code>) function for a property internally calls the function (<code>insert</code>) you decorated as a getter but with a single argument <code>insert(instanceOfClass)</code>. </p>

<p>Because you have defined your function <code>insert()</code> with more than one arguments, when this call is made you'll get a nice little <code>TypeError</code>.</p>
