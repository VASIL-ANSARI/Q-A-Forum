<p>I can't imagine it leading to the problem you've cited, but the way you're doing the conversion is pretty ugly, and involves floating point math, so it could lead to at least some degree of inaccuracy in some cases.</p>

<p>You could eliminate that particular problem by doing the conversion a little differently. For example:</p>

<pre><code>int toInt(vector&lt;int&gt; const &amp;v) { // pass by reference to avoid copying
    int ret = 0;
    for (int i=0; i&lt;v.size(); i++)
        ret = 10 * ret + v[i];
    return ret;
}
</code></pre>

<p>Or, you could use the standard library to handle more of the work for you:</p>

<pre><code>int toInt(vector&lt;int&gt; const &amp;v) { // pass by reference to avoid copying
    return std::accumulate(v.begin(), v.end(), 
               0, 
               [](int v, int digit) { return 10 * v + digit; });
}
</code></pre>

<p>Of course, this is still limited to values that will fit in an <code>int</code>--around 2 billion for a typical 32-bit <code>int</code>, for example.</p>
