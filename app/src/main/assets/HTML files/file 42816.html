<p>The third parameter of <code>std::priority_queue</code> is a type. A lambda expression is not a type, but rather, an expression (you can think of it as an instance or object of something). On top of that, lambdas do not have an type that can be known <em>a priori</em>, but stateless lambdas do convert to pointer to function .</p>

<p>There are some work-arounds you can use in order to instantiate priority_queues with lambdas:</p>

<ul>
<li><p>Make the 3rd parameter a pointer to function and pass a stateless lambda to the constructor. You can also pass plain function pointers. For example,</p></li>
<li><p>Make the 3rd parameter an <code>std::function&lt;bool(int, int)&gt;</code> and pass any kind of lambda that matches the correct signature to the constructor. You can pass anything that can be used to construct an <code>std::function&lt;bool(int)&gt;</code>.</p></li>
</ul>

<p>For example,</p>

<pre><code>// no capture. Pointer to function is OK
std::priority_queue&lt;int, std::vector&lt;int&gt;, bool (*)(int, int)&gt;
    q2([](int a, int b){return a &lt; b;});
</code></pre>

<p>or</p>

<pre><code>// capture. Can't use pointer to function.
std::priority_queue&lt;int, std::vector&lt;int&gt;, std::function&lt;bool(int, int)&gt;&gt;
    q2([some_var](int a, int b){return a &lt; b;});
</code></pre>
