<blockquote>
  <p>This program prints "Scanf Test #0 and 1" over and over</p>
</blockquote>

<p>This is a consequence of not checking the result of <code>scanf</code>.  If <code>scanf</code> cannot read an integer, then it leaves the stream untouched and reports failure.  You don't check for this, so it worked once and failed 9 times.</p>

<p>If you enter 10 integers it will work fine; however clearly you're entering some other stuff such as letters which is causing the extraction of an integer to fail.</p>

<p>When there's a single conversion specification (<code>"%d"</code>) in the format string, <code>scanf</code> can return:</p>

<ul>
<li><code>1</code> - success</li>
<li><code>0</code> - junk characters entered</li>
<li>EOF - stream error</li>
</ul>

<p>You should check this value and take appropriate action. You could just abort the program if it is not <code>1</code>, although it would be pro to clear the junk and ask again in case <code>0</code>.</p>

<p>Moving onto the actual sort. Your interface is weird as you pass <code>N-1</code> to the function, and then have the function access 1 item beyond the end of the array. It would be clearer to do <code>selection_sort(N, a)</code>, and then inside the function, <code>high = n-1</code> and <code>for (i = 0; i &lt; n-1; i++)</code> etc.</p>

<p>Now, there is a subtle issue with the line:</p>

<pre><code>void selection_sort(int n, int a[n])
</code></pre>

<p>This line does not match the prototype; you can fix your problem by replacing the line with:</p>

<pre><code>void selection_sort(int n, int a[])
</code></pre>

<p>The original version caused the program to behave unexpectedly for me, but only if I invoke gcc in default mode (i.e. not C-standard compliant). There must be some sort of GNU extension in play that is causing trouble with <code>int a[n]</code>. </p>

<p>In Standard C, the original code should work (and does, if gcc is invoked in standard mode via <code>-std=c99</code>, which is something I'd strongly recommend doing anyway).</p>
