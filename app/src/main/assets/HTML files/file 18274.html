<p>In Java, there are a number of ways of accomplishing this.  One way is to use any of the <a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/Lock.html" rel="nofollow"><code>Lock</code></a> objects which has a <code>tryLock(...)</code> method which allows you to wait for the lock for a certain amount of time.  It returns <code>true</code> if it was able to acquire the lock or <code>false</code> if it timed out.  <a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/locks/ReentrantLock.html" rel="nofollow"><code>ReentrantLock</code></a> may be a good choice here.</p>

<pre><code>private final Lock lock = new ReentrantLock();
...

if (lock.tryLock(1L, TimeUnit.SECONDS)) {
   try {
      // we were able to lock
   } finally {
      // always unlock in a finally
      lock.unlock();
   }
} else {
   // trying to lock timed out without locking
}
</code></pre>

<p>After some discussion in comments, I now understand that you have existing <code>synchronized</code> methods that you'd like to wait for only for a certain amount of time.  Unfortunately, there is no way to do this in Java with the <code>synchronized</code> keyword.</p>
