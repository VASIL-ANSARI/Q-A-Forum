<p>Sorry, this is not possible in the C family.  (It <em>is</em> possible in languages with a more powerful macro system, such as Common Lisp and Rust.)</p>

<p>The only thing a macro can do is textual replacement.  So your </p>

<pre><code>#define VAR_TYPE_( ind_ ) ( (ind_) == IND_I_ ? int : float )
#define IND_I_ 0
VAR_TYPE_( IND_I_ ) first_var = 123;
</code></pre>

<p>expands to</p>

<pre><code>( (0) == 0 ) ? int : float ) first_var = 123;
</code></pre>

<p>which is a syntax error.  There is no way to make it evaluate that <code>?:</code> expression.</p>

<p>There is a thing you could do that would make it work whenever the argument to <code>VAR_TYPE_</code> expanded to a literal zero, one, etc.:</p>

<pre><code>#define VAR_TYPE_(ind_) VAR_TYPE__(ind_)
#define VAR_TYPE__(ind_) VAR_TYPE__##ind_
typedef int VAR_TYPE__0;
typedef float VAR_TYPE__1;
// etc
</code></pre>

<p>... but if you're doing this at all, you probably want to allow <code>ind_</code> to be an arbitrary integer constant expression and that won't work.  You would get things like</p>

<pre><code>VAR_TYPE_sizeof(int)==4?0:2
</code></pre>

<p>in the expansion and you'd be back to the syntax errors.</p>

<p>(Psst: Every time you put spaces on the inside of your parentheses, God kills a kitten.)</p>
