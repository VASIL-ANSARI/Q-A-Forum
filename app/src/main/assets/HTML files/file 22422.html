<p>If <code>odeint</code> expects a vector, not a matrix, you are going to have to give it a vector. If you don't want to change the logic of your code to much, you can make <code>x</code> be  an <code>(m**2,)</code> vector outside your functions, but still an <code>(m, m)</code> matrix inside, by liberally applying <code>.reshape(-1)</code> everywhere needed. You didn't provide us with enough information to test it fully, but something like this may work:</p>

<pre><code>def update_matrix(x,coeffs,m):
    x = x.reshape(m, m)
    update_matrix=numpy.zeros((m,m))
    for i in range(m+1):
        for j in range(m+1-i):
            update_matrix[m][m]=diffeq(x,i,j,coeffs)
    return update_matrix.reshape(-1)

def run_simulation_R2(a,q,m):
    x_counts=numpy.zeros((m,m))
    x_counts[1][0]=1
    x_counts[0][1]=1
    coeffs=R2(a,q,m,x_counts)
    t=range(0,100)
    output = integrate.odeint(update_matrix, x_counts.reshape(-1), t,
                              args=(coeffs, m))
    return output.reshape(m, m)
</code></pre>
