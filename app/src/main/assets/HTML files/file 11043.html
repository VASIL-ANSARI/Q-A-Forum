<blockquote>
  <p>Why result.Add(value) not executed?</p>
</blockquote>

<p>This is because LINQ uses deferred execution.  Until you actually enumerate the results (the return of <code>Select</code>), the delegates will not execute.</p>

<p>To demonstrate, try the following:</p>

<pre><code>List&lt;int&gt; result = new List&lt;int&gt;();

var list = new List&lt;int&gt; { 1, 2, 3, 4 };

var results = list.Select(value =&gt;
    {
        result.Add(value);//Does not work??
        return value;
    });

foreach(var item in results)
{
     // Just iterating through this will cause the above to execute...
}
</code></pre>

<p>That being said, this is a <strong>bad idea</strong>.  LINQ queries should not have side effects if you can avoid it.  Think of <code>Select</code> as a way to transform your data, not execute code.</p>

<blockquote>
  <p>However this not executed, Another question that is have a way do a foreach on a IEnumerable with Extention Method?</p>
</blockquote>

<p>You could write your own extension method:</p>

<pre><code>public static void ForEach&lt;T&gt;(this IEnumerable&lt;T&gt; items, Action&lt;T&gt; action)
{
    foreach(var item in items)
         action(item);
}
</code></pre>

<p>However, I would recommend not doing this. For details, refer to <a href="http://blogs.msdn.com/b/ericlippert/archive/2009/05/18/foreach-vs-foreach.aspx">Eric Lippert's post on the subject</a>.</p>
