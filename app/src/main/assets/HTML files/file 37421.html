<p>According to the <code>numpy</code> documentation: <a href="http://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html">http://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html</a>, <code>numpy.void</code> types are defined as <strong>flexible</strong> data types.  Basically, these are data types where there is no pre-defined type associated to the variable(s) you're looking at.  If you look at <code>numpy</code>, you have data types such as <code>float</code>, <code>uint8</code>, <code>bool</code>, <code>string</code>, etc.</p>

<p><code>void</code> is to accommodate for more generic and flexible types and are for those data types that don't necessary fall into any one of these pre-defined data types.  This situation is mostly encountered when you're loading in a <code>struct</code> where each element has multiple data types associated with multiple fields.  Each structure element could have a combination of different data types, and the amalgamation of all of these data types to represent an instance of this structure element thus leads us to <code>numpy.void</code>.</p>

<p>With the documentation, you can certainly do the same operations like you would with any other data type.  Take a look at the <code>generic</code> data type methods here: <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.html#numpy.generic">http://docs.scipy.org/doc/numpy/reference/generated/numpy.generic.html#numpy.generic</a> .  In fact, all <code>numpy</code> data types are derived from this generic class, including <code>numpy.void</code>.</p>

<p>In the first link I provided at the beginning of this post, it shows a good example of how to create a custom record type, where a record is a combination of a tuple of numbers and a string.  When creating a list of these records, each type in the list is of type <code>numpy.void</code> and it demonstrates that a record is of this data type.  However, bear in mind that this record list has a data type <strong>that is of this record</strong>, but each element of this list <strong>will be of type <code>numpy.void</code></strong>.</p>

<hr>

<p>However, as a matter of self-containment, let's re-create the example here:  Let's create a custom record type where it has two fields associated for each variable you create:</p>

<ul>
<li>A 16-bit string with a field named <code>name</code></li>
<li>A 2-element tuple of floating point numbers that are 64-bits each, with a field named <code>grades</code></li>
</ul>

<p>As such, you'd do something like:</p>

<pre><code>import numpy as np
dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])
</code></pre>

<p>As such, let's create an example list of two elements and instantiate their fields:</p>

<pre><code>x = np.array([('Sarah', (8.0, 7.0)), ('John', (6.0, 7.0))], dtype=dt)
</code></pre>

<p>Because we made this list into a <code>numpy.array</code>, we expect its data type to be so:</p>

<pre><code>type(x)
</code></pre>

<p>We get:</p>

<pre><code>&lt;type 'numpy.ndarray'&gt;
</code></pre>

<p>Remember, the list itself is a <code>numpy.array</code>, but <strong>not</strong> the individual elements.</p>

<hr>

<p>To access the second element of this list, which is the second record, we do:</p>

<pre><code>x[1]
</code></pre>

<p>We get:</p>

<pre><code>('John', [6.0, 7.0])
</code></pre>

<p>To check the type of the second record, we do:</p>

<pre><code>type(x[1])
</code></pre>

<p>We get:</p>

<pre><code>&lt;type 'numpy.void'&gt; # As expected
</code></pre>

<hr>

<h1>Some additional bonuses for you</h1>

<p>To access the name of the second record, we do:</p>

<pre><code>x[1]['name']
</code></pre>

<p>We get:</p>

<pre><code>'John'
</code></pre>

<p>To access the grades of the second record, we do:</p>

<pre><code>x[1]['grades']
</code></pre>

<p>We get:</p>

<pre><code>array([ 6.,  7.])
</code></pre>

<p>To check the type of the name inside the second record, we do:</p>

<pre><code>type(x[1]['name'])
</code></pre>

<p>We get:</p>

<pre><code>&lt;type 'numpy.string_'&gt;
</code></pre>

<p>To check the type of the grades inside the second record, we do:</p>

<pre><code>type(x[1]['grades'])
</code></pre>

<p>We get:</p>

<pre><code>&lt;type 'numpy.ndarray'&gt;
</code></pre>

<hr>

<p>Take note that each element in this list is of type <code>numpy.void</code>.  However, the individual fields for each element in our list is either a tuple of numbers, or a string.  The <strong>collection</strong> of these elements together is of type <code>numpy.void</code>.</p>
