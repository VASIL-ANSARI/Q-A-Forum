<p>How about :</p>

<pre><code>interface IEntity {
    public int Id { get; }
    public string Name { get; }
}

[Table("buildings")]
public class Building : IEntity
{
    [Column("id")]
    [Key]
    public int Id {get;set;}

    [Column("description")]
    public string Description {get;set;}

    [NotMapped]
    public string Name { get { return this.Description; } }
}

[Table("cars")]
public class Car : IEntity
{
    [Column("id")]
    [Key]
    public int Id {get;set;}

    [Column("title")]
    public string Title {get;set;}

    [NotMapped]
    public string Name { get { return this.Title; } }
}
</code></pre>

<p>and then instead of a generic method, is writing one that works on elements that implement this interface suffices?</p>

<p>The Method: </p>

<pre><code>public SpaceResult&lt;IEntity&gt; SelectList() 
{
    SpaceResult&lt;IEntity&gt; result = new SpaceResult&lt;IEntity&gt;();

    try
    {
        result.SelectList = this.GetAll().Select(x =&gt; new SelectListItem { x.Id, x.Name });
    }
    catch (System.Exception ex)
    {
        result.IsError = true;
        result.Message = ex.Message;
        result.InnerException = ex.InnerException.Message;
    }

    return result;
}
</code></pre>

<p>Usage :</p>

<pre><code>ISpaceRepository&lt;Building&gt; _repo = new SpaceRepository&lt;Building&gt;();
SpaceResult&lt;IEntity&gt; result = this._repo.SelectList();
</code></pre>

<p>or</p>

<pre><code>ISpaceRepository&lt;Car&gt; _repo = new SpaceRepository&lt;Car&gt;();
SpaceResult&lt;IEntity&gt; result = this._repo.SelectList();
</code></pre>

<p>As long as all your entity classes implement the common interface, the same method can be applied.</p>
