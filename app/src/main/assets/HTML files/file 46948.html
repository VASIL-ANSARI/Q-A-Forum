<p>As per the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html#subList-int-int-" rel="nofollow"><code>JavaDoc</code></a> on the matter:</p>

<blockquote>
  <p>List subList(int fromIndex,
                  int toIndex) </p>
  
  <p>Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex,
  exclusive. (If fromIndex and toIndex are equal, the returned list is
  empty.) <strong>The returned list is backed by this list, so non-structural
  changes in the returned list are reflected in this list, and
  vice-versa</strong>. The returned list supports all of the optional list
  operations supported by this list.</p>
</blockquote>

<p>The sub list will point to the same elements present within the original list, thus, any changes made through the sub list will be reflected within the original list since you are changing the same objects.</p>

<p>EDIT: As per your comment, assume that the <code>original list</code> has the following references: <code>0x00 0x01 0x02 0x03 0x04 0x05</code> and these map to locations in memory where objects exist.</p>

<p>Doing <code>sublist(0, 2)</code> on the above will yield a list which contains pointers to the following memory locations <code>0x00 0x01 0x02 0x03</code> which are the same as in <code>original list</code>. </p>

<p>What this means is that if you do <code>sublist.get(0).setFoo(foo)</code>, this will in turn seek out the object present at <code>0x00</code> and set some property. However, <code>0x00</code> is also being referenced to by <code>original list</code>, which is why changing the sub list means that you will be changing the source list <strong>since both lists point to the same objects</strong>. The same also holds should you change your elements through <code>original list</code>.</p>
