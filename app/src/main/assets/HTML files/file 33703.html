<p>I think it is not a good practice to throw the same exceptions as the super class or interface definition if your implementation ensures it will never happen. I would always reduce a signature to the bare minimum required.</p>

<p>The <code>IOException</code> is required for all the implementations imaginable, including file sources and streams and sockets etc. Without, such implementations could not notify their errors as a checked exception. But if an implementation has no need to throw a checked exception (which is often annoying for the calling code) removing it from the implementing class does no harm, but removes some burden.</p>

<p><strong>UPDATE:</strong></p>

<p>I have found the reason why the method read() <strong>must</strong> throw an <code>IOException</code>: because of the contract defined for the close() method. From the JavaDoc:</p>

<blockquote>
  <p>Closes the stream and releases any system resources associated with it. Once the stream has been closed, further read(), ready(), mark(), or reset() invocations will throw an IOException. Closing a previously closed stream has no effect.</p>
</blockquote>
