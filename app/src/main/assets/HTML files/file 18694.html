<p>You are assuming a certain order of execution, in as only certain rows you believe are 'correct' will be evaluated against the <code>CAST</code> operation. This is a fundamental fallacy. SQL is a declarative, set oriented language which does not make any evaluation ordering promise the way imperative languages do. As such your entire approach is flawed and you're asking the wrong question. Some query execution plans may work, some may fail, but those that work will start failing randomly later as the query chooses a different plan. </p>

<p>Ultimately your problem is the data model, the fact that you have to crack this composite <code>c000</code> field into substrings and cast to get out int values. Use string fields to store strings, use numeric fields to store numbers. Simple as that. What you're trying to achieve <strong>will never work</strong>.</p>

<p>See also <a href="http://rusanu.com/2009/09/13/on-sql-server-boolean-operator-short-circuit/" rel="nofollow">On SQL Server boolean operator short-circuit</a> and <a href="http://rusanu.com/2011/08/10/t-sql-functions-do-no-imply-a-certain-order-of-execution/" rel="nofollow">T-SQL Functions do not imply a certain order of execution</a>.</p>
