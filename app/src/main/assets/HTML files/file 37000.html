<p>The set returned from <a href="http://docs.oracle.com/javase/8/javafx/api/javafx/collections/FXCollections.html#unmodifiableObservableSet-javafx.collections.ObservableSet-" rel="nofollow"><code>FXCollections.unmodifiableObservableSet()</code></a> work in mysterious ways. You might think you add a listener to the backing set, but in reality, the listeners you add go straight to the wrapper, which has registered himself as a <em>weak</em> listener (<a href="http://docs.oracle.com/javase/8/javafx/api/javafx/collections/WeakSetChangeListener.html" rel="nofollow"><code>WeakSetChangeListener</code></a>) of the backing set.</p>

<p>As long as the wrapper is alive and kicking, his personal listener will pick up events from the backing set and distribute those to the listeners I have registered with the wrapper. But as I never stored a strong reference to the wrapper, it was only a matter of time before the wrapper was picked up by the garbage collector and disposed thereof. All my trigger-happy listeners joined the ride. </p>

<p>And here lie also the entire difference between my small test application and the desktop application that despite identical code, had two completely different results. My test application was executed from start to finish in no time. It took time though for my desktop application to go from registration of the listener to the actual event. It is during that time a GC kicked in and fucked me up.</p>

<p>After spending my time reading source code only, I must, theoretically, conclude that the unmodifiable yet observable Map work the same. So lesson learned: save the reference to the unmodifiable wrapper or rework your client's API so that client's may pass listeners directly to the backing Set (which is the solution I picked).</p>

<p>For more reading on how weak listeners work in JavaFX, see another answer I posted <a href="http://stackoverflow.com/a/24758987/1268003">here</a>.</p>
