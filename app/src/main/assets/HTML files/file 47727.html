<p>A range-based for loop (for a class-type range) looks up for <code>begin</code> and <code>end</code> functions. <code>cbegin</code> and <code>cend</code> are not considered at all:</p>

<p>Â§ 6.5.4 [stmt.ranged]/p1 *:</p>

<blockquote>
  <p>[...]</p>
  
  <ul>
  <li><p>if <code>_RangeT</code> is a class type, the <em>unqualified-ids</em> <code>begin</code> and <code>end</code> are looked up in the scope of class <code>_RangeT</code> as if by class member access lookup (3.4.5), and if either (or both) finds at least one declaration, <em>begin-expr</em> and <em>end-expr</em> are <code>__range.begin()</code> and <code>__range.end()</code>, respectively;</p></li>
  <li><p>otherwise, <em>begin-expr</em> and <em>end-expr</em> are <code>begin(__range)</code> and <code>end(__range)</code>, respectively, where <code>begin</code> and <code>end</code> are looked up in the associated namespaces (3.4.2). [ <em>Note</em>: Ordinary unqualified lookup (3.4.1) is not performed. â <em>end note</em> ]</p></li>
  </ul>
</blockquote>

<p>For a <code>const</code>-qualified range the related member functions must be <code>const</code>-qualified as well (or should be callable with a <code>const</code>-qualified instance if the latter option is in use). You'd need to introduce additional overloads:</p>

<pre><code>typename std::list&lt;T&gt;::iterator begin() {
    return objects.begin();
}

typename std::list&lt;T&gt;::const_iterator begin() const {
//                                            ~~~~^
    return objects.begin();
}

typename std::list&lt;T&gt;::const_iterator cbegin() const {
    return begin();
}

typename std::list&lt;T&gt;::iterator end() {
    return objects.end();
}

typename std::list&lt;T&gt;::const_iterator end() const {
//                                          ~~~~^
    return objects.end();
}

typename std::list&lt;T&gt;::const_iterator cend() const {
    return end();
}
</code></pre>

<p><a href="http://coliru.stacked-crooked.com/a/a133ee1a552dad69" rel="nofollow"><strong>DEMO</strong></a></p>

<hr>

<p><sub><sup>*</sup> the wording comes from C++14, but the differences are unrelated to the problem as it is stated</sub></p>
