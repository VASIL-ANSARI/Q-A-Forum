<p>EDIT:</p>

<p>I think I misunderstood at first:</p>

<p>"When there is no function declaration gcc has no idea what to expect during the compile time phase, and as long as it finds the function during the linking phase everything will work. This 'error' has to be caught during the compile phase because it is not technically an error at all in the linking phase."</p>

<p>OLD ANSWER:</p>

<p>This is a feature and not a bug.  When you call a function the arguments get pushed onto the stack.  If you don't use them, no big deal generally.</p>

<p>You can even plan on having an unknown number of arguments.  Here is simple example of a custom printf style function for logging:</p>

<pre><code>void Debug_Message(uint32_t level, const char *format, ...)
{
    char buffer[256];

    //check level and do stuff

    va_list args;
    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);

   //buffer now contains data as if we did an sprintf to it
}
</code></pre>

<p>This would be called just like printf, could be:</p>

<pre><code>Debug_Message(1, "%d%d%d", 1, 2, 3);
</code></pre>

<p>could be:</p>

<pre><code>Debug_Message(1, "%d", 1);
</code></pre>
