<p>You have the wrong field because you rely on the Code First's convention but your are not following it correctly for the <code>UsersOrders</code> entity. Assuming that <code>Id</code> is the primary key of <code>User</code> class then it will look for <code>UserId</code> (not <code>User_Id</code>) which is not in your <code>UsersOrders</code> entity. The same goes for <code>Order</code> navigational property in <code>UsersOrders</code>.</p>

<p>To fix this you have to follow the convetion by refactoring your <code>UsersOrders</code> and use data annotations like this: (If you use this solution you must remoeve configuration for <code>UsersOrders</code> entity in your <code>OnModelCreating</code> implementation.</p>

<pre><code>public class UsersOrders
{
    [Key]
    public int OrderID { get; set; }
    [Key]
    public int UserID { get; set; }
    public virtual User User { get; set; }
    public virtual Order Order { get; set; }
}
</code></pre>

<p>Or in your <code>OnModelCreating</code> implementation make the following changes for <code>UsersOrders</code> entity like this:</p>

<pre><code>modelBuilder.Entity&lt;UsersOrders&gt;().HasKey(od =&gt; new { od.Order_ID, od.User_ID });
modelBuilder.Entity&lt;UsersOrders&gt;().HasRequired(os =&gt; os.User).WithMany(p =&gt; p.Orders).HasForeignKey(p =&gt; p.User_ID);
modelBuilder.Entity&lt;UsersOrders&gt;().HasRequired(os =&gt; os.Order).WithMany(p =&gt; p.Users).HasForeignKey(p =&gt; p.Order_ID);
</code></pre>

<p>In the two solutions, note that <code>UsersOrders</code> use composite keys using <code>Order_Id</code> and <code>User_Id</code> not only <code>Order_ID</code>. </p>
