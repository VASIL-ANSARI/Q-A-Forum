<p>Why are more types a problem? It does not necessarily mean much more code. For instance, you could make you iterator-type a template that takes an iteration-policy as template-parameter. The iteration-policy could then provide the implementation of the iteration:</p>

<pre><code>struct iterate_all_policy {
    iterate_all_policy(iterator&lt;iterate_all_policy&gt; &amp; it) : it(it) {}

    void advance() { /* implement specific advance here */ }
private:
    iterator&lt;iterate_all_policy&gt; &amp; it;
}
</code></pre>

<p>You will probably have to make the iteration-policy-classes friends of the iterator-types.</p>
