<p>Option 1:
If your cvs is already sorted by date, you could implement a group reader, which reads lines until a key value changes. After that, the whole group can be passed as one item to the processor. </p>

<p>Such a group reader could look like this:</p>

<pre><code>  private SingleItemPeekableItemReader&lt;I&gt; reader;
  private ItemReader&lt;I&gt; peekReaderDelegate;

  @Override
  public void afterPropertiesSet() throws Exception {
    Assert.notNull(peekReaderDelegate, "The 'itemReader' may not be null");
    this.reader= new SingleItemPeekableItemReader&lt;I&gt;();
    this.reader.setDelegate(peekReaderDelegate);
  }

  @Override
  // GroupDTO is just a simple container. It is also possible to use
  // List&lt;I&gt; instead of GroupDTO&lt;I&gt;
  public GroupDTO&lt;I&gt; read() throws Exception {
    State state = State.NEW; // a simple enum with the states NEW, READING, and COMPLETE
    GroupDTO&lt;I&gt; group = null;
    I item = null;

    while (state != State.COMPLETE) {
      item = reader.read();

      switch (state) {
        case NEW: {
          if (item == null) {
            // end reached
            state = State.COMPLETE;
            break;
          }

          group = new GroupDTO&lt;I&gt;();
          group.addItem(item);
          state = State.READING;
          I nextItem = reader.peek();
          // isGroupBreak returns true, if 'item' and 'nextItem' do NOT belong to the same group
          if (nextItem == null || getGroupBreakStrategy.isGroupBreak(item, nextItem)) {
            state = State.COMPLETE;
          }
          break;
        }
        case READING: {
          group.addItem(item);

          // peek and check if there the peeked entry has a new date
          I nextItem = peekEntry();
          // isGroupBreak returns true, if 'item' and 'nextItem' do NOT belong to the same group
          if (nextItem == null || getGroupBreakStrategy.isGroupBreak(item, nextItem)) {
            state = State.COMPLETE;
          }
          break;
        }
        default: {
          throw new org.springframework.expression.ParseException(groupCounter, "ParsingError: Reader is in an invalid state");
        }
      }
    }

    return group;
  }
</code></pre>

<p>You need a SingleItemPeekableItemReader, in order to pre-read the next element. This one wraps your normal reader.</p>

<p>Option 2:
Step one is as you have proposed, but simply write a tasklet for step 2. There is no need to use reader-process-writer approach, instead a simple tasklet could be used that writes the content of your map to a file.</p>

<p>Option 3:
If you really wanna use a reader-processor-writer approach for step 2, write your own reader that iterates over your map.</p>

<p>something like (I did not test that code):</p>

<pre><code>public class MapReader implements ItemReader {

     private MapContainer container;
     private Iterator&lt;Map.Entry&lt;Date, Integer&gt; mapIterator;

     @PostConstruct
     public void afterPropertiesSet() {
        Assert.notNull(container);
        iterator = container.getMap().entry().iterator;
     }

     public void setMapContainer(MapContainer container) {
         this.container = container;
     }

     public Map.Entry&lt;Date, Integer&gt; read() {
        if (iterator.hasNext()) {
           return iterator.next();
        }
        return null;
      }
}

@Component
public class MapContainer {
    private Map&lt;Date, Integer&gt; data = new Hashmap&lt;&gt;();

    public Map&lt;Date, Integer&gt; getMap() {
        return data;
    }

    // add modifier method as needed for step 1

}
</code></pre>

<p>so, you create a single spring-bean instance for the Container, inject it in your processor of step 2, fill it there, also inject it in the reader above.</p>
