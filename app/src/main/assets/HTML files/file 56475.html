<p>I would have done that this way</p>

<pre><code>public class Test {

    interface Copyable&lt;T&gt; {
        void copyFrom(Copyable&lt;T&gt; v);
        T getV();
    }

    interface Val&lt;T&gt; extends Copyable&lt;T&gt; {
        // Do not know if this is usefull
    }

    abstract class AbstractVal&lt;T&gt; implements Val&lt;T&gt; {
        T value;
        public AbstractVal(T val) {
            this.value = val;
        }
    }

    class StrVal extends AbstractVal&lt;String&gt; {

        public StrVal(String o3) {
            super(o3);
        }

        @Override
        public void copyFrom(Copyable&lt;String&gt; v) {
            this.value = v.getV();
        }

        @Override
        public String getV() {
            return this.value;
        }
    }

    class Bla&lt;T extends AbstractVal&lt;S&gt;, S&gt; {
        final T value1;
        final T value2;

        public Bla( T value1,  final T value2) {
            this.value1 = value1;
            this.value2 = value2;
        }

        void letsCopy() {
            value1.copyFrom(value2);
        }
    }

    void test() {
        StrVal o1 = new StrVal("qwe");
        StrVal o2 = new StrVal("qwe2");
        StrVal o3 = new StrVal("zxc");
        Bla tester = new Bla&lt;StrVal, String&gt;(o1, o2);
        tester.letsCopy();
        System.out.println(tester.value1.getV());
    }

    public static void main(String[] args) {
        Test t = new Test();
        t.test();
    }
}
</code></pre>

<p>Maybe a little complicated for what it's doing but I think it's the idea.. </p>
