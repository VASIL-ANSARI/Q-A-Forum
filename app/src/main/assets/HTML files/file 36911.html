<p>Your regex is currently greedy; <a href="http://www.regular-expressions.info/dot.html" rel="nofollow">the dot</a> (<code>.</code>) matches as much as it can, so it will match everything between the <code>[lang:xx]</code> tag and <code>[endlang:xx]</code> tag. In order to fix this issue, you can make the pattern lazy by adding a <code>?</code> at the end, like so:</p>

<pre><code>\[lang:([a-z]{2})\]\R*(.*?)\R*\[endlang:\1\]
</code></pre>

<p>Note that I've also used <a href="http://stackoverflow.com/a/18992691/1438393"><code>\R</code></a> in the regex which will capture any vertical whitespace characters in the string â this way, the newline characters will not get included in the match results.</p>

<p>Additionally, the language code from the opening tag can differ from that one used in the matched ending tag. I've used a <a href="http://www.regular-expressions.info/backref.html" rel="nofollow">backreference</a> (<code>\1</code>) in the ending tag to avoid that â it makes the matching more robust.</p>

<p>Complete code:</p>

<pre><code>$pattern = '|\[lang:([a-z]{2})\]\R*(.*?)\R*\[endlang:\1\]|si';

preg_match_all($pattern, $value, $matches);

// Combine the languages and matched strings to create an associative array
$result = array_combine($matches[1], $matches[2]);

var_dump($result);
</code></pre>

<p><a href="https://eval.in/177721" rel="nofollow"><strong>Demo</strong></a></p>
