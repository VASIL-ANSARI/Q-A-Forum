<p>You can attach to the event from the child instance.</p>

<pre><code>public abstract class Parent
{
      public event Action Something;

      public void OnSomething()
      {
          if (Something != null)
          {
              Something();
          }
      }
}
public class Child : Parent
{

}

Child c = new Child();
c.Something += () =&gt; Console.WriteLine("Got event from child");
c.OnSomething();
&gt; Got event from child
</code></pre>

<p>You can even declare it as a <code>Parent</code> type that contains a child:</p>

<pre><code>Parent c2 = new Child();
c2.Something += () =&gt; Console.WriteLine("Got event from Parent type");
c2.OnSomething();
&gt; Got event from Parent type
</code></pre>

<p>An abstract class is just a code template that gets copied into every class that inherits from it (to put it simply). Think of it like, all of your <code>Child</code> classes contain an identical copy of the code that exists in <code>Parent</code>.</p>

<hr>

<p>Note that this will also produce a unique event handler for each instance of <code>Child</code>. Having a static event handler for all <code>Child</code>s that derive from <code>Parent</code> would look like this, and requires no code in <code>Child</code>:</p>

<pre><code>public abstract class Parent
{
    public static event Action Something;

    public static void OnSomething()
    {
        if (Something != null)
        {
            Something();
        }
    }
}
</code></pre>

<p>Then, you could do something like this, for example:</p>

<pre><code>Parent.Something += () =&gt; Console.WriteLine("This will be invoked twice.");

Child c = new Child();
Child c2 = new Child();
c.OnSomething();
c2.OnSomething();

&gt; This will be invoked twice.
&gt; This will be invoked twice.
</code></pre>

<p>Both of those objects/event calls will invoke the same event handler even though they come from separate children.</p>
