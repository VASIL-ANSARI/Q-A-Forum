<blockquote>
  <p>Is <code>TObjectList&lt;T&gt;.Contains()</code> really O(n<sup>2</sup>)?</p>
</blockquote>

<p>No, it is O(n). The implementation of <code>Contains()</code> is simply a linear search. The graph you show is not linear, but then we don't know how you generated it. Presumably your code doesn't test purely the performance of <code>Contains()</code>. </p>

<p>My guess is that you are measuring the population of your list. For your code that will be O(n<sup>2</sup>). Loosely speaking, adding items is O(n), and checking if they are in the list is also O(n) due to your choice of container, i.e. that you have to perform linear search on each add to the list. So put that together and you have O(n<sup>2</sup>) performance.</p>

<blockquote>
  <p>Any better function to check whether an element exists or not?</p>
</blockquote>

<p>Not if your data is held in this type of container. A <code>TObjectList&lt;T&gt;</code> is a random access array in performance terms. You would need to choose a different container if you wanted better than <code>O(n)</code> search performance. For instance a <code>TDictionary&lt;K,V&gt;</code> would give you <code>O(1)</code> search performance.</p>

<blockquote>
  <p>Instead of <code>TObjectList&lt;T&gt;</code> can we change to any other more faster data type for building generic graphs?</p>
</blockquote>

<p>See above.</p>

<blockquote>
  <p>I know C++ Boost or METIS/HMETIS Graph libs, but I can't write on a short timeframe evaluation programs for these lib. Do they also suffer that O(n<sup>2</sup>) problem on building large graphs?</p>
</blockquote>

<p>I don't know. As I said, we don't know where your graph comes from so we can't actually tell what you are measuring. However, any decent library in this field is surely not going to perform a full linear search over all edges before adding a new one.</p>
