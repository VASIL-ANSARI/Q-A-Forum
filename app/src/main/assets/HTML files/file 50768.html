<p>It is acceptable if you "know" the string variable to be "clean", if you don't care about the warning most modern compilers generate for that construct. <strong>Because</strong>:</p>

<ol>
<li><p>If your string contains conversion specifiers "by accident", you are invoking undefined behaviour.</p></li>
<li><p>If you read that string from somewhere, a malicious attacker could exploit point 1. above to his ends.</p></li>
</ol>

<p>It's <strong>generally better</strong> to use <code>puts()</code> or <code>fputs()</code> as they avoid this problem, and consequently don't generate a warning. (<code>puts()</code> also tosses in an automatic <code>'\n'</code>.)</p>

<p>The <code>*puts()</code> functions also have (marginally) better performance. <code>*printf()</code>, even on nothing more than <code>"%s"</code> as format string, <em>still</em> has to parse that conversion specifier, and count the number of characters printed for its return value.</p>

<p>Thanks to users 'rici' and 'Grady Player' for pointing out the character counting and compiler warning. My C got a bit rusty it seems. ;-)</p>
