<p>When you divide two integers in Java, the result is rounded down ("truncated") automatically.</p>

<p>The expression <code>longDiff / MILLS_IN_DAY</code> isn't equal to <code>18.99999</code>, it is equal to <code>18</code>.  Java essentially calculates <code>18.99999</code> and then throws everything after the decimal point away, <em>before</em> you can do anything with it.  Rounding up with <code>ceil</code> won't help at that point, because you just end up calculating <code>ceil(18)</code> which is just <code>18</code>.</p>

<p>One solution to this is to cast the numbers to <code>double</code> before you divide them.  <code>double</code>'s are floating point values, so dividing them does not round the result down.  To use doubles, replace</p>

<pre><code>longDiff / MILLS_IN_DAY
</code></pre>

<p>with</p>

<pre><code>((double)longDiff) / ((double)MILLS_IN_DAY)
</code></pre>

<p>Another solution, which may be more computationally efficient but a little bit less elegant is to simply add <code>1</code> to the result.  This isn't strictly equivalent, because when you are within a millisecond of midnight the result will be a day more than you expected, but this is essentially unnoticeable.  To take this approach, you would replace the line:</p>

<pre><code>return (int) (Math.ceil(longDiff / MILLS_IN_DAY));
</code></pre>

<p>with</p>

<pre><code>return longDiff / MILLS_IN_DAY + 1;
</code></pre>
