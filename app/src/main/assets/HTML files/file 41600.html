<p>Possibly the <em>easiest</em> thing to do will be to define</p>

<p><code>std::vector&lt;std::shared_ptr&lt;DenseCRF&gt;&gt; crf_vec;</code></p>

<p>instead. Then use</p>

<p><code>crf_vec.push_back(new DenseCRF(W, H));</code></p>

<p><code>std::shared_ptr</code> is a <em>smart pointer</em>. It will <code>delete</code> the class once the vector goes out of scope and all other smart pointers referring to the object are also out of scope. The advantage of this approach is that <code>std::shared_ptr</code> <em>does</em> have a copy constructor so can be used in a <code>std::vector</code>.</p>

<p>There is an alternative: using <em>emplacement</em>. But that's trickier.</p>

<p>(Also, you can replace <code>DenseCRF( DenseCRF &amp; o ){}</code> with <code>DenseCRF(DenseCRF&amp;) = delete;</code>. This is an explicit <em>deletion</em> of the copy constructor.)</p>
