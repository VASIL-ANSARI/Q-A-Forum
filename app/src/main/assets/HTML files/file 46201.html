<p>I can't say for sure the exact pattern you're illustrating, but it seems to at least fall into the basic strategy pattern. </p>

<p>Based on your mention of not needing to instantiate classes or add boostraping code when you include new classes... This is something a good dependency injection lib and conventions-based strategy can help with.  Add in some sort of assembly scan, and you should rarely have to deal with configuring components.</p>

<p>Below is an example of how this might be accomplished using Ninject and the Ninject Conventions extension (Nuget package ninject.extensions.conventions).    This example doesn't require any attribute decorators as your question demonstrates, but you could create and use them if you need to. </p>

<p>Also, Structure Map and MEF are other popular dependency injection libraries you might experiment with and see what works best for you.</p>

<pre><code>static IKernel kernel = new StandardKernel();
void Main()
{
    //
    // Automatic binding using 
    // Ninject.Extensions.Conventions
    // Generally, you only want to declare your
    // DI container once in the application lifetime
    // Expecially in web apps, you will also need to 
    // consider the scope of bound classes, such as:
    //   Transient, Thread, Singleton, or Request
    kernel.Bind(x=&gt;x
        .FromThisAssembly()
        .SelectAllClasses()
        .BindAllInterfaces()
    );
    //
    // Now we can resolve the loader and run it
    // Compare this code to how it would look if you
    // manually instantiate all the dependencies and consider:
    // - How much additional code is there?
    // - How easy is it to perform unit tests on the various
    //   components (Mocking is useful here)?
    // - What is the effort if I need to swap out a service
    //   such as IMessageWriter?
    //
    // IMPORTANT: For example only. Do not use kernel.Get()
    // all over your code base.
    // This results in a ServiceLocator anti-pattern! 
    ProcessRunner runner = kernel.Get&lt;ProcessRunner&gt;();
    runner.Execute();
}

public interface IMessageWriter{
    void Write(string message);
}

public class MessageWriter : IMessageWriter
{
    public void Write(string message){
        Console.WriteLine ("MESSAGE: {0}", message);
    }
}

public interface IProcessStep {
    int Step{ get; }
    void Execute();
}

public class ProcessRunner
{
    private readonly IEnumerable&lt;IProcessStep&gt; steps;
    public ProcessRunner(IEnumerable&lt;IProcessStep&gt; steps)
    {
        this.steps = steps;     
    }

    public void Execute(){
        steps
            .OrderBy (o =&gt; o.Step)
            .ToList()
            .ForEach(i=&gt;i.Execute());
    }
}
public class ProcessStep1 : IProcessStep
{
    private readonly IMessageWriter writer;
    public ProcessStep1(IMessageWriter writer)
    {
        this.writer = writer;       
    }
    public int Step { get { return 10; }}
    public void Execute(){
        writer.Write("Hello from step1!");      
    }
}
public class ProcessStep2 : IProcessStep
{
    private readonly IMessageWriter writer;
    public ProcessStep2(IMessageWriter writer)
    {
        this.writer = writer;       
    }
    public int Step { get { return 20; }}
    public void Execute(){
        writer.Write("Hello from step2!");  
    }
}
public class ProcessStep3 : IProcessStep
{
    private readonly IMessageWriter writer;
    public ProcessStep3(IMessageWriter writer)
    {
        this.writer = writer;       
    }
    public int Step { get { return 30; }}
    public void Execute(){
        writer.Write("Hello from step3!");  
    }
}
</code></pre>

<p>OUTPUT</p>

<pre><code>MESSAGE: Hello from step1!
MESSAGE: Hello from step2!
MESSAGE: Hello from step3!
</code></pre>
