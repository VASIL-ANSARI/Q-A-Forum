<p><strike>In the code above, prefix <code>++</code> has precedence over <code>*=</code>, and so gets executed first. The result is that <code>l</code> equals <code>4</code>.</strike></p>

<p><strike><strong>UPDATE:</strong> It is indeed undefined behavior. My assumption that precedence ruled was false.</p>

<p>The reason is that <code>l</code> is both an lvalue and rvalue in <code>*=</code>, and also in <code>++</code>. These two operations are not sequenced. Hence <code>l</code> is written (and read) twice "without a sequence point" (old standard wording), and behavior is undefined.</p>

<p>As a sidenote, I presume your question stems from changes regarding sequence points in C++0x. C++0x has changed wording regarding "sequence points" to "sequenced before", to make the standard clearer. To my knowledge, this does not change the behavior of C++.</strike></p>

<p><strong>UPDATE 2:</strong> It turns out there actually is a well defined sequencing as per sections 5.17(1), 5.17(7) and 5.3.2(1) of the <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2010/n3126.pdf" rel="nofollow">N3126 draft for C++0x</a>. @Johannes Schaub's answer is correct, and documents the sequencing of the statement. Credit should of course go to his answer.</p>
