<p>C#</p>

<pre><code>public static void DoIt(IntPtr srcWindow)
{
Graphics g = Graphics.FromHwnd(srcWindow);
g.DrawLine(new Pen(Color.Red), new Point(0, 0), new Point(400, 400));
}
</code></pre>

<p>Delphi:</p>

<pre><code>type
    intPtrArgs = procedure(hand : hwnd); StdCall;

procedure T_CS.RePaint;  //extends TWinControl
var
  Hm: HModule;
  ExtDoIt: intptrArgs;  
begin
  Hm := LoadLibrary(pchar('my.dll'));
  try
    @ExtDoIt := GetProcAddress(Hm, 'DoIt');
    ExtDoIt(Handle);
  finally
    FreeLibrary(Hm);
  end;
end;
</code></pre>

<p>It's silly to load an unload on each paint, but for example purposes it works.  </p>

<p>For anyone else trying to do this, you will need to google "Reverse P/Invoke" to be able to see the C# DLL procedure in another language.</p>

<p>Example Reverse P/Invoke
<a href="http://www.blong.com/Conferences/BorConUK2002/Interop1/Win32AndDotNetInterop.htm" rel="nofollow">http://www.blong.com/Conferences/BorConUK2002/Interop1/Win32AndDotNetInterop.htm</a></p>
