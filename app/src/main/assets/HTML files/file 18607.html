<p>Code below has been tested. Please correct or downvote as needed. Apologies if formatting for code is invalid.
I am going to give you an example that I just put together, off the top of my head.
It might not be exactly in line with your requirements, but it should get you started.
I will then explain how my code works, and give you some pointers to modify your code.</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main()
{
int i,vowels,pals,words;
vowels=words=pals=i=0;
long max=1024;
char *sentence=malloc(sizeof(char)*max);
printf("sentence:");
fgets(sentence,max,stdin);
if (sentence[strlen(sentence)-1]=='\n')
{
sentence[strlen(sentence)-1]='\0';
}
for (i=0;i&lt;=strlen(sentence);i++)
{
char x;
x=sentence[i];
switch (x)
{
case 'a':
case 'A':
case 'e':
case 'E':
case 'i':
case 'I':
case 'o':
case 'O':
case 'u':
case 'U':
vowels+=1;
}
if ((x==' '||x=='\0') &amp;&amp; i&gt;0 &amp;&amp; sentence[i-1]!=' ')
{
words+=1;
}
if (i&gt;0 &amp;&amp; (x=='\0'||x==' '))
{
char *lastchar,*pos,*word;
lastchar=sentence+i;
pos=(sentence+i)-1;
while (*pos!=' ' &amp;&amp; pos!=sentence)
{
pos--;
if (*pos==' ')
{
pos++;
break;
}
}
word=strndup(pos,lastchar-pos);
if (isSameStringReversed(word)==0)
{
pals+=1;
}
free(word);
} //if on space for pal
} //for
printf("vowels:%d words:%d pals:%d\n",vowels,words,pals);
free(sentence);
}

int isSameStringReversed(char *word)
{
int i;
char destword[strlen(word)+1];
int j;
for (i=strlen(word)-1,j=0;i&gt;=0;i--,j++)
{
destword[j]=word[i];
}
return strncmp(word,destword,strlen(word));
}
&lt;/pre&gt;
</code></pre>

<p>Now some code descriptions.</p>

<pre><code>//here are our includes. nothing special.
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main()
{
//defines
int i,vowels,pals,words;
long max;
//set all to zero. (an empty sentence has no words.)
vowels=words=pals=i=0;
//max is the largest sentence you can enter
max=1024;
//allocate space for the sentence in memory.
char *sentence=malloc(sizeof(char)*max);
//prompt for sentence
printf("sentence:");
//read characters from stdin, making sure that only the first 1023 characters are read. (fgets removes the last character(s) if it is greater or equal to the provided limit. e.g. providing 1024 means that all characters past character 1023 are removed, and a \0 is appended to sentence.)
fgets(sentence,max,stdin);
//check last character of sentence for \n character, as some calls leave newlines attached.
if (sentence[strlen(sentence)-1]=='\n')
{
//set the last character to \0 if newline found. \0 terminates strings in c.
sentence[strlen(sentence)-1]='\0';
}
//move through every character in the sentence, including the terminating \0 character. This way, we make sure we pass every word and character provided, and we don't have to check at the end of loops for remaining characters.
for (i=0;i&lt;=strlen(sentence);i++)
{
//defines for this for loop
char x;
//pull the current character from sentence. this way, we don't ahve to do sentence[i] each time.
x=sentence[i];
//switch is like an extended if statement with lots of possible branches.
switch (x)
{
//if x, the current character, equals 'a'
case 'a':
//if x, the current character, equals uppercase 'A'
case 'A':
//etc for the rest of the variables (excluding the sometimes cases of 'y')
case 'e':
case 'E':
case 'i':
case 'I':
case 'o':
case 'O':
case 'u':
case 'U':
//if x equals any of the above letters, then
//we add one to vowels, since our current letter is a vowel.
vowels+=1;
}
//if our current character is a space character, or a \0, meaning the end of our sentence string,
//and we are not on our first character, (because our sentence is not empty), and the character before our current character is not a space (because we don't count double spaces as words)
if ((x==' '||x=='\0') &amp;&amp; i&gt;0 &amp;&amp; sentence[i-1]!=' ')
{
//it's a word, so add one to the words count
words+=1;
}
//again, if we are on a space or at the end of our string,
if (i&gt;0 &amp;&amp; (x=='\0'||x==' '))
{
//defines
char *lastchar,*pos,*word;
//lastchar is a pointer to where we are currently sitting (on the space or end character of the string)
lastchar=sentence+i;
//pos is a pointer to the previous character
//say we have
//A bunny likes racecar races.
//if we are on the space just after racecar, then lastchar points to the space, and pos points to the r in racecar
pos=(sentence+i)-1;
//while the character that pos points to isn't a space, and we aren't at the beginning of the string
while (*pos!=' ' &amp;&amp; pos!=sentence)
{
//move the pointer pos back one character
pos--;
//if we're on a space, we've moved back before the previous word.
if (*pos==' ')
{
//we want to move pos to the first character of the preceding word.
pos++;
break;
}
}
//make a new copy of the current word, which we do by using strndup, analagus to (duplicate string with only n number of characters).
//we take the value of pos, and subtract it from lastchar, which gives us the length of the preceeding word.
//we used racecar as our example, so the space after racecar, minus the position of the r, gives us 7, which is the amount that strndup copys.
word=strndup(pos,lastchar-pos);
//if the function below returns 0
if (isSameStringReversed(word)==0)
{
//we've found a palindrome
pals+=1;
}
//free word, a.k.a. the chunk of memory we created for checking the last word as a palindrome.
free(word);
} //endif palindrome boundary check
} //endfor character in sentence loop
//print the character vowel and palindrome counts
printf("vowels:%d words:%d pals:%d\n",vowels,words,pals);
//free the sentence, as we're done with it.
free(sentence);
}

//function
//word is a pointer to char, or an array of characters. In this case word points to "word" defined above,
//or "racecar" from our example.
int isSameStringReversed(char *word)
{
//defines
//take the length of the provided word, and add a character to it for the \0, or ending character.
char destword[strlen(word)+1];
int i;
int j;
//set i to the number of the last character in word, and j to 0.
//move through the string, subtracting one from i and adding one to j.
for (i=strlen(word)-1,j=0;i&gt;=0;i--,j++)
{
//move from right to left, assigning word to destword in reverse order.
//racecar would take the last r, assign it to the first slot in destword, the second to last a to the second position, and so on.
destword[j]=word[i];
//continue the loop
}
//see if the two reversed strings match, with strncmp.
return strncmp(word,destword,strlen(word));
}
</code></pre>

<p>Explanations.
Notice that we used pointers everywhere except in the last function.
This is for good reason.
Pointers are flexible, understandable, and allow mathmatical operations.
They are also quick and lend to code readability.
If you notice, we use these mathmatical properties when we subtract pos from lastchar.
This isn't as important when using chars, but when you get into other datatypes, moving from element to element will be quite helpful.
Also, if you notice, all of my variables are clearly labeled.
Again, this will help with code readability and maintainability.
If the code above was not enough, feel free to let me know, and I will do my best to elaborate further on a specific issue.</p>
