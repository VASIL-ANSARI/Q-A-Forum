<p>Yes, you can do that.. Using a bit of "laziness" as well as higher order function using currying , there may be other technique as well. Infact using this you can wrap any function which produce a result.</p>

<pre><code>let worker = new BackgroundWorker()
let numIterations = 1000

let rec computeFibonacci resPrevPrev resPrev i = 
            let res = resPrevPrev + resPrev
            if i = numIterations then
                box res
            else 
                computeFibonacci resPrev res (i+1)


let wrapper (result:obj Lazy) (args:DoWorkEventArgs) = args.Result &lt;- result.Force()


worker.DoWork.Add( lazy (computeFibonacci 1 1 2) |&gt; wrapper)

worker.RunWorkerCompleted.Add(fun args -&gt;
    MessageBox.Show(sprintf "result = %A" args.Result) |&gt; ignore)

//execute the worker
worker.RunWorkerAsync()
</code></pre>
