<p>Recursion depth likely exceeded.</p>

<p>Recursion depth appears to go up proportional to the square of the limit.<br>
Try</p>

<pre><code>#include &lt;stdio.h&gt;
int depth = 0;
int maxdepth = 0;

void rec(int n, int x) {
  depth++;
  if (depth &gt; maxdepth) maxdepth = depth;
  if (x &gt; 860) {
    depth--;
    return;
  }
  if (n == x) {
    printf("%d ,", x);
    rec(2, x + 1);
    depth--;
    return;
  }
  if (x % n == 0) {
    rec(2, x + 1);
    depth--;
    return;
  }
  rec(n + 1, x);
  depth--;
}

int main(void) {
  rec(2, 2);
  printf("\n depth %d maxdepth %d\n", depth, maxdepth);
  return 0;
}
</code></pre>

<p>max depth 60099 (and that is with limit 860)</p>

<p>Code needs a less depth intensive approach.  </p>

<p>Try dividing <code>n</code> by all primes 2 to sqrt(n). If number of even, it in a prime only of 2.  Else if below 7, it is  a prime if not 1.  Else to find a prime above 7, add 2 to previous prime candidate and recursively test if it is a prime. So you have 2 functions <code>bool is_prime(n)</code> and <code>unsigned next_prime(n)</code> calling each other. </p>

<p>max depth : 3 for all 1000</p>

<p>Like OP's <a href="http://stackoverflow.com/users/5132337/siraj">self description</a>, in this case "And too lazy to tell anything further."</p>
