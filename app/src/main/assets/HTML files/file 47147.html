<p>There is no difference between copy or direct-initialization for arrays. Both cases are handled identically by the compiler. The analogy you make in the beginning is more of a rule of thumb. In reality, an array cannot be initialized by another array unless it is a string literal. BTW your analogy is not entirely correct. The target array would be direct-initialized with the temporary array:</p>

<pre><code>const char test2[](test1);
</code></pre>

<p>But this still won't compile for the same reason. This is how initialization of a character array works.</p>

<p>[dcl.init]/p17:</p>

<blockquote>
  <p>The semantics of initializers are as follows. The <em>destination type</em> is the type of the object or reference being initialized and the <em>source type</em> is the type of the initializer expression. If the initializer is not a single (possibly parenthesized) expression, the source type is not defined.</p>
  
  <ul>
  <li>If the initializer is a (non-parenthesized) <em>braced-init-list</em>, the object or reference is list-initialized (8.5.4).</li>
  <li>If the destination type is a reference type, see 8.5.3.</li>
  <li><strong>If the destination type is an array of characters, an array of <code>char16_t</code>, an array of <code>char32_t</code>, or an array of <code>wchar_t</code>, and the initializer is a string literal, see 8.5.2.</strong></li>
  </ul>
</blockquote>

<p>8.5.2:</p>

<blockquote>
  <p>An array of narrow character type (3.9.1), <code>char16_t</code> array, <code>char32_t</code> array, or <code>wchar_t</code> array can be initialized by a narrow string literal, <code>char16_t</code> string literal, <code>char32_t</code> string literal, or wide string literal,
  respectively, or by an appropriately-typed string literal enclosed in braces (2.13.5). Successive characters of the value of the string literal initialize the elements of the array. <em>[ Example:</em></p>

<pre><code>char msg[] = "Syntax error on line %s\n";
</code></pre>
  
  <p>shows a character array whose members are initialized with a <em>string-literal</em>. [..]</p>
</blockquote>

<p>In your other example the string literal decays into a pointer to its first element, with which <code>test3</code> is initialized. This code is invalid in C++11<sup>1</sup>, as the decayed pointer is <code>const char*</code>, but this was a valid conversion in C because string literals were non-const. It was allowed in until C++03 where it was deprecated.</p>

<hr>

<p><sub>1: Some compilers still allow the conversion in C++11 as an extension. </sub></p>
