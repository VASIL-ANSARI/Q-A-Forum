<p>The problem is that you're not ensuring that the steps in your walk are valid.</p>

<p>The way you have it currently, <code>walk</code> could pick a <code>neighboor</code> that is out of the bounds of the maze.  For example, if a maze is 5x5, attempting to access <code>maze[5][?]</code> or <code>maze[?][5]</code> will result in an <code>IndexError</code> like you get.</p>

<p>To fix this, you could define an <code>is_valid</code> method for your maze class, e.g.:</p>

<pre><code>def is_valid(self, x, y):
    return (0 &lt;= x &lt; self.size) and (0 &lt;= y &lt; self.size)
</code></pre>

<p>Then, you when you pick a <code>neighboor</code>, you ensure it's valid:</p>

<pre><code>#...
else:
    new = choice(neighboor)
    while self.is_valid(new[0], new[1]) == False:
        new = choice(neighboor)

    while self.maze[new[0]][new[1]].getVisit():
#...
</code></pre>

<p>This snippet picks a <code>neighboor</code>, then, if it's not valid, regenerates <code>new</code> until it finds a valid one.</p>

<p>But this loop would be better written as:</p>

<pre><code>#...
else:
    while True:
        new = choice(neighboor)
        if self.is_valid(new[0], new[1]): break

    while self.maze[new[0]][new[1]].getVisit():
#...
</code></pre>

<p>There are more problems with your code, however, as you'll eventually see, but this will get you past this specific one.</p>
