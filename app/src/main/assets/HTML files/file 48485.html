<p>It works for me, or rather it works as the grammar describes things.</p>

<pre><code>&lt;!-- language: lang-none --&gt;
7-29T08:42
[Int] 7
[Delimiter] -
[Text] 29T08
[Delimiter] :
[Int] 42
[Delimiter] 
</code></pre>

<p>Indeed, after the scanner matches the <code>-</code> delimiter</p>

<ul>
<li>it gets <code>2</code>, which matches [:digit:]+, and {Parameter}</li>
<li>it gets <code>9</code>, which matches [:digit:]+, and {Parameter}</li>
<li>it gets <code>T</code>, which doesn't match [:digit:]+ but still matches {Parameter}</li>
<li>then <code>0</code> and <code>8</code> keep matching {Parameter}</li>
<li><code>:</code> doesn't match {Parameter}; and the token <code>{Parameter} 29T08</code> is returned.</li>
</ul>

<p>Note that {SpecialT} is recognized if you enter only that:</p>

<pre><code>&lt;!-- language: lang-none --&gt;
5T6
[Delimiter] 5T6
</code></pre>

<p>Your first problem is that SpecialT is capturing too much.</p>

<p>Your second problem is that {Parameter} matches virtually everything.</p>

<p>I suggest you define an ISO date more accurately:</p>

<pre><code>// HH:MM or HH:MM:ss
IsoTime = {Dig2} {Delimiter} {Dig2} ({Delimiter} {Dig2})?

// yyyy-mm-dd or yyyy-mm-ddT&lt;isotime&gt;
IsoDate =  {Dig4} ({Delimiter} {Dig2}){2} (T {IsoTime})?
</code></pre>

<p>This will create a nice token with the full 2015-07-29T16:42.</p>
