<p>The C Standard documents the minimum number of arguments that a compiler should accept for a function call:</p>

<blockquote>
  <p>C11 5.2.4.1 Translation limits</p>
  
  <p>The implementation shall be able to translate and execute at least one program that contains at least one instance of every one of the following limits:</p>
  
  <ul>
  <li><p>...</p></li>
  <li><p>127 arguments in one function call</p></li>
  <li><p>...</p></li>
  </ul>
</blockquote>

<p>Therefore, you should be able to pass at least 126 values to <code>printf</code> after the initial format string, assuming the format string is properly constructed and consistent with the actual arguments that follow.</p>

<p>If the format string is a string literal, the standard guarantees that the compiler can handle string literals at least 4095 bytes long, and source lines at least 4095 characters long.  You can use string concatenation to split the literal on multiple source lines.  If you use a <code>char</code> array for the format string, no such limitation exists.</p>

<p>The only environmental limit documented for the <code>printf</code> family of functions is this:</p>

<blockquote>
  <p>The number of characters that can be produced by any single conversion shall be at least 4095</p>
</blockquote>

<p>This makes the behavior of format <code>%10000d</code> at best defined by the implementation, but the standard does not mandate anything.</p>

<p>A compliant compiler/library combination should therefore accept at least 126 values for <code>printf</code>, whether your environment allows even more arguments may be defined by the implementation and documented as such, but is not guaranteed by the standard.</p>
