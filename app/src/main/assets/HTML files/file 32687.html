<p>In synchronous code, continuation is performed when the line ends <code>;</code> </p>

<p>With promises, continuation is performed via <code>.then</code>.  You were using a promise constructor and resolved it immediately, you did not wait for any task at all. I'd map my work into tasks and then either chain them with then or await them serially.</p>

<pre><code>//I'm assuming
zippyarray; // array of Zippy objects

var tasks = zippyarray.map(function(zippy,i){
    return function(){ // return a task on that zippy;
       // basic logic here
       return $.get({
            // ajax request
       }).then(function(data){
            // process data like in your code
            // possibly store later for later use too
            return process(data); // return the processed data;
       });
    }
});
</code></pre>

<p>Now we can execute them all sequentially:</p>

<pre><code> var p = tasks[0](); // start the first one
 for(var i = 1; i &lt; tasks.length; i++) p = p.then(tasks[i]);
 p.then(function(result){
       // all available here
 });
</code></pre>

<p>Or better, serially:</p>

<pre><code>$.when.apply(tasks.forEach(function(t){ return t(); })).then(function(results){
     // all done
})
</code></pre>
