<p><code>Unit</code> in Kotlin is mostly equivalent to <code>void</code> in Java, however only when the rules of the JVM allow it.</p>

<p>Functional types in Kotlin are represented by interfaces like:</p>

<pre><code>public interface Function1&lt;in P1, out R&gt; : Function&lt;R&gt; {
    /** Invokes the function with the specified argument. */
    public operator fun invoke(p1: P1): R
}
</code></pre>

<p>When you declare <code>(Int) -&gt; Unit</code>, from Java's point of view this is equivalent to <code>Function&lt;Integer, Unit&gt;</code>. That's why you have to return a value. To work around this problem, in Java there are two separate interfaces <code>Consumer&lt;T&gt;</code> and <code>Function&lt;T, R&gt;</code> for when you don't have/have a return value.</p>

<p>The Kotlin designers decided to forgo the duplication of functional interfaces and instead rely on compiler "magic". If you declare a lambda in Kotlin, you don't have to return a value because the compiler will insert one for you.</p>

<p>To make your live a little easier, you can write a helper method that wraps a <code>Consumer&lt;T&gt;</code> in a <code>Function1&lt;T, Unit&gt;</code>:</p>

<pre><code>public class FunctionalUtils {
    public static &lt;T&gt; Function1&lt;T, Unit&gt; fromConsumer(Consumer&lt;T&gt; callable) {
        return t -&gt; {
            callable.accept(t);
            return Unit.INSTANCE;
        };
    }
}
</code></pre>

<p>Usage:</p>

<pre><code>f(fromConsumer(integer -&gt; doSomething()));
</code></pre>

<hr>

<p>Fun fact: The special handling of <code>Unit</code> by the Kotlin compiler is the reason you can write code like:</p>

<pre><code>fun foo() {
    return Unit
}
</code></pre>

<p>or</p>

<pre><code>fun bar() = println("Hello World")
</code></pre>

<p>Both methods have return type <code>void</code> in the generated bytecode but the compiler is smart enough to figure that out and allow you to use return statements/expressions anyway.</p>
