<p>Non-static inner classes contain implicit reference to the instance of the enclosing class. All constructors of such inner classes take reference to the instance of enclosing class as an argument. </p>

<p>A simple example:</p>

<pre><code>import java.lang.reflect.*;

class Foo {
    class Bar {
        public Bar(int a) {
        }
    }

    public static void main(String[] args) {
        for(Constructor c: Bar.class.getDeclaredConstructors()) {
            System.out.println(c);
        }   
    }
}
</code></pre>

<p>prints <code>public Foo$Bar(Foo,int)</code> - note the first <code>Foo</code> parameter.
The <a href="http://docs.oracle.com/javase/1.5.0/docs/tooldocs/windows/javap.html" rel="nofollow">javap</a> tool can show information about structure - declared fields, methods and constructors of <code>Foo$Bar.class</code>:</p>

<pre><code>Compiled from "Foo.java"
class Foo$Bar extends java.lang.Object{
    final Foo this$0;
    public Foo$Bar(Foo, int);
}
</code></pre>

<p>Here you can see this implicit reference to the parent. JVM doesn't know about inner classes so the compiler has to introduce synthetic methods and fields to achieve required behavior. It is usually remain unnoticed until you need something like reflection. </p>

<p>In your particular case you can either make your inner classes static so there will be no implicit reference or remove explicit reference to the <code>MainActivity</code>.</p>
