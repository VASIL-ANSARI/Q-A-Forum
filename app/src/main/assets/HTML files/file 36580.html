<p><code>UITableView</code> follows the Model-View-Controller pattern. According to this pattern, all your changes need to be done to the model - in other words, to the data structure that stores the information from which you populate your cell data. Once you made the change to the model, you tell the view that the data has changed, which would then show the new data.</p>

<p>Let's say that your <code>cellForRowAtIndexPath</code> function reads from an array. Your <code>imageSwiped</code> function should then locate the item that has been swiped, modify its entry in the array, and call either <code>reloadData</code> or <code>reloadRowsAtIndexPaths</code>.</p>

<p>That's it! Once you notify the table view of the reload, it would go back to the array, find the modified data, and call your <code>cellForRowAtIndexPath</code> to display it.</p>

<p>Specifically, in your code add an array called <code>swipedCells</code> to the same class where you declared <code>tableData</code> array:</p>

<pre><code>var swipedCells = Boolean[](count:self.tableData.count, repeatedValue: false)
</code></pre>

<p>Now replace</p>

<pre><code>cell.testLabel.text = "Test Label"
</code></pre>

<p>line with</p>

<pre><code>if self.swipedCells[indexPath.row] {
    cell.testLabel.text = "Swiped!"
} else {
    cell.testLabel.text = "Test Label"
}
</code></pre>

<p>Finally, change the <code>imageSwiped</code> as follows:</p>

<pre><code>let indexPathRow = self.indexPathArray[recognizer.view.tag] as Int
self.swipedCells[indexPathRow] = true
self.tableView?.reloadData()
</code></pre>

<p>This way the cells that you have swiped would continue to have a label <code>"Swiped!"</code> even after you scroll.</p>
