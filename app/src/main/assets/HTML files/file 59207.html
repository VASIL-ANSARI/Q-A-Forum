<blockquote>
  <p>I feel like it will be very efficient to do those calls asynchronously (call and forget, no waiting).</p>
</blockquote>

<p>The problem with fire and forget is that you have no idea whether the operation failed. This is not acceptable for most code.</p>

<p>Many logging frameworks synchronously write to an in-memory store which is then periodically flushed to disk/db. This gives a good tradeoff between speed and log reliability.</p>

<blockquote>
  <p>I would like to put this [processA()] in a Task and use 4-8 tasks in parallel to call the [processA()].</p>
</blockquote>

<p>Sounds like you're confusing asynchrony with parallel processing. If you want to use parallel processing, then use <code>Parallel.ForEach</code> or something like that; if you want to use asynchrony, then the first step is to make <code>processA</code> asynchronous, and then use <code>await Task.WhenAll</code> for all the tasks to complete.</p>
