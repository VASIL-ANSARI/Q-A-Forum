<p>You can extend <code>execute</code> so that any additional parameters are passed to the supplied function:</p>

<pre><code>function Obj() {
    this.execute = function(f) {
        var args = [].slice.call(arguments, 1);
        f.apply(this, args);
    }
}

var obj = new Obj();
obj.execute(function(message){
    alert(message);
}, "boo!");
</code></pre>

<p>This line is the "magic" one:</p>

<pre><code>var args = [].slice.call(arguments, 1);
</code></pre>

<p>It uses the <code>Array.prototype.slice</code> function which is used to copy arrays, but (kind of) tricks the function into using the <code>arguments</code> pseudo-array as the source array (instead of the supplied <code>[]</code>), copying all of the elements apart from the first.</p>

<p>You can't just use <code>arguments.slice(1)</code> because <code>arguments</code> isn't a <em>real</em> JS array.  It has a <code>.length</code> property, and you can access <code>arguments[n]</code>, but it doesn't have all of the extra functions in its <code>prototype</code> that a real array has.  It's close enough though that the implementation of <code>.slice()</code> doesn't know any better.</p>

<p>NB: you should use <code>new</code> to create an object instance - in your original code you're just <em>calling</em> <code>obj()</code> immediately and then reassigning the (undefined) result back to <code>obj</code> - that code could never have worked at all.</p>
