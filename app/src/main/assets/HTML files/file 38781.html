<p>Your question is not clear. And your goals are more difficult than what you believe.</p>

<p>Either you consider that you want to somehow process <em>human language sentences</em> (e.g. in English). Then you want to study <a href="http://en.wikipedia.org/wiki/Natural_language_processing" rel="nofollow">natural language processing</a>, and you can find some libraries related to that field.</p>

<p>Or you consider that you want to interpret some formal programming or scripting language. Then you want to study <a href="http://en.wikipedia.org/wiki/Interpreter_%28computing%29" rel="nofollow">interpreters</a> and <a href="http://en.wikipedia.org/wiki/Compiler" rel="nofollow">compilers</a>. BTW, in that case, you might just embed an existing interpreter (like <a href="http://lua.org/" rel="nofollow">Lua</a>, <a href="http://www.gnu.org/software/guile" rel="nofollow">Guile</a>, <a href="http://python.org/" rel="nofollow">Python</a>, etc....) in your program.</p>

<p>You could also think in terms of <a href="http://en.wikipedia.org/wiki/Expert_systems" rel="nofollow">expert systems</a> with a <a href="http://en.wikipedia.org/wiki/Knowledge_base" rel="nofollow">knowledge base</a> made of <a href="http://en.wikipedia.org/wiki/Rule-based_system" rel="nofollow">rules</a> (this approach could be viewed as in the middle between NLP and scripting language) You'll then need some <a href="http://en.wikipedia.org/wiki/Inference_engine" rel="nofollow">inference engine</a> (perhaps <a href="http://clipsrules.sourceforge.net/" rel="nofollow">CLIPS</a>). See also <a href="http://bootstrappingartificialintelligence.fr/WordPress3/" rel="nofollow">J.Pitrat's blog.</a></p>

<p>Notice that even coding a simple interpreter is more difficult than you believe. You absolutely need to represent <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="nofollow">abstract syntax trees</a>, which you construct from textual input with a <a href="http://en.wikipedia.org/wiki/Parsing" rel="nofollow">parsing</a> phase.</p>

<p>BTW, All of NLP, expert systems, and interpreter design and implementation are difficult fields. You could get a PhD in all 3 fields (but you have to choose which).</p>

<p>If you go the embedded interpreter way: study the interpreters I mentioned (Guile, Lua, Python, <a href="http://nekovm.org/" rel="nofollow">Neko</a>, etc...) and choose which one you want, to embed.</p>

<p>If for whatever reason, you want to make an interpreter from scratch: Learn several programming languages first (including scripting languages like Ruby, Python, Ocaml, Scheme, Lua, Neko, ...). Read books on <a href="https://www.cs.rochester.edu/~scott/pragmatics/" rel="nofollow">Programming Language Pragmatics (by M.Scott)</a> and <a href="http://pagesperso-systeme.lip6.fr/Christian.Queinnec/WWW/LiSP.html" rel="nofollow">Lisp In Small Pieces (by Queinnec)</a>. Read also text books on compilation and parsing, and on <a href="http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29" rel="nofollow">Garbage Collection</a> and formal (e.g. denotational) <a href="http://en.wikipedia.org/wiki/Semantics_%28computer_science%29" rel="nofollow">semantics</a>. All this may need a dozen <em>years</em> of work.</p>

<p>Notice that by experience embedding a software in an interpreter is a very structuring design. If you did not thought of that at the beginning you probably need to redesign and refactor a lot your existing application. For instance, when embedding a software in an interpreter, you cannot afford that bad input crashes the program. So error handling and memory management (interfacing to the GC of the interpreter) is challenging and gives new constraints. Hence you'll need to re-think your application.</p>

<p>If all this is new (and even if you don't choose e.g. Guile as the embedding interpreter): learn and practice a bit of Scheme -e.g. with Guile or PltScheme- (e.g. reading <a href="http://mitpress.mit.edu/sicp/" rel="nofollow">SICP</a>), read a little bit about <a href="http://en.wikipedia.org/wiki/Lambda_calculus" rel="nofollow">Î»-calculus</a> and <a href="http://en.wikipedia.org/wiki/Closure_%28computer_programming%29" rel="nofollow">closures</a>, then read Queinnec's Lisp In Small Pieces book. Remember the <a href="http://en.wikipedia.org/wiki/Halting_problem" rel="nofollow">halting problem</a> (which is partly why interpreters are difficult to code).</p>

<p>BTW the syntax you are proposing (e.g. <code>rotate mat 1 by x 90</code>) is not very readable and looks <a href="http://en.wikipedia.org/wiki/COBOL" rel="nofollow">COBOL</a>-like. If possible, have a language which looks familiar to existing ones. Make it easy to <em>read</em> !</p>

<p><sup>Start by reading all the wikipages I am referencing here.</sup></p>

<p>FWIW, I am the main author of <a href="http://gcc-melt.org/" rel="nofollow">MELT</a>, a <a href="http://en.wikipedia.org/wiki/Domain_specific_language" rel="nofollow">domain specific language</a> (inspired a lot by Scheme) to extend the <a href="http://gcc.gnu.org/" rel="nofollow">GCC</a> compiler. Some of the papers / documentations I wrote might inspire you (and contain valuable references).</p>

<h3>Addenda (after question was reformulated)</h3>

<p>You seems to invent some formal syntax like </p>

<pre><code>add material 1 to layer 1
rotate layer 1 about x-axis by 90 degrees
translate layer 1 in x-axis by 10 inches
</code></pre>

<p>I can't guess what kind of language is it? Are you implementing a <a href="http://en.wikipedia.org/wiki/3D_printing" rel="nofollow">3D printer</a>? If yes, you should stick to some existing standard formal language in that domain.</p>

<p>I believe that such a COBOL-like syntax is really wrong. The point is that it is too verbose, and that you are wishing to implement some <a href="http://en.wikipedia.org/wiki/Domain_specific_language" rel="nofollow">domain specific language</a>. I find your example very bad-looking.</p>

<p>Is that syntax your invention, or is there some document specifying (and many thousands <em>already existing</em> lines coded in) your domain specific language. If you are just inventing it, please reconsider the syntax and the semantics.
First, you need to specify on paper the full syntax and semantics of your DSL.</p>

<p>Is your DSL <a href="http://en.wikipedia.org/wiki/Turing_complete" rel="nofollow">Turing complete</a>? (I guess that yes, because Turing completeness is reached very quickly - e.g. with variables and loops....). If yes, you are inventing a <a href="http://en.wikipedia.org/wiki/Scripting_language" rel="nofollow">scripting language</a>. Please don't invent scripting language without knowing several programming &amp; scripting languages (then read <a href="https://www.cs.rochester.edu/~scott/pragmatics/" rel="nofollow"><em>Programming Language Pragmatics</em></a>...). The point is that, if your scripting language will become successful, advanced users will soon or later write important programs in it (e.g. many thousand lines). Then, these advanced users will be programmers. In that case, it is very important (for social &amp; economic reasons) to have a DSL well founded and looking familiar (if possible, an extension of some <em>existing</em> scripting language).</p>

<p>If your DSL already exists, stick to its specification on paper. If that specification is not good enough, improve it with formalization (e.g. by writing some BNF syntax, and some formal (e.g. denotational) semantics for it). Publish and discuss that formalization with existing users.</p>

<p>Several industries got some ad-hoc DSLs which became widely used but was ill designed
(e.g., in the French nuclear industry, the <em>Gibiane</em> DSL designed in the 1970s by nuclear physicists, not computer scientists; the US Boeing corporation is also rumored to have made similar mistakes). Then, maintaining and improving the many hundred thousands lines of DSL scripts is becoming a nightmare (and may means losing millions of dollars or euros). So you better stick to some <em>existing</em> scripting language. The advantages are that there exist some culture on it (e.g. you can find dozens of books on Python or Lua, and many trained engineers familiar with them), that the interpreter is widely used and tested, that the community working on them is improving the interpreters, so it has quite few uncorrected bugs.</p>

<p>You should not attempt to design and implement your own DSL if you are not a trained computer scientist. Stick to some existing scripting language (of course their syntax is not like you want it to be), and leverage on existing implementations and experiment.</p>

<p>As a counter-example, <a href="http://en.wikipedia.org/wiki/John_Ousterhout" rel="nofollow">J.Ousterhout</a> has invented the widely used <a href="http://en.wikipedia.org/wiki/Tcl" rel="nofollow">Tcl</a> scripting language, with the claim that scripts are always small (e.g. hundreds of line only) and won't grow to big code base; unfortunately, some of them did, and Tcl is known as a bad language to code many dozens of thousands of lines (even if Tcl is an easy and convenient language for <em>tiny scripts</em>). The moral of the story is that if a (turing complete) scripting language is becoming successful, some "crazy" advanced user <em>will</em> code hundred of thousands of script code. So you need that scripting language to be well designed from the start. Hence, you should adopt and adapt a good <em>existing</em> scripting language (and avoid inventing an unfamiliar syntax without having a good knowledge of several existing scripting languages)</p>

<h3>later additions</h3>

<p><sup>PS: my criticism of Tcl is not entirely subjective: the point is that Tcl was <em>designed for small scripts</em> in mind (read J.Ousterhout's first papers about Tcl), but my point is that when you offer a Turing-complete scripting language, some "crazy" user will eventually write huge scripts for it. Hence, you need to anticipate such "crazy" usage by offering a scripting language which "scales up" to big scripts, so is built according to software engineering practices for large software code base.</sup></p>

<p>NB. Lua is probably a good choice as a language to embed. It is small, has a nice implementation, is well documented, and has good performance. But be careful about memory management issues (and this advice holds for any scripting language).</p>
