<p>The efficiency of your current code depends on the implementation of <code>g.get_shortest_paths</code>. Typically choices of <code>g.get_shortest_paths</code> include:</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm" rel="nofollow">BellmanâFord algorithm</a>, which shall run at <code>O(VE)</code>, </li>
<li><a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" rel="nofollow">Dijkstra's algorithm</a>, which shall run at <code>O(V^2)</code> without optimization, <code>O(Elog(v))</code> or even <code>O(E+Vlog(E/V)log(V))</code> if well-optimized.</li>
</ul>

<p>And the time cost of your code shall be the cost of <code>g.get_shortest_paths</code> times <code>O(V^2)</code> since the iteration.</p>

<p>For all-pairs-shortest-path problem in your case, <a href="http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm" rel="nofollow">FloydâWarshall algorithm</a> is suggested which uses dynamic programming to reach a time cost of <code>O(V^3)</code></p>

<p><strong>EDITED:</strong></p>

<p>Notations used above: <code>E</code> for number of edges, and <code>V</code> for number of vertices in the graph.</p>
