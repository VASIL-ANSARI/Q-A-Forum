<blockquote>
  <p>So, where I'm wrong? Why it's compiling?</p>
</blockquote>

<p>It is compiling because your compiler is too permissive, and your compiler is too permissive because in C++03 the implicit conversion from a string literal to <code>char*</code> was only <em>deprecated</em>, not invalid. </p>

<p>The rationale was backward compatibility with legacy C APIs. Per paragraph 4.2/2 of the C++03 Standard:</p>

<blockquote>
  <p>A string literal (2.13.4) that is not a wide string literal can be converted to an rvalue of type âpointer to
  <code>char</code>â; a wide string literal can be converted to an rvalue of type âpointer to <code>wchar_t</code>â. In either case,
  the result is a pointer to the first element of the array. This conversion is considered only when there is an
  explicit appropriate pointer target type, and not when there is a general need to convert from an lvalue to an
  rvalue. [<strong><em>Note</em>: this conversion is deprecated. See Annex D.</strong>]</p>
</blockquote>

<p>In C++11, however, the implicit conversion is illegal (the above paragraph has been removed altogether).</p>

<blockquote>
  <p>Can I legally dereference-and-modify the pointer inside the constructor?!</p>
</blockquote>

<p>You can, but you cannot modify the dereferenced object. Doing so would be undefined behavior, since the type of the object is <code>const</code>-qualified.</p>
