<p>Since each case is computed by a trivial comparison, you can just as well do all comparisons either way.</p>

<p>So here's a suggestion:</p>

<pre><code>boolean[] aSol = { primary &gt; 10000, primary &gt; 20000, secondary &gt; 30000 };
boolean[] bSol = { primary &gt; 40000, primary &gt; 50000, secondary &gt; 60000 };
boolean[] cSol = { primary &gt; 70000, primary &gt; 80000, secondary &gt; 90000 };

level = Math.min(level, 2);
return group.equals("A") ? aSol[level] :
       group.equals("B") ? bSol[level] :
       group.equals("C") ? cSol[level] :
       false;
</code></pre>

<p>I think it's fairly readable and maintainable.</p>

<p>Here's another slightly different formulation:</p>

<pre><code>boolean[][] result = {
        { primary &gt; 10000, primary &gt; 20000, secondary &gt; 30000 },
        { primary &gt; 40000, primary &gt; 50000, secondary &gt; 60000 },
        { primary &gt; 70000, primary &gt; 80000, secondary &gt; 90000 } };

int groupId = Arrays.asList("A", "B", "C").indexOf(group);

if (groupId == -1)
    return false;

boolean[] groupResult = result[groupId];
return groupResult[Math.min(level, groupResult.length-1)];
</code></pre>

<p>Another option is to create an interface with a method</p>

<pre><code>makeDecision(int level, int primaryAmount, int secondaryAmount)
</code></pre>

<p>and then populate a <code>Map&lt;String, GroupDecision&gt;</code> with decision procedures,</p>

<pre><code>groupMap.put("A", new GroupDecision() { ... });
groupMap.put("B", new GroupDecision() { ... });
groupMap.put("C", new GroupDecision() { ... });
</code></pre>

<p>and then call</p>

<pre><code>return groupMap.get(group).makeDecision(level, primaryAmount, secondaryAmount);
</code></pre>

<p>This approach is probably the most extendible and readable approach.</p>
