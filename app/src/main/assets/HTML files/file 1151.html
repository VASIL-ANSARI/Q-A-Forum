<p>I think a better question is why should it? After all:</p>

<pre><code>MyObject foo;
foo.DoBar();
</code></pre>

<p>Is hardly any more difficult. It's more readable too (though obviously that may be biased.) Even if you could construct-call, it would likely be tagged as a "bad thing" to do. Sort of how like multiple declarations on the same line are allowed, but often decrease readability.</p>

<p>Such a construct adds rules and complexity to an already complex language, when an arguably preferable solution is already present. Do we really want to add costly sugar to a language just to save a few keystrokes?</p>

<p>In response to:</p>

<blockquote>
  <p>"I could see it being useful though when you want to construct an object and just call one function on it. "</p>
</blockquote>

<p>If you want to construct an object just to call a function, would it be possible to just make that function a free-function? After all, it's operating either on default data or data that was passed to the constructor anyway. The only thing missing would be the destructor.</p>

<p>Not to mention the other option:</p>

<pre><code>struct MyObject
{
    MyObject(bool pCallDoBar = true)
    {
        if (pCallDoBar)
            DoBar();
    }

    void DoBar(void)
    {
    }
};

MyObject foo;
</code></pre>

<p>Or just:</p>

<pre><code>MyObject().DoBar(); // destructor called here, though
</code></pre>

<p>I think you'd need a concrete example to really make a case.</p>
