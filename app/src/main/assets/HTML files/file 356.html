<p>The flow you are seeing is something like this:</p>

<ol>
<li>Click on button</li>
<li>AnimationExtender catches action and call clickOn callback</li>
<li>linkPostback starts asynchronous request for page and then returns flow to AnimationExtender</li>
<li>Animation begins</li>
<li>pageRequest returns and calls playAnimation, which starts the animation again</li>
</ol>

<p>I think there are at least two ways around this issue.  It seems you have almost all the javascript you need, you just need to work around AnimationExtender starting the animation on a click.</p>

<p>Option 1: Hide the AnimationExtender button and add a new button of your own that plays the animation.  This should be as simple as setting the AE button's style to "display: none;" and having your own button call linkPostback().</p>

<p>Option 2: Re-disable the Animation Extender once the animation has finished with.  This should work, as long as the playAnimation call is blocking, which it probably is:</p>

<pre><code>function linkPostback() {

    var prm = Sys.WebForms.PageRequestManager.getInstance();
    prm.add_endRequest(playAnimation)
}

function playAnimation() {

    AnimationExtender.Enabled = true;
    var onclkBehavior = $find("ctl00_btnOpenList").get_OnClickBehavior().get_animation();
    onclkBehavior.play();
    AnimationExtender.Enabled = false;
}
</code></pre>

<p>As an aside, it seems your general approach may face issues if there is a delay in receiving the pageRequest.  It may be a bit weird to click a button and several seconds later have the animation happen.  It may be better to either pre-load the data, or to pre-fill the div with some "Loading..." thing, make it about the right size, and then populate the actual contents when it arrives.</p>
