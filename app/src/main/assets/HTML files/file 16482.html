<p>In this line:</p>

<pre><code>a[j]=k+b[j];
</code></pre>

<p>You use <code>j</code> but it is unitialized so it's some huge value and you are outside of the array bounds and thus you get a segmentation fault.</p>

<p>You also have some weird things going on in your code. <code>void main()</code> and you use <code>cout</code> without either saying <code>std::cout</code> or <code>using namespace std;</code> or something similar. An odd practice.</p>

<p>Also don't you think you should pass the arrays as arguments if you're going to make <code>lcm()</code> a function? That is <code>int lcm(int a[], int b[]);</code>.</p>

<p>You might look into using a debugger also and improving your coding practices. I found this error within 30 seconds of pasting your code into the compiler with the help of the debugger.</p>

<p>Your loop condition is:</p>

<pre><code>while(n==1&amp;&amp;i&lt;20)
</code></pre>

<p>So your <code>equl</code> function will never return 1 because if n happens to be 1 then the loop will just keep going and never return a 1.
However, your program still does not appear to return the correct result. You can split the piece of your code that finds the minimum element and replace it with this for cleanliness:</p>

<pre><code>int least(int a[], int size){
    int minPos = 0;

    for(int i=0; i&lt;size ;i++){

        if (a[i] &lt; a[minPos] ){
            minPos = i;
        }
    }

    return minPos;
}
</code></pre>

<p>Then you can call it by saying <code>j = least(a, 20);</code>. I will leave further work on your program to you. Consider calling your variables something meaningful instead of <code>i,j,k,a,b</code>.</p>
