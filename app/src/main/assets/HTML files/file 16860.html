<p>I got a very similar problem today and solved it with the replacing the Root Controller - I create new view controller and assign it to the root view controller of the app window. This new controller supports only Landscape. The original root controller supports both modes. 
So instead of of [self addChild... I rotate the device and replace the root view controller.</p>

<pre><code>UIInterfaceOrientation current = [[UIDevice currentDevice] orientation];
if ( UIInterfaceOrientationIsPortrait(current)) {
    [UIView beginAnimations:@"InterfaceOrientation" context:nil];
    [UIView setAnimationDuration:[application statusBarOrientationAnimationDuration]];
    [[[application delegate] window] setRootViewController:controller];
    [UIView commitAnimations];
    [application setStatusBarOrientation:UIInterfaceOrientationLandscapeRight animated:YES];
}
else {
    [[[application delegate] window] setRootViewController:controller];
}
</code></pre>

<p>There are three methods in the controller that I didn't use before iOS 6 and you didn't mention in your question:
viewWillLayoutSubviews, willRotateToInterfaceOrientation and didRotateFromInterfaceOrientation. For example, in willRotateToInterfaceOrientation I save the current orientation, in viewWillLayoutSubviews I re-arrange all subviews.</p>

<p>If you create a child view controller. it uses the parent view controller settings about the device orientation - I think so. </p>

<p>I'll be glad to understand the situation better and find a better solution.</p>
