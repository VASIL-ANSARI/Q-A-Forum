<p>The <code>x</code>/<code>y</code> parameter of <code>drawOval</code> is the top/left corner from where the oval will be drawn</p>

<p>In order to be able to draw the circle around the center point if <code>230x300</code>, you will need to subtract the radius from each point and then generate a width and height (diameter) of double that...</p>

<pre><code>g.drawOval(230 - radius, 300 - radius, radius * 2, radius * 2);
</code></pre>

<p>So, this example basic draws a rectangle around the point of <code>230x300</code> with a width/height of <code>200</code> (radius = 100) and draws lines through this point to illustrate the center point the oval then drawn about...</p>

<p><img src="http://i.stack.imgur.com/aUPgA.png" alt="Oval"></p>

<pre><code>import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Graphics;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;

public class TryoutOval {

    public static void main(String[] args) {
        new TryoutOval();
    }

    public TryoutOval() {
        EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                try {
                    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
                } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException ex) {
                }

                JFrame frame = new JFrame("Testing");
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                frame.setLayout(new BorderLayout());
                frame.add(new TryoutPanel(Color.RED));
                frame.pack();
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
            }
        });
    }

    public class TryoutPanel extends JPanel {

        private Color myColor;

        public TryoutPanel(Color c) {
            myColor = c;
        }

        @Override
        public Dimension getPreferredSize() {
            return new Dimension(400, 400);
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);

            int centerX = 280;
            int centerY = 300;

            int radius = 50;
            int diameter = radius * 2;

            int x = centerX - radius;
            int y = centerY - radius;

            g.setColor(Color.BLACK);
            g.drawRect(x, y, diameter, diameter);
            g.drawLine(x, y, x + diameter, y + diameter);
            g.drawLine(x + diameter, y, x, y + diameter);

            g.setColor(myColor);
            g.drawOval(x, y, diameter, diameter);

            g.fillOval(centerX - 5, centerY - 5, 10, 10);

        }
    }

}
</code></pre>

<p>Oh, and <code>setForeground(myColor);</code> is a horribly bad idea within any <code>paint</code> method as it will cause a <code>paint</code> event to be added to the event queue each time the method is called, which will cause a never ending repaint request which will eventually consume your CPU</p>
