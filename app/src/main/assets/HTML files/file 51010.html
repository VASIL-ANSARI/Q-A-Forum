<p>If you want to chain them one after the other, you'd have to do this:</p>

<pre><code>var $deferred;
$(someArray).each(function (index) {
    if (!$deferred) {
        $deferred = someFunction(index);
    } else {
        $deferred = $deferred.then(function () {
            return someFunction(index);
        });
    }
});
</code></pre>

<p>What you were doing is putting all the <code>.then()</code> handlers on the same deferred which will run them all in parallel, not serially.   What you need is the equivalent of p.then(...).then(...).then(...).  Since each <code>.then()</code> returns a new promise, you need to chain to the next link in the chain.</p>

<hr>

<p>You may find this design pattern a little simpler for iterating through an array sequentially with an async operation that generates a promise:</p>

<pre><code>someArray.reduce(function(p, item) {
    return p.then(function() {
        return someFunction(item);
    });
}, $.Deferred().resolve()).then(function() {
    // all done here
});
</code></pre>

<p>Working demo: <a href="http://jsfiddle.net/jfriend00/uusjs3mt/" rel="nofollow">http://jsfiddle.net/jfriend00/uusjs3mt/</a></p>
