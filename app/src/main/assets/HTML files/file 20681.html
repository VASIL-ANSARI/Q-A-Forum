<p>The misunderstanding is here:</p>

<blockquote>
  <p><code>*this</code> means its passing the address of whatever object is being cloned</p>
</blockquote>

<p>In reality, <code>this</code> is the address of the object that is being cloned, but <code>*this</code> (note the asterisk) is the result of <em>dereferencing</em> that address. So <code>*this</code> is of type <code>Derived &amp;</code>, it's a reference to the object being cloned, not its address.</p>

<p>Therefore, calling <code>new Derived(*this)</code> means that after dynamically allocating space (which is what <code>new</code> does), the new space is initialised by the copy constructor <code>Derived(const Derived &amp;)</code>, which in this case hasn't actually been user-defined, so the (compiler-generated) default version of the copy constructor is used.</p>

<hr>

<p>To clarify the semantics of <code>new</code>: If <code>C</code> is a class, then</p>

<pre><code>new C;
</code></pre>

<p>allocates enough space for an object of type <code>C</code> and then calls the constructor of <code>C</code> to initialise that space. This is part of the semantics of <code>new</code>: It always calls the constructor to initialise the newly allocated space.</p>

<p>When you call</p>

<pre><code>new C(a,b,c);
</code></pre>

<p>with some arguments <code>a</code>, <code>b</code> and <code>c</code>, then <code>new</code> will call a constructor of <code>C</code> that takes these three arguments. If no such constructor has been defined, you'll get a compiler error.</p>

<p>Now in the special case where you call</p>

<pre><code>new C(a);
</code></pre>

<p>with an argument <code>a</code> that is itself of type <code>C&amp;</code>, <code>new</code> will, as always, call the appropriate constructor. The appropriate constructor is either <code>C(C &amp;)</code> (if defined), or <code>C(const C&amp;)</code> (copy-constructor auto-defined by the compiler).</p>
