<p>Quick google results:<br>
Taken from: <a href="http://www.glennslayden.com/code/c-sharp/trie" rel="nofollow">Trie Generic</a><br>
By Glenn Slayden<br>
attributed to Kerry D. Wong</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

public class Trie&lt;TValue&gt; : System.Collections.IEnumerable, IEnumerable&lt;Trie&lt;TValue&gt;.TrieNodeBase&gt;
{
    public abstract class TrieNodeBase
    {
        protected TValue m_value = default(TValue);

        public TValue Value
        {
            get { return m_value; }
            set { m_value = value; }
        }

        public bool HasValue { get { return !Object.Equals(m_value, default(TValue)); } }
        public abstract bool IsLeaf { get; }

        public abstract TrieNodeBase this[char c] { get; }

        public abstract TrieNodeBase[] Nodes { get; }

        public abstract void SetLeaf();

        public abstract int ChildCount { get; }

        public abstract bool ShouldOptimize { get; }

        public abstract KeyValuePair&lt;Char, TrieNodeBase&gt;[] CharNodePairs();

        public abstract TrieNodeBase AddChild(char c, ref int node_count);

        /// &lt;summary&gt;
        /// Includes current node value
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public IEnumerable&lt;TValue&gt; SubsumedValues()
        {
            if (Value != null)
                yield return Value;
            if (Nodes != null)
                foreach (TrieNodeBase child in Nodes)
                    if (child != null)
                        foreach (TValue t in child.SubsumedValues())
                            yield return t;
        }

        /// &lt;summary&gt;
        /// Includes current node
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public IEnumerable&lt;TrieNodeBase&gt; SubsumedNodes()
        {
            yield return this;
            if (Nodes != null)
                foreach (TrieNodeBase child in Nodes)
                    if (child != null)
                        foreach (TrieNodeBase n in child.SubsumedNodes())
                            yield return n;
        }

        /// &lt;summary&gt;
        /// Doesn't include current node
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public IEnumerable&lt;TrieNodeBase&gt; SubsumedNodesExceptThis()
        {
            if (Nodes != null)
                foreach (TrieNodeBase child in Nodes)
                    if (child != null)
                        foreach (TrieNodeBase n in child.SubsumedNodes())
                            yield return n;
        }

        /// &lt;summary&gt;
        /// Note: doesn't de-optimize optimized nodes if re-run later
        /// &lt;/summary&gt;
        public void OptimizeChildNodes()
        {
            if (Nodes != null)
                foreach (var q in CharNodePairs())
                {
                    TrieNodeBase n_old = q.Value;
                    if (n_old.ShouldOptimize)
                    {
                        TrieNodeBase n_new = new SparseTrieNode(n_old.CharNodePairs());
                        n_new.m_value = n_old.m_value;
                        Trie&lt;TValue&gt;.c_sparse_nodes++;
                        ReplaceChild(q.Key, n_new);
                    }
                    n_old.OptimizeChildNodes();
                }
        }

        public abstract void ReplaceChild(Char c, TrieNodeBase n);

    };

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ///
    /// Sparse Trie Node
    ///
    /// currently, this one's "nodes" value is never null, because we leave leaf nodes as the non-sparse type,
    /// (with nodes==null) and they currently never get converted back. Consequently, IsLeaf should always be 'false'.
    /// However, we're gonna do the check anyway.
    /// 
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public class SparseTrieNode : TrieNodeBase
    {
        Dictionary&lt;Char, TrieNodeBase&gt; d;

        public SparseTrieNode(IEnumerable&lt;KeyValuePair&lt;Char, TrieNodeBase&gt;&gt; ie)
        {
            d = new Dictionary&lt;char, TrieNodeBase&gt;();
            foreach (var kvp in ie)
                d.Add(kvp.Key, kvp.Value);
        }

        public override TrieNodeBase this[Char c]
        {
            get
            {
                TrieNodeBase node;
                return d.TryGetValue(c, out node) ? node : null;
            }
        }

        public override TrieNodeBase[] Nodes { get { return d.Values.ToArray(); } }

        /// &lt;summary&gt;
        /// do not use in current form. This means, run OptimizeSparseNodes *after* any pruning
        /// &lt;/summary&gt;
        public override void SetLeaf() { d = null; }

        public override int ChildCount { get { return d.Count; } }

        public override KeyValuePair&lt;Char, TrieNodeBase&gt;[] CharNodePairs()
        {
            return d.ToArray();
        }

        public override TrieNodeBase AddChild(char c, ref int node_count)
        {
            TrieNodeBase node;
            if (!d.TryGetValue(c, out node))
            {
                node = new TrieNode();
                node_count++;
                d.Add(c, node);
            }
            return node;
        }

        public override void ReplaceChild(Char c, TrieNodeBase n)
        {
            d[c] = n;
        }

        public override bool ShouldOptimize { get { return false; } }
        public override bool IsLeaf { get { return d == null; } }

    };

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ///
    /// Non-sparse Trie Node
    ///
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public class TrieNode : TrieNodeBase
    {
        private TrieNodeBase[] nodes = null;
        private Char m_base;

        public override int ChildCount { get { return (nodes != null) ? nodes.Count(e =&gt; e != null) : 0; } }
        public int AllocatedChildCount { get { return (nodes != null) ? nodes.Length : 0; } }

        public override TrieNodeBase[] Nodes { get { return nodes; } }

        public override void SetLeaf() { nodes = null; }

        public override KeyValuePair&lt;Char, TrieNodeBase&gt;[] CharNodePairs()
        {
            KeyValuePair&lt;Char, TrieNodeBase&gt;[] rg = new KeyValuePair&lt;char, TrieNodeBase&gt;[ChildCount];
            Char ch = m_base;
            int i = 0;
            foreach (TrieNodeBase child in nodes)
            {
                if (child != null)
                    rg[i++] = new KeyValuePair&lt;char, TrieNodeBase&gt;(ch, child);
                ch++;
            }
            return rg;
        }

        public override TrieNodeBase this[char c]
        {
            get
            {
                if (nodes != null &amp;&amp; m_base &lt;= c &amp;&amp; c &lt; m_base + nodes.Length)
                    return nodes[c - m_base];
                return null;
            }
        }

        public override TrieNodeBase AddChild(char c, ref int node_count)
        {
            if (nodes == null)
            {
                m_base = c;
                nodes = new TrieNodeBase[1];
            }
            else if (c &gt;= m_base + nodes.Length)
            {
                Array.Resize(ref nodes, c - m_base + 1);
            }
            else if (c &lt; m_base)
            {
                Char c_new = (Char)(m_base - c);
                TrieNodeBase[] tmp = new TrieNodeBase[nodes.Length + c_new];
                nodes.CopyTo(tmp, c_new);
                m_base = c;
                nodes = tmp;
            }

            TrieNodeBase node = nodes[c - m_base];
            if (node == null)
            {
                node = new TrieNode();
                node_count++;
                nodes[c - m_base] = node;
            }
            return node;
        }

        public override void ReplaceChild(Char c, TrieNodeBase n)
        {
            if (nodes == null || c &gt;= m_base + nodes.Length || c &lt; m_base)
                throw new Exception();
            nodes[c - m_base] = n;
        }

        public override bool ShouldOptimize
        {
            get
            {
                if (nodes == null)
                    return false;
                return (ChildCount * 9 &lt; nodes.Length);     // empirically determined optimal value (space &amp; time)
            }
        }

        public override bool IsLeaf { get { return nodes == null; } }
    };

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// 
    /// Trie proper begins here
    ///
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    private TrieNodeBase _root = new TrieNode();
    public int c_nodes = 0;
    public static int c_sparse_nodes = 0;

    // in combination with Add(...), enables C# 3.0 initialization syntax, even though it never seems to call it
    public System.Collections.IEnumerator GetEnumerator()
    {
        return _root.SubsumedNodes().GetEnumerator();
    }

    IEnumerator&lt;TrieNodeBase&gt; IEnumerable&lt;TrieNodeBase&gt;.GetEnumerator()
    {
        return _root.SubsumedNodes().GetEnumerator();
    }

    public IEnumerable&lt;TValue&gt; Values { get { return _root.SubsumedValues(); } }

    public void OptimizeSparseNodes()
    {
        if (_root.ShouldOptimize)
        {
            _root = new SparseTrieNode(_root.CharNodePairs());
            c_sparse_nodes++;
        }
        _root.OptimizeChildNodes();
    }

    public TrieNodeBase Root { get { return _root; } }

    public TrieNodeBase Add(String s, TValue v)
    {
        TrieNodeBase node = _root;
        foreach (Char c in s)
            node = node.AddChild(c,ref c_nodes);

        node.Value = v;
        return node;
    }

    public bool Contains(String s)
    {
        TrieNodeBase node = _root;
        foreach (Char c in s)
        {
            node = node[c];
            if (node == null)
                return false;
        }
        return node.HasValue;
    }

    /// &lt;summary&gt;
    /// Debug only; this is hideously inefficient
    /// &lt;/summary&gt;
    public String GetKey(TrieNodeBase seek)
    {
        String sofar = String.Empty;

        GetKeyHelper fn = null;
        fn = (TrieNodeBase cur) =&gt;
        {
            sofar += " ";   // placeholder
            foreach (var kvp in cur.CharNodePairs())
            {
                Util.SetStringChar(ref sofar, sofar.Length - 1, kvp.Key);
                if (kvp.Value == seek)
                    return true;
                if (kvp.Value.Nodes != null &amp;&amp; fn(kvp.Value))
                    return true;
            }
            sofar = sofar.Substring(0, sofar.Length - 1);
            return false;
        };

        if (fn(_root))
            return sofar;
        return null;
    }


    /// &lt;summary&gt;
    /// Debug only; this is hideously inefficient
    /// &lt;/summary&gt;
    delegate bool GetKeyHelper(TrieNodeBase cur);
    public String GetKey(TValue seek)
    {
        String sofar = String.Empty;

        GetKeyHelper fn = null;
        fn = (TrieNodeBase cur) =&gt;
             {
                 sofar += " ";  // placeholder
                 foreach (var kvp in cur.CharNodePairs())
                 {
                     Util.SetStringChar(ref sofar, sofar.Length - 1, kvp.Key);
                     if (kvp.Value.Value != null &amp;&amp; kvp.Value.Value.Equals(seek))
                         return true;
                     if (kvp.Value.Nodes != null &amp;&amp; fn(kvp.Value))
                         return true;
                 }
                 sofar = sofar.Substring(0, sofar.Length - 1);
                 return false;
             };

        if (fn(_root))
            return sofar;
        return null;
    }

    public TrieNodeBase FindNode(String s_in)
    {
        TrieNodeBase node = _root;
        foreach (Char c in s_in)
            if ((node = node[c]) == null)
                return null;
        return node;
    }

    /// &lt;summary&gt;
    /// If continuation from the terminal node is possible with a different input string, then that node is not
    /// returned as a 'last' node for the given input. In other words, 'last' nodes must be leaf nodes, where
    /// continuation possibility is truly unknown. The presense of a nodes array that we couldn't match to 
    /// means the search fails; it is not the design of the 'OrLast' feature to provide 'closest' or 'best'
    /// matching but rather to enable truncated tails still in the context of exact prefix matching.
    /// &lt;/summary&gt;
    public TrieNodeBase FindNodeOrLast(String s_in, out bool f_exact)
    {
        TrieNodeBase node = _root;
        foreach (Char c in s_in)
        {
            if (node.IsLeaf)
            {
                f_exact = false;
                return node;
            }
            if ((node = node[c]) == null)
            {
                f_exact = false;
                return null;
            }
        }
        f_exact = true;
        return node;
    }

    // even though I found some articles that attest that using a foreach enumerator with arrays (and Lists)
    // returns a value type, thus avoiding spurious garbage, I had already changed the code to not use enumerator.
    public unsafe TValue Find(String s_in)
    {
        TrieNodeBase node = _root;
        fixed (Char* pin_s = s_in)
        {
            Char* p = pin_s;
            Char* p_end = p + s_in.Length;
            while (p &lt; p_end)
            {
                if ((node = node[*p]) == null)
                    return default(TValue);
                p++;
            }
            return node.Value;
        }
    }

    public unsafe TValue Find(Char* p_tag, int cb_ctag)
    {
        TrieNodeBase node = _root;
        Char* p_end = p_tag + cb_ctag;
        while (p_tag &lt; p_end)
        {
            if ((node = node[*p_tag]) == null)
                return default(TValue);
            p_tag++;
        }
        return node.Value;
    }

    public IEnumerable&lt;TValue&gt; FindAll(String s_in)
    {
        TrieNodeBase node = _root;
        foreach (Char c in s_in)
        {
            if ((node = node[c]) == null)
                break;
            if (node.Value != null)
                yield return node.Value;
        }
    }

    public IEnumerable&lt;TValue&gt; SubsumedValues(String s)
    {
        TrieNodeBase node = FindNode(s);
        if (node == null)
            return Enumerable.Empty&lt;TValue&gt;();
        return node.SubsumedValues();
    }

    public IEnumerable&lt;TrieNodeBase&gt; SubsumedNodes(String s)
    {
        TrieNodeBase node = FindNode(s);
        if (node == null)
            return Enumerable.Empty&lt;TrieNodeBase&gt;();
        return node.SubsumedNodes();
    }

    public IEnumerable&lt;TValue&gt; AllSubstringValues(String s)
    {
        int i_cur = 0;
        while (i_cur &lt; s.Length)
        {
            TrieNodeBase node = _root;
            int i = i_cur;
            while (i &lt; s.Length)
            {
                node = node[s[i]];
                if (node == null)
                    break;
                if (node.Value != null)
                    yield return node.Value;
                i++;
            }
            i_cur++;
        }
    }

    /// &lt;summary&gt;
    /// note: only returns nodes with non-null values
    /// &lt;/summary&gt;
    public void DepthFirstTraverse(Action&lt;String,TrieNodeBase&gt; callback)
    {
        Char[] rgch = new Char[100];
        int depth = 0;

        Action&lt;TrieNodeBase&gt; fn = null;
        fn = (TrieNodeBase cur) =&gt;
        {
            if (depth &gt;= rgch.Length)
            {
                Char[] tmp = new Char[rgch.Length * 2];
                Buffer.BlockCopy(rgch, 0, tmp, 0, rgch.Length * sizeof(Char));
                rgch = tmp;
            }
            foreach (var kvp in cur.CharNodePairs())
            {
                rgch[depth] = kvp.Key;
                TrieNodeBase n = kvp.Value;
                if (n.Nodes != null)
                {
                    depth++;
                    fn(n);
                    depth--;
                }
                else if (n.Value == null)       // leaf nodes should always have a value
                    throw new Exception();

                if (n.Value != null)
                    callback(new String(rgch, 0, depth+1), n);
            }
        };

        fn(_root);
    }


    /// &lt;summary&gt;
    /// note: only returns nodes with non-null values
    /// &lt;/summary&gt;
    public void EnumerateLeafPaths(Action&lt;String,IEnumerable&lt;TrieNodeBase&gt;&gt; callback)
    {
        Stack&lt;TrieNodeBase&gt; stk = new Stack&lt;TrieNodeBase&gt;();
        Char[] rgch = new Char[100];

        Action&lt;TrieNodeBase&gt; fn = null;
        fn = (TrieNodeBase cur) =&gt;
        {
            if (stk.Count &gt;= rgch.Length)
            {
                Char[] tmp = new Char[rgch.Length * 2];
                Buffer.BlockCopy(rgch, 0, tmp, 0, rgch.Length * sizeof(Char));
                rgch = tmp;
            }
            foreach (var kvp in cur.CharNodePairs())
            {
                rgch[stk.Count] = kvp.Key;
                TrieNodeBase n = kvp.Value;
                stk.Push(n);
                if (n.Nodes != null)
                    fn(n);
                else
                {
                    if (n.Value == null)        // leaf nodes should always have a value
                        throw new Exception();
                    callback(new String(rgch, 0, stk.Count), stk);
                }
                stk.Pop();
            }
        };

        fn(_root);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ///
    /// Convert a trie with one value type to another
    ///
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public Trie&lt;TNew&gt; ToTrie&lt;TNew&gt;(Func&lt;TValue, TNew&gt; value_converter)
    {
        Trie&lt;TNew&gt; t = new Trie&lt;TNew&gt;();
        DepthFirstTraverse((s,n)=&gt;{
            t.Add(s,value_converter(n.Value));
        });
        return t;
    }
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///
///
///
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public static class TrieExtension
{
    public static Trie&lt;TValue&gt; ToTrie&lt;TValue&gt;(this IEnumerable&lt;String&gt; src, Func&lt;String, int, TValue&gt; selector)
    {
        Trie&lt;TValue&gt; t = new Trie&lt;TValue&gt;();
        int idx = 0;
        foreach (String s in src)
            t.Add(s,selector(s,idx++));
        return t;
    }

    public static Trie&lt;TValue&gt; ToTrie&lt;TValue&gt;(this Dictionary&lt;String, TValue&gt; src)
    {
        Trie&lt;TValue&gt; t = new Trie&lt;TValue&gt;();
        foreach (var kvp in src)
            t.Add(kvp.Key, kvp.Value);
        return t;
    }

    public static IEnumerable&lt;TValue&gt; AllSubstringValues&lt;TValue&gt;(this String s, Trie&lt;TValue&gt; trie)
    {
        return trie.AllSubstringValues(s);
    }

    public static void AddToValueHashset&lt;TKey, TValue&gt;(this Dictionary&lt;TKey, HashSet&lt;TValue&gt;&gt; d, TKey k, TValue v)
    {
        HashSet&lt;TValue&gt; hs;
        if (d.TryGetValue(k, out hs))
            hs.Add(v);
        else
            d.Add(k, new HashSet&lt;TValue&gt; { v });
    }
};
</code></pre>
