<p>What you see here is a difference in the initialization rules for cstring in C and C++.  In C11 Â§6.7.9/14 we have</p>

<blockquote>
  <p>An array of character type may be initialized by a character string literal or UTFâ8 string literal, optionally enclosed in braces. Successive bytes of the string literal (<strong>including the terminating null character if there is room</strong> or if the array is of unknown size) initialize the elements of the array.</p>
</blockquote>

<p><sup>emphasis mine</sup></p>

<p>So as long as the array is large enough for the string excluding the null terminator it is valid.  So </p>

<pre><code>char  str[3]="abc";
</code></pre>

<p>Is valid C.  In C++14 however the rule that governs this found in [dcl.init.string]/2 states</p>

<blockquote>
  <p>There shall not be more initializers than there are array elements.</p>
</blockquote>

<p>And goes on to show that the following code is an error</p>

<pre><code>char cv[4] = "asdf"; // error
</code></pre>

<p>So in C++ you have to have enough storage for the entire string literal including the null terminator.</p>
