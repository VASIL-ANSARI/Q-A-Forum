<p>Using an interface this way gives you the ability to create methods that use standard template of the interface. So here you might have many classes of printer that all inherit from <code>IPrinter</code></p>

<pre><code>class SamsungPrinter : IPrinter
{
    // Stuff and interface members.
}

class SonyPrinter : IPrinter
{
    // Stuff and interface members.
}

interface IPrinter
{
    void Print();
}
</code></pre>

<p>So for each type <code>SamsungPrinter</code>, <code>SonyPrinter</code>, etc. you can pre-process using something like </p>

<pre><code>public static void PreProcessAndPrint(IPrinter printer)
{
    // Do pre-processing or something.
    printer.Print();
}
</code></pre>

<p>You know from inheriting from <code>IPrinter</code> and using that type in the method parameters that you can always safely use the <code>Print</code> method on what ever object is passed.</p>

<p>Of course there are many other uses for using interfaces. One example of their use is in design patterns, in particular the Factory and Strategy patterns. The description of which and examples can be found <a href="http://www.dofactory.com/Patterns/Patterns.aspx">here</a>.</p>

<p>I hope this helps.</p>
