<p>You don't need to change how the <code>form</code> submits, in this case, for validating the captcha, use <code>remote</code> function from <code>jquery.validate</code>.</p>

<p>There are some problems around the <code>remote</code> usage with <code>jquery.validate</code>. Check if you did the following:</p>

<p><strong>1)</strong> Make sure you are using <em>jQuery</em> version <strong>1.6.1</strong> and above only.</p>

<p><strong>2)</strong> Use the "synchronous" option for remote execution (default being asynchronous) and to do this set <code>async</code> argument to false.</p>

<hr>

<h2>Example of usage:</h2>

<p>Suppose this is my form...</p>

<p><em><strong>HTML:</em></strong></p>

<p>Add <code>id</code> and <code>name</code> attributes to all the form elements or just the captcha <em>(this one must have both).</em></p>

<pre><code>&lt;form id="signin_form" action="save.php" method="POST"&gt;
  Enter captcha: O1S2C3A4R
  &lt;br/&gt;
  &lt;input type="text" id="captcha" name="captcha" value=""/&gt;
  &lt;input type="submit" id="save" name="save" value="Save"/&gt;
&lt;/form&gt;
</code></pre>

<p><em><strong>jQuery:</em></strong></p>

<p>Add <code>type</code>, <code>async</code> and <code>data</code> arguments. This last argument passes the captcha value to <strong>check.php</strong> file and that's why that element needs the <code>id</code> attribute. Then you are able to use this selector <code>$('#captcha')</code>.</p>

<p><em>(For me this is better but you can also call the element by name using other selector type)</em></p>

<p>Just to know, you need to also define an error message for the <code>remote</code>, in this case I used <em>Invalid captcha</em>.</p>

<pre><code>$(document).ready(function(){

    $("#signin_form").validate({
        rules: {
            captcha: {
                required: true,
                remote: { 
                    url:"check.php",
                    type:"post",
                    async:false,
                    data: {
                        /* this is the name of the post parameter that PHP will use: $_POST['captcha'] */
                        captcha: function() {
                            return $.trim($("#captcha").val());
                        }
                    }
                }
            }
        },
        messages: {
            captcha: {
                required: "*",
                remote: "Invalid captcha"
            }
        }
    });

});
</code></pre>

<p><em><strong>PHP: check.php</em></strong></p>

<p>At this point it is important to use <code>"true"</code> or <code>"false"</code> as <strong><em>string</em></strong> to let know the <code>jquery.validation</code> plugin if the captcha is valid or not. In this case, if captcha is equals to <strong><em>O1S2C3A4R</em></strong> then is valid and, at client side, you will look that the <code>submit</code> will process the <code>form</code> to <code>save.php</code> file specified in the html <code>form</code> <code>action</code> attribute.</p>

<pre><code>&lt;?php

    $captcha = $_POST['captcha'];

    if($captcha == "O1S2C3A4R"){
        echo "true";
    } else {
        echo "false";
    }

?&gt;
</code></pre>

<hr>

<p>Doing this way, you can validate the whole <code>form</code> without problems and also check the captcha value remotely without altering plugin functionality.</p>

<p>Also you can test all this code together and look that it works :-)</p>

<p>Hope this helps.</p>
