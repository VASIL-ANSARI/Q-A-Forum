<p>As others have mentioned, Python's closures are <em>late binding</em>, which means that variables from an outside scope referenced in a closure (in other words, the variables <em>closed over</em>) are looked up at the moment the closure is called and <em>not</em> at the time of definition.</p>

<p>In your example, the closure in question is formed when your lambda references the variable <code>i</code> from the outside scope. However, when your lambda is called later on, the loop has already finished and left the variable <code>i</code> with the value 19.</p>

<p>An easy but not particularly elegant fix is to use a default argument for the lambda:</p>

<pre><code>for i in range(20):
    funct_list.append(lambda x=i: test(x, "Hello World"))
</code></pre>

<p>Unlike closure variables, default arguments are bound early and therefore achieve the desired effect of capturing the value of the variable <code>i</code> at the time of lambda definition.</p>

<p>A better way is use <code>functools.partial</code> which allows you to partially apply some arguments of the function, "fixing" them to a certain value:</p>

<pre><code>from functools import partial

for i in range(20):
    funct_list.append(partial(lambda x: test(x, "Hello World"), i))
</code></pre>
