<p>What about the following example?</p>

<p>First of all, I think you need define <code>virtual</code> the <code>send()</code> method in <code>Foo</code> (if you want it pure virtual).</p>

<p>Next, you can declare a intermediate template class (<code>Foo2</code>) where implement the <code>override</code> <code>send()</code></p>

<p>Last, you can use a template <code>send()</code> method in <code>Bar</code> to select the correct virtual <code>send()</code> method.</p>

<pre><code>#include &lt;iostream&gt;

template &lt;typename T&gt;
struct Foo
 { virtual void send(T t) = 0; };

template &lt;typename T&gt;
struct Foo2 : Foo&lt;T&gt;
 {
   void  send(T) override
    { std::cout &lt;&lt; "sizeof[" &lt;&lt; sizeof(T) &lt;&lt; "] " &lt;&lt; std::endl; }
 };

template &lt;typename...T&gt;
struct Bar : Foo2&lt;T&gt;...
 {
   template &lt;typename U&gt;
   void send (U u)
    { Foo2&lt;U&gt;::send(u); }
 };

int main()
 {
   Bar&lt;int, double&gt; b;

   b.send(1);    // print sizeof[4]
   b.send(2.3);  // print sizeof[8]
 }
</code></pre>
