<p><a href="http://www.cplusplus.com/reference/new/operator%20delete%5B%5D/"><code>::operator delete[]</code></a> is documented on <a href="http://www.cplusplus.com/">cplusplus.com</a> (which is sometimes frowned upon) as:</p>

<blockquote>
  <p><code>operator delete[]</code> can be called explicitly as a regular function, but in C++, <code>delete[]</code> is an operator with a very <em>specific behavior</em>: An expression with the <code>delete[]</code> operator, first <em>calls the appropriate destructors</em> for <em>each</em> element in the array (if these are of a class type), and then calls function  <code>operator delete[]</code> (i.e., this function) to release the storage.</p>
</blockquote>

<p>so the destructor is called <em>n</em> times (once for each element), and then the memory freeing "function" is called once.</p>

<p><sup>Notice that each destruction might take a different time (or even complexity) than the others. Generally most destructions are quick, and have the same complexity.... But that won't be the case if each destroyed element is a complex tree or node or graph...</sup></p>

<p>For primitive types like <code>int</code> the fictitious destructor of <code>int</code> is a no-op. The compiler probably would optimize that (if asked).</p>

<p>You should check the real <a href="http://en.wikipedia.org/wiki/C++11">C++11</a> standard, or at least its late <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf">n3337</a> working draft, which says (thanks to <a href="http://stackoverflow.com/users/214671/matteo-italia">Matteo Italia</a> for pointing that in a comment) in รยง5.3.5.6 page 110 of n3337: </p>

<blockquote>
  <p>If the value of the operand of the <em>delete-expression</em> is not a null pointer value, the <em>delete-expression</em> will
  invoke the destructor (if any) for the object or the elements of the array being deleted. In the case of an
  array, the elements will be destroyed in order of decreasing address (that is, in reverse order of the completion
  of their constructor; see 12.6.2)</p>
</blockquote>

<p>If you use -and trust enough- <a href="http://gcc.gnu.org/gcc-4.8/">GCC 4.8</a> or better, you could have used the <code>g++</code> compiler with the <code>-fdump-tree-phiopt</code> or <code>-fdump-tree-all</code> option (beware, they are dumping a lot of files!), or the <a href="http://gcc-melt.org/">MELT</a> plugin, to query the intermediate Gimple representation of some example. Or use <code>-S -fverbose-asm</code> to get the assembler code. And you also want to add optimization flags like <code>-O1</code> or <code>-O2</code> ...</p>

<p><sup>NB: IMHO, <a href="http://cppreference.com/">cppreference.com</a> is also an interesting site about C++, see <a href="http://en.cppreference.com/w/cpp/language/delete">there</a> about <code>delete</code> (as commented by <a href="http://stackoverflow.com/users/273767/cubbi">Cubbi</a>)</sup></p>
