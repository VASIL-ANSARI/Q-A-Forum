<p>From <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID351" rel="nofollow">Language Reference / Declarations</a> we know the following.</p>

<blockquote>
  <h2>Function Declaration</h2>
  
  <p>...</p>
  
  <h3>Special Kinds of Methods</h3>
  
  <p>...</p>
  
  <p>Methods associated with a type rather than an instance of a type must be marked with the <code>static</code> declaration modifier <em>for enumerations and structures</em> or the <code>class</code> declaration modifier <em>for classes</em>.</p>
</blockquote>

<p>I.e. the <code>static</code> keyword is (mainly) for enumerations and structures and the <code>class</code> keyword is for classes.</p>

<p>There is also such a note:</p>

<blockquote>
  <h3>Type Variable Properties</h3>
  
  <p>...</p>
  
  <h3>NOTE</h3>
  
  <p>In a class declaration, the keyword <code>static</code> has the same effect as marking the declaration with both the <code>class</code> and <code>final</code> declaration modifiers.</p>
</blockquote>

<p>I.e. the <code>static</code> keyword actually <em>can</em> be used in class declaration and will mean <code>final class</code>.</p>

<h1>So what about protocols?</h1>

<blockquote>
  <h3>Protocol Method Declaration</h3>
  
  <p>...</p>
  
  <p>To declare a class or static method requirement in a protocol declaration, mark the method declaration with the <code>static</code> declaration modifier. Classes that implement this method declare the method with the <code>class</code> modifier. Structures that implement it must declare the method with the <code>static</code> declaration modifier instead. If youâre implementing the method in an extension, use the <code>class</code> modifier if youâre extending a class and the <code>static</code> modifier if youâre extending a structure.</p>
</blockquote>

<p>Here the docs state that we should replace the <code>static</code> keyword from protocol declaration with the <code>class</code> keyword when implementing the protocol in a class or a class extension (and this is the exact answer to the original question).</p>

<h1>Bonus</h1>

<p>There are two cases in which protocol adoption will be restricted to classes only. The first (and the least explicit) is when a protocol includes <code>optional</code> members:</p>

<blockquote>
  <h2>Protocol Declaration</h2>
  
  <p>...</p>
  
  <p>By default, types that conform to a protocol must implement all properties, methods, and subscripts declared in the protocol. That said, you can mark these protocol member declarations with the <code>optional</code> declaration modifier to specify that their implementation by a conforming type is optional. The <code>optional</code> modifier can be applied only to protocols that are marked with the <code>objc</code> attribute. <em>As a result, only class types can adopt and conform to a protocol that contains optional member requirements</em>. ...</p>
</blockquote>

<p>And the second (explicit; the next paragraph):</p>

<blockquote>
  <p>To restrict the adoption of a protocol to class types only, mark the protocol with the <code>class</code> requirement by writing the <code>class</code> keyword as the first item in the <em>inherited protocols</em> list after the colon. ...</p>
</blockquote>

<p>But neither of them changes the rules considering the <code>static</code> and the <code>class</code> keywords applicability.</p>
