<p>Semantically and conceptually and with respect to The Holy Standard, it will be created every time. </p>

<p>The rest is up to your compiler and how you support her:</p>

<p><strong>Possibly</strong> the compiler can inline the call and then move deduced invariants outside
to a single point of initialization. </p>

<p><strong>Possibly</strong> the compiler dislikes that your
function has external linkage and so does not inline it, then having a hard time
seeing that invariant from other functions. </p>

<p><strong>Possibly</strong> the compiler will always check a variables constness and use one-time-initialization
when it can look inside and verify that <code>boost::assign::map_list_of( A, "A" )( B, "B" )( C, "C" )</code>
does not mutate global state.</p>

<p>Many factors, and the only way to be sure is to look at generated code.</p>

<hr>

<p>In response to a request for quotation:</p>

<p><strong>3.7.2.3 [basic.std.auto]:</strong> </p>

<blockquote>
  <p>If a named automatic object has initialization or a destructor with side effects, it shall not be destroyed before the end of its block, nor shall it be eliminated as an optimization even if it appears to be unused, except that a class object or its copy may be eliminated as specified in"  </p>
</blockquote>

<p>This basically means that either it has side effects, in which case it won't be eliminated, or it hasn't, in which case it is hardly observable within C++; this means effectively: </p>

<p><em>The observed behaviour is always <strong>as if it is called every time</strong>.</em></p>

<p>In other words: <em>There is no way to guarantee that initialization only happens once with automatic storage, so never assume the opposite</em>.</p>
