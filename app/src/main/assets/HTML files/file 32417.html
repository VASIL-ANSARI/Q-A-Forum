<p>Your options aren't limited to one or all at a time.  </p>

<p>You could insert the data in batches which will still give you the speed gains but also be more predictable on success.  Changing limits is still just that, still a limit (and there's others you may hit depending on data).  Batching 100 at a time seems reasonable.</p>

<p>Also ensure that you're not doing large batching work on the main UI thread.</p>

<p>In addition to that, the sqlite link you provided has preprocessor compilations settings if you compile your own sqlite binary.  FMDB is just a wrapper over sqlite and by default on iOS you'll get the sqlite packaged with iOS.  Of course, you could compile your own with altered limits and link into your app.</p>

<p>So, you would need to recompile and link with a limit of 0.  Note that the runtime limit call only allows you to <strong>lower</strong> the compiled limit if it's set above 0 (default is 100)</p>

<blockquote>
  <p>The maximum depth of an expression tree can be lowered at run-time
  using the sqlite3_limit(db,SQLITE_LIMIT_EXPR_DEPTH,size) interface if
  the SQLITE_MAX_EXPR_DEPTH is initially positive. In other words, the
  maximum expression depth can be lowered at run-time if there is
  already a compile-time limit on the expression depth. If
  SQLITE_MAX_EXPR_DEPTH is set to 0 at compile time (if the depth of
  expressions is unlimited) then the
  sqlite3_limit(db,SQLITE_LIMIT_EXPR_DEPTH,size) is a no-op.</p>
</blockquote>
