<p>Instead of calling <code>AutoDiscoverUrl()</code>, you can <a href="http://msdn.microsoft.com/en-us/library/dd633692%28v=exchg.80%29.aspx" rel="nofollow">set the url directly using</a> <code>exchangeService.Url = new Uri("https://outlook.office365.com/EWS/Exchange.asmx");</code>.</p>

<p>Also, after calling <code>AutoDiscoverUrl()</code> you can also inspect the <code>Url</code> property of your <code>ExchangeService</code> object to see whether it resolves to a secure endpoint or to an endpoint that you trust (from a specific list in your config file for example).</p>

<p>To be absolutely sure the returned Url is safe and secure, you should verify that the returned certificate is from the organization you expect it to be and that the certificate is signed by a trusted authority. This <a href="http://msdn.microsoft.com/en-us/library/dd633677%28v=exchg.80%29.aspx" rel="nofollow">process is explained here</a>. The default implementation mentioned int he article also accepts self-signed certificates, you probably don't want to do that in your production code. You could pin the certificate to a specific fingerprint for example. </p>

<p>If you want to exclude self-signed certs, change the following code in the referenced sample to return false:</p>

<pre><code>// When processing reaches this line, the only errors in the certificate chain are 
// untrusted root errors for self-signed certificates. These certificates are valid
// for default Exchange server installations, so return true.

// Or when you know that the certificate is signed by a trusted root authority, return false.
return false;
</code></pre>

<p>To answer your question, the username/password is normally sent securely using NTLM or Kerberos. In the worst case <a href="http://technet.microsoft.com/en-us/library/aa997233%28v=exchg.150%29.aspx" rel="nofollow">they can be sent using basic authentication</a>, but if you're connecting over SSL, than it shouldn't be easy to intercept the password as long as you validate the SSL certificates properly.</p>
