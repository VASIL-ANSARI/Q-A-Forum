<p>The <a href="https://msdn.microsoft.com/en-us/library/system.datetime.maxvalue(v=vs.110).aspx" rel="nofollow">DateTime.MaxValue</a> is:</p>

<blockquote>
  <p>equivalent to 23:59:59.9999999 UTC, December 31, 9999 in the
  Gregorian calendar, exactly one 100-nanosecond tick before 00:00:00
  UTC, January 1, 10000.</p>
</blockquote>

<p>Thus, considering roughly 10,000 years, you have:</p>

<pre><code>10,000 x 365 x 24 x 60 x 60 x 1000 = 315,360,000,000,000 //Note 15-digit
</code></pre>

<p>And the <a href="https://msdn.microsoft.com/en-sg/library/678hzkk9.aspx" rel="nofollow">double</a> precision is at least 15-digit. In other words, as long as you use the first 15 digit of your <code>TotalMilliseconds</code> as the timestamp, then it should be fine. </p>

<p>I recommend to cast it to <a href="https://msdn.microsoft.com/en-us/library/ctetwysk.aspx" rel="nofollow">long</a> whose integer precision is:</p>

<pre><code>â9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 //note, more than 15-digit
</code></pre>

<p>And then use <code>ToString("D15")</code> as unique timestamp:</p>

<pre><code>long val = (long)DateTime.MaxValue.Subtract(DateTime.UtcNow).TotalMilliseconds;
string timestamp = val.ToString("D15");
</code></pre>

<p>And to convert back, you could cast it back to <code>double</code> and use <code>AddMilliseconds</code> with negative sign from max.</p>

<pre><code>double db = Convert.ToDouble(timestamp);
DateTime dt = DateTime.MaxValue;
dt.AddMilliseconds(-db); //this will give you the datetime back with milliseconds precision
</code></pre>

<p>Then you will get precision up to your milliseconds.</p>
