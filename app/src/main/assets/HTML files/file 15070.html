<p>I think you should use the NDK. Write your program in <strong>C</strong> as opposed to C++ for easier project management. You should consider using <strong>libevent</strong> for asynchronous request processing. Don't use PHP for <strong>web</strong> interfaces, <strong>Python</strong> is much better at this point. C  is <em>the</em> best solution if you're willing to get <strong>dirty</strong>.</p>

<p>For developing sockets, I'd say you should use <strong>POSIX</strong> sockets - the industry standard. Later you should check out more advanced solutions like <strong>ZeroMQ</strong>. Use <strong>PostgreSQL</strong>/*<em>MongoDB</em>* depending on your requirements. Those are really advanced database management systems where you'll definitely find less overhaul then in, say, MySQL. I'd say <strong><em>MongoDB</em></strong> will fit the cause better - it's faster but doesn't feature full support for ACID data.</p>

<p>You should learn what you need for sockets programming in the <strong>MAN pages</strong> in any online/offline documentation base. It's not that hard. Here's a <strong>server example in C</strong>, <strong>study it</strong>, try to <strong>write your own client implementation</strong>, understand the basic principle of TCP/IP packet abstraction (by the way, this is a TCP socket, you should <strong>check out UDP examples</strong>, those are way more relevant for your project):</p>

<pre><code>/*
"Arch_server" - a basic server program in C
Copyright Â© Juozas Domarkas 2012, all rights served
*/

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;strings.h&gt;
#include &lt;unistd.h&gt;

void respond(int socket);

void error(char *msg)
{
    perror(msg);
    exit(1);
}

int main
(int argc, char *argv[])
{
    int socket_server_fd, socket_client_fd, pid;
    socklen_t client_address_length;
    struct sockaddr_in server_address, client_address;

    if (argc != 3)
        error("Correct usage: server [host] [port]\n");

    socket_server_fd = socket(AF_INET, SOCK_STREAM, 0);

    bzero(&amp;server_address, sizeof(server_address));
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_port = htons(atoi(argv[2]));

    bind(socket_server_fd, (const struct sockaddr *) &amp;server_address, sizeof(server_address));

    listen(socket_server_fd, 16);
    client_address_length = sizeof(client_address);

    while (1) {
        socket_client_fd = accept(socket_server_fd, (struct sockaddr *) &amp;client_address, &amp;client_address_length);
        pid = fork();
        if (pid == 0) {
            close(socket_server_fd);
            respond(socket_client_fd);
            exit(0);
        }
    }

    return EXIT_SUCCESS;
}

void respond
(int socket)
{
    int n;
    char buffer[1024];

    bzero(buffer, 1024);
    n = recv(socket, buffer, 1023, 0);
    if (n &lt; 0) error("ERROR reading from socket");
    printf("Here is the message: %s\n", buffer);
    n = send(socket,"Message received.", 17, 0);
    if (n &lt; 0) error("ERROR writing to socket");
}
</code></pre>

<p>Depending on your experience, you should either write your server suite or <strong>use existing solutions</strong>. I recommend giving yourself a decent deadline (say, <strong><em>8 months</em></strong>) and writing ALL the "HIGHER LEVEL" tools yourself. That way you'll get the most out of your project. Try to write them as <em>basic</em> as possible. Use low level existing solutions for better performance, study them, learn something from the 31337 h2x0r5.</p>

<p>Definitely check out OGRE 3D instead of GL/ES. It's an abstraction library for OpenGL. Much easier than OpenGL, better support for modern 3D development, libraries, plugins, all sorts of already developed particle, locomotion, sky/water systems.</p>

<p>Do not go for something like Unity3D. You have better things to do.</p>

<hr>

<p>The best book to learn real C programming is "<strong>The C programming language</strong>" by <strong>Dennis M. Ritchie</strong> and <strong>Brian W. Kernighan</strong>.</p>

<p>Google has a lot of tutorials for Android development regarding the NDK. <strong>Definitely use the NDK</strong>. Java has good support for 3D graphics but it really isn't the right tool for the job. It's a 'niche' solution, not an industry accepted standard in game development. Regarding that, the industry uses C++ for game development. I'd seriously recommend using ONE language for the whole product life cycle. You'll need a networking server, database interface, hooks... Use C. With C++ you'll get way too much overhaul. You'll end up learning BOOST, STL, all that other crap that comes with C++. Better use C, libevent, OGRE 3D, some existing OGRE systems. All those projects have good solid documentation and are ready for prime-time use.</p>

<p><strong>Ogre3D</strong> is intended for 3D games. You can make a "2D platform" game with it. One extra dimension isn't really that much to learn.</p>

<p>Learn each platform one-by-one. Don't read "all-in-one" books.</p>

<p>Check out the documentation of those projects.</p>

<hr>

<p>Seeing as you have a lot of free time on your hands, better make yourself firstly a good plan. Organize yourself, your thoughts in one manner and try to reach for the "goal". It's really realistic to finish your MMO in, say, 4 to 5 years. That's how long it mostly takes for professionals and sometimes even indies.</p>

<p>Be persistent, learn something new each day, try to write code each day. Work towards ONE goal - your game. If some other project comes up - postpone it. Be a pragmatic programmer. Don't be afraid to get dirty. Take a couple of days per month off for your title, don't go to school (don't drop it!!!). Be persistent.</p>

<hr>

<p>I hate doing this, but choosing a compiler, tool, platform, language is <em>pure</em> politics. I prefer "the best tool for the job", similarly to Linus Torvalds. I mostly use open source software since it does the job better. When it comes to "GPL" vs "BSD" or restrictive versus permissive software licenses, I definitely choose BSD, simply because I believe in free software versus somewhat "socially free".</p>

<p>A good compiler, in my opinion, would be <strong>CLANG</strong> from Apple's LLVM compiler collection.</p>
