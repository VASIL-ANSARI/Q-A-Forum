<p>Changing size by adding fields is ok for strictly managed code.</p>

<p>Adding field(s) is non-breaking change as code will be re-JIT-ed with the new type and all allocations will use correct size. Since it is value type the new fields will be properly initialized with empty values anyway.</p>

<p>Removing/changing types of existing fields(s) or properties is definitely breaking change. </p>

<p>Value types are sealed - so no other libraries can derive from that type - so unlike classes they can't create problems with "this derived class did not implement a new virtual property/interface method".</p>

<p>Note: if a value type is used for interop or any other kind of binary serialization outside of your control than any change is breaking.</p>

<p>I.e. someone else used <code>MyLib.Point {int x;int y;}</code> to save a list of points with binary serialization to a file. If now "MyLib" adds a new field to <code>MyLib.Point</code> than the serialized data no longer can be read with binary serialization. Similar issue with native interop.</p>
