<pre><code>Box box = new Box(x+i,y);  //error
</code></pre>

<p>One error is right here. You should write this as:</p>

<pre><code>Box *box = new Box(x+i,y); //ok
</code></pre>

<p>It is because when you use <code>new</code>, you're allocating memory, and only a pointer can hold a memory, so <code>box</code> has to be <em>pointer</em> type.</p>

<p>Similarly, </p>

<pre><code>Edge getBoxEdges() const {return boxEdges;}  //error
</code></pre>

<p>should be written as:</p>

<pre><code>const Edge* getBoxEdges() const {return boxEdges;}  //ok
</code></pre>

<p>It is because <code>boxEdges</code> is an array, which can decay into pointer type to its first element, and since it is const member function, <code>boxEdges</code> will decay into <code>const Edge*</code>.</p>

<hr>

<p>By the way, instead of <em>pointer</em> in the first case, you use automatic object as:</p>

<pre><code>Box box(x+i, y); //ok
</code></pre>

<hr>

<p>I would suggest you to make the second parameter of <code>operator&lt;&lt;</code> a const reference:</p>

<pre><code>//std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, Box box); //don't use this
std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, Box const &amp; box); //use this
</code></pre>

<p>This avoids unnecessary copy!</p>
