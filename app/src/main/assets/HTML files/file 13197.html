<p><a href="http://docs.python.org/release/2.5/lib/module-cPickle.html"><code>cPickle</code></a> has a smarter algorithm than <a href="http://docs.python.org/library/marshal.html"><code>marshal</code></a> and is able to do tricks to reduce the space used  by large objects. That means it'll be slower to decode but faster to encode as the resulting output is smaller.
<code>marshal</code> is simplistic and serializes the object straight as-is without doing any further analyze it. That also answers why the <code>marshal</code> loading is so inefficient, it simply has to do more work - as in reading more data from disk - to be able to do the same thing as <code>cPickle</code>.</p>

<p><code>marshal</code> and <code>cPickle</code> are really different things in the end, you can't really get both fast saving and fast loading since fast saving implies analyzing the data structures less which implies saving a lot of data to disk.  </p>

<p>Regarding the fact that <code>marshal</code> might be incompatible to other versions of Python, you should generally use <code>cPickle</code>:</p>

<blockquote>
  <p>"This is not a general âpersistenceâ module. For general persistence and transfer of Python objects through RPC calls, see the modules pickle and shelve. The marshal module exists mainly to support reading and writing the âpseudo-compiledâ code for Python modules of .pyc files. Therefore, the Python maintainers reserve the right to modify the marshal format in backward incompatible ways should the need arise. If youâre serializing and de-serializing Python objects, use the pickle module instead â the performance is comparable, version independence is guaranteed, and pickle supports a substantially wider range of objects than marshal." (<a href="http://docs.python.org/library/marshal.html">the python docs about marshal</a>)</p>
</blockquote>
