<blockquote>
  <p>it isn't obvious that those params are constants</p>
</blockquote>

<p>Does it matter that much? If you are choosing recursion over a loop because you like the functional approach, all your variables and parameters are constants anyway. You can tell whether they stay constant or not in the recursive descent by looking at the recursive call and comparing the arguments to your function's parameters.</p>

<blockquote>
  <p>Alternatively, I could have 2 functions and keep constants in the closure of the first, but I'm curious if recreating the second function every time the first is called will cause unnecessary object creation &amp; GC.</p>
</blockquote>

<p>Unlikely. Afaik, no function objects are instantiated for simple inline helper functions that are never used as an object or exported as a closure. At least it's a rather trivial optimisation, and even when not done the GC pressure will not be hard or impair performance noticeably.<br>
You should go for this approach as it is the cleanest and most maintainable.</p>

<blockquote>
  <p>I could keep it at one function, and just cache the initial values</p>
</blockquote>

<p>You better not do that. It introduces an extra condition in the function that will impair performance because it is executed on each and every call, but most of all it complicates the code unnecessarily much. This is also likely the reason for the bug you introduced - you never unset the <code>.cache</code> in the base case<sup>1</sup> so that all invocations will use the same constants no matter what is passed to them. Also, you are leaking the constants into the global scope where anyone could access them.</p>

<p><sub>1: Admittedly, your demo function does not <em>have</em> a base case, but ask yourself: if you had added one, would you have forgotten to unset the cache?</sub></p>
