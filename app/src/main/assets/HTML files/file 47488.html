<blockquote>
  <p>Why proguard does not obfuscate method body?</p>
</blockquote>

<p>Because it can't.<br>
The names of method arguments and local variables are simply not stored when compiling.<br>
The names you're seeing are generated by your decompiler.</p>

<p>For compiled code, there are two way to store data locally (i.e. within a method):</p>

<ul>
<li>On the operand stack</li>
<li>In local variables</li>
</ul>

<p>The operand stack is really just a stack.<br>
See <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-7.html#d5e22660">Table 7.2</a> from the Java VM Specification for stack operators.<br>
You can pop values (<code>pop</code>), duplicate the top value (<code>dup</code>), swap the top two values (<code>swap</code>) and the same with slightly altered behaviour (<code>pop2</code>, <code>dup_x1</code>, <code>dup_x2</code>, <code>dup2</code>, <code>dup2_x1</code>, <code>dup2_x2</code>).<br>
And most, if not all instructions that produce a return value will drop said value onto the stack.</p>

<p>The important thing for this question is how things on the stack are referred to, which is like with any other stack:<br>
Relative to the top position, and based on the instruction used.<br>
There are no assigned numbers or names, it's just whatever's currently there.</p>

<p>Now, for the so-called "local variables":  </p>

<p>Think of them more as an <code>ArrayList</code> than variables in Java.<br>
Because that's exactly how you access them: by index.<br>
For the variables 0 to 3, there are special instructions (i.e. single byte) because they are used so often, all other variables can only be accessed via a two-byte instruction, where the second byte is the index.<br>
See <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-7.html#d5e22660">Table 7.2</a> again, "Loads" and "Stores".<br>
The first five entries in both tables are the wide (two-byte) store/load instructions for each data type (note that, for single values, <code>boolean</code>, <code>char</code>, <code>byte</code> and <code>short</code> are all converted to <code>int</code>, leaving only <code>int</code>, <code>float</code> and <code>Object</code> as single-slot values and <code>long</code> and <code>double</code> as double-slot ones), the next twenty instructions are the instructions for direct access to registers 0 to 3, and the last eight instructions are to access array indices (note that inside arrays, <code>boolean</code>, <code>byte</code>, <code>char</code> and <code>short</code> are <strong>not</strong> converted to <code>int</code>, to not waste space, which is why there are three more instructions (not four, since <code>byte</code> and <code>char</code> have the same size)).</p>

<p>Both the maximum stack size and the number of local variables are limited, and must be given in the header of the <code>Code</code> attribute of each method, as defined in <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3">Section 4.7.3</a> (<code>max_stack</code> and <code>max_locals</code>).</p>

<p>The interesting thing about local variables, though, is that they double as method arguments, meaning that the number of local variables can never be lower than the number of method arguments.<br>
Note that when counting values for the Java VM, variables of the type <code>long</code> and <code>double</code> are treated as two values, and need two "slots" accordingly.<br>
Also note that for non-static methods, the argument 0 will be <code>this</code>, which requires another "slot" for itself.</p>

<p>That being said, let's look at some code!</p>

<p>Example:</p>

<pre><code>class Test
{
    public static void main(String[] myArgs) throws NumberFormatException
    {
        String myString = "42";
        int myInt = Integer.parseInt(myString);
        double myDouble = (double)myInt * 42.0d;
        System.out.println(myDouble);
    }
}
</code></pre>

<p>Here we have three local variables <code>myString</code>, <code>myInt</code> and <code>myDouble</code>, plus one argument <code>myArgs</code>.<br>
In addition, we have two constants <code>"42"</code> and <code>42.0d</code>, and a lot of external references:</p>

<ul>
<li><code>java.lang.String[]</code> - class</li>
<li><code>java.lang.NumberFormatException</code> - class</li>
<li><code>java.lang.String</code> - class</li>
<li><code>java.lang.Integer.parseInt</code> - method</li>
<li><code>java.lang.System.out</code> - field</li>
<li><code>java.io.PrintStream.println</code> - method</li>
</ul>

<p>And some exports: <code>Test</code> and <code>main</code>, plus the default constructor that the compiler will generate for us.</p>

<p>All constants, references and exports will be exported to the <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4">Constant Pool</a> - the local variables and argument names will not.</p>

<p>Compiling and disassembling the class (using <code>javap -c Test</code>) yields:</p>

<pre><code>Compiled from "Test.java"
class Test {
  Test();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
       4: return

  public static void main(java.lang.String[]) throws java.lang.NumberFormatException;
    Code:
       0: ldc           #2                  // String 42
       2: astore_1
       3: aload_1
       4: invokestatic  #3                  // Method java/lang/Integer.parseInt:(Ljava/lang/String;)I
       7: istore_2
       8: iload_2
       9: i2d
      10: ldc2_w        #4                  // double 42.0d
      13: dmul
      14: dstore_3
      15: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;
      18: dload_3
      19: invokevirtual #7                  // Method java/io/PrintStream.println:(D)V
      22: return
}
</code></pre>

<p>Besides the default constructor, we can see our <code>main</code> method, step by step.<br>
Note how <code>myString</code> is accessed with <code>astore_1</code> and <code>aload_1</code>, <code>myInt</code> with <code>istore_2</code> and <code>iload_2</code>, and <code>myDouble</code> with <code>dstore_3</code> and <code>dload_3</code>.<br>
<code>myArgs</code> isn't accessed anywhere, so there's no bytecode dealing with it either, but at the beginning of the method, a reference to the String array will in local variable 1, which gets soon overwritten by a reference to <code>"42"</code>.</p>

<p><code>javap</code> will also show you the Constant Pool if you pass it the <code>-v</code> flag, but it doesn't really add any value to the output, since all relevant information from the Constant Pool is displayed in comments anyway.</p>

<p>But now, let's look at what the decompilers produce!</p>

<p>JD-GUI 0.3.5 (JD-Core 0.6.2):</p>

<pre><code>import java.io.PrintStream;

class Test
{
  public static void main(String[] paramArrayOfString)
    throws NumberFormatException
  {
    String str = "42";
    int i = Integer.parseInt(str);
    double d = i * 42.0D;
    System.out.println(d);
  }
}
</code></pre>

<p>Procyon 0.5.28:</p>

<pre><code>class Test
{
    public static void main(final String[] array) throws NumberFormatException {
        System.out.println(Integer.parseInt("42") * 42.0);
    }
}
</code></pre>

<p>Note how everything that was exported to the Constant Pool persists, while JD-GUI simply picks some names for local variables, and Procyon optimizes them out entirely.<br>
The name of the argument - <code>paramArrayOfString</code> vs <code>array</code> (vs the original <code>myArgs</code>) - is a perfect example, though, to show that there is no "correct" name anymore, and the decompilers simply have to rely on some pattern of picking a name.</p>

<p>I don't know where the "true" names in your decompiled code are coming from, but I'm fairly certain that they're not contained in the jar file.<br>
Feature of your IDE maybe?</p>
