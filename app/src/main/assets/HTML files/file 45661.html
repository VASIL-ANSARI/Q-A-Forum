<p>To your point, the Timer object [1] in python runs just once and after some period of time executes a function. That function, though, can start a new Timer object. An example of this implementation is below. </p>

<pre><code>timerThread = None

def timesUp():
    global timerThread
    print('Nice!')
    timerThread = Timer(10, timesUp)
    timerThread.start()

def main():
    global timerThread
    timerThread = Timer(10, timesUp)
    timerThread.start()
    while 1:
        input = str(sys.stdin.readline())
        if input == 'EXIT\n':
            timerThread.cancel()
            break;
</code></pre>

<p>Overall, due to GIL [2] issues in python, you'll have issues with threading properly, as only 1 thread has access to the interpreter at a time. This is why a lot of frameworks in python are single threaded, asynchronous frameworks (e.g. gevent [3], tornado [4]). Instead of using threads they listen on an IOLoop (eventlets, epoll) and cooperatively yield operation flow to the other waiting coroutines.</p>

<p>[1] - <a href="https://docs.python.org/2/library/threading.html#timer-objects" rel="nofollow">https://docs.python.org/2/library/threading.html#timer-objects</a></p>

<p>[2] - <a href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="nofollow">https://wiki.python.org/moin/GlobalInterpreterLock</a></p>

<p>[3] - <a href="http://www.gevent.org/" rel="nofollow">http://www.gevent.org/</a></p>

<p>[4] - <a href="http://www.tornadoweb.org/en/stable/" rel="nofollow">http://www.tornadoweb.org/en/stable/</a></p>
