<p>The brute force approach is to generate the cartesian product of the buckets, and filter out any that are invalid. So, assuming your buckets are simply lists of items, something along the lines of:</p>

<pre><code>var cp = _.flatten(_.flatten(_.map(B1, function(item1) {
    return _.map(B2, function(item2) {
        return _.map(B3, function(item3) {
            return [item1, item2, item3];
        });
    });
}), true), true);
</code></pre>

<p>Will give you the cartesian product of 3 buckets.</p>

<pre><code>_.filter(cp, function(tuple) {
    return !overlaps(item1, item2) &amp;&amp; !overlaps(item1, item3) &amp;&amp; !(overlaps(item2, item3);
});
</code></pre>

<p>will filter out the ones you don't want (given a suitable definition of overlaps).</p>

<pre><code>function overlaps(a, b) {
    return a.lower &gt; b.upper || b.lower &gt; a.upper;
}
</code></pre>

<p>You can generalise the filter to any number of intervals by converting the cartesian product to a recursive call calculating the flattened expansion of _.first(args) over the cartesian product of _.rest(args).</p>

<p>You can generalise the filter to any number of intervals by generating all possible pairs, and calling <code>!_.any(pairs, function(pair) { return overlaps.prototype.apply(undefined, pair); });</code>.</p>
