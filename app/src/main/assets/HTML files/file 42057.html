<p><strong>Trust the language</strong>. Whatever behaviour you observe happened because that's what your code does. If you see a bug, it's 99.99% percent that it's your fault, and not a bug in PHP.</p>

<p>With this mindset you can make progress.</p>

<hr>

<p>See what <em>pure reasoning</em> shows us:</p>

<pre><code>TRUE AND TRUE ? 'yes' : 'no'
</code></pre>

<p>and</p>

<pre><code>(TRUE AND TRUE) ? 'yes' : 'no'
</code></pre>

<p>behave differently.</p>

<p>Because all we did was changing the order of evaluation, that means that the first expression must have parsed as:</p>

<pre><code>TRUE AND (TRUE ? 'yes' : 'no')
</code></pre>

<p>And indeed, <code>TRUE and 'yes'</code> is <code>TRUE</code>.</p>

<hr>

<p>The rules are sometimes complicated. In this case you have to know the <a href="http://php.net/manual/en/language.operators.precedence.php" rel="nofollow">operator precedence</a> and how values are <a href="http://php.net/manual/en/language.types.boolean.php#language.types.boolean.casting" rel="nofollow">converted to boolean.</a></p>

<p>The <a href="http://php.net/manual/en/language.operators.logical.php" rel="nofollow">manual</a> specifically mentions the difference.</p>

<blockquote>
  <p>The reason for the two different variations of "and" and "or" operators is that they operate at different precedences. (See Operator Precedence.) </p>
</blockquote>

<hr>

<p>In case you're unsure about the precedence order it's best to explicitly mark your intention with parentheses. At least, that's what I do. If it's not obvious to me, it might cause problems to others as well. And of course, you can read the code faster if you don't have to recite the rule. Don't abuse this though, obvious things shouldn't be mentioned in the code, don't increase syntactic noise just because you're lazy to learn the basic rules ;)</p>

<hr>

<p>For a practical viewpoint, it's best to avoid <code>AND</code> in your code.</p>
