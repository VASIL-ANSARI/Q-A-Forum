<p>A single hash prefix (<code>#</code>) forces the preprocessor to <a href="http://gcc.gnu.org/onlinedocs/cpp/Stringification.html#Stringification" rel="nofollow">stringify</a> your argument. Double hash prefix (<code>##</code>) simply pastes the argument and merges it with its prefix.</p>

<p>This means that <code>tokenpaster(34)</code> will be expanded to:</p>

<pre><code>printf ("token" "34" " = %d", token34)
                ^^^^               ^^
                  |                 |
                  |                 +---- pasted and merged
                  |
                  +---- enclosed in quotes
</code></pre>

<p>These three string literal parts are then merged into a single literal:</p>

<pre><code>printf ("token34 = %d", token34)
</code></pre>

<p>According to <a href="http://www.open-std.org/JTC1/sc22/wg14/www/docs/n1124.pdf" rel="nofollow">the standard</a>:</p>

<blockquote>
  <p>Â§6.10.3.2 The <code>#</code> operator </p>
  
  <p>2   If, in the replacement list, a parameter is immediately preceded by a <code>#</code> preprocessing
  token, both are replaced by a <strong>single character string literal preprocessing token</strong> that
  contains the spelling of the preprocessing token sequence for the corresponding
  argument. (...)</p>
</blockquote>

<p>and</p>

<blockquote>
  <p>Â§6.10.3.3 The <code>##</code> operator </p>
  
  <p>2  If, in the replacement list of a function-like macro, a parameter is immediately preceded
  or followed by a <code>##</code> preprocessing token, the <strong>parameter is replaced by the corresponding
  argument's preprocessing token sequence</strong> (...)</p>
</blockquote>
