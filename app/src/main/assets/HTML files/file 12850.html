<p>Keep it simple.</p>

<p>Abstract away the network layer. I usually use an interface called something like <code>INetworkChannel</code> that looks something like this:</p>

<pre><code>public interface INetworkChannel : IDisposable
{
    void Connect(IPEndPoint remoteEndPoint);
    void Send(byte[] buffer, int offset, int count);

    public event EventHandler Disconnected;
    public event EventHandler&lt;ReceivedEventArgs&gt; Received;
}
</code></pre>

<p>It makes it easy to test everything and you could create <code>SecureNetworkChannel</code> class which uses <code>SslStream</code>  or <code>FastNetworkChannel</code> which uses the new Async methods.</p>

<p>The details like what stream is used or if you use <code>TcpClient</code> or <code>Socket</code> should not matter to the rest of the application.</p>

<p><strong>Edit</strong></p>

<p>Testing the <code>INetworkingChannel</code> implementation is easy too since you now got a class with a very clear responsibility.  I do create a connection to my implementations to test them. Let the <code>TcpListener</code> listen on port <code>0</code> to let the OS assign a free port. </p>

<p>I just make sure that it handle sends and receives properly and that it do proper clean up when a connection is closed/broken.</p>
