<p>A <code>Task</code> is a unit of work (a promise) which will complete sometime in the near future. A task isn't necessarily using a <code>Thread</code> behind the scenes to do its work (as we have something called a Promise Task). You can think about it like this: A task is <strong>something you want done</strong>, while a thread is <strong>one possible way to to get that work done</strong>.</p>

<p>Specifically, <code>Task.Factory.Startnew</code> or <code>Task.Run</code> queue work on the ThreadPool. They provide an abstraction over that ThreadPool for us, and expose a more flexiable API than <code>Thread</code>, such as Continuation and Cancellation.</p>

<p>From <a href="http://msdn.microsoft.com/en-us/library/hh195051(v=vs.110).aspx" rel="nofollow"><code>Task.Run</code></a>:</p>

<blockquote>
  <p>Queues the specified work to run on the ThreadPool and returns a task
  handle for that work.</p>
</blockquote>

<p>In your example, the code that runs inside the <code>delegate</code> will be queued on the ThreadPool, and will not block your UI. </p>

<p>From <a href="http://msdn.microsoft.com/en-us/library/dd537609(v=vs.110).aspx" rel="nofollow"><code>Task Parallelism</code></a>:</p>

<blockquote>
  <p>The Task Parallel Library (TPL) is based on the concept of a task,
  which represents an asynchronous operation. In some ways, a task
  resembles a thread or ThreadPool work item, but at a higher level of
  abstraction. The term task parallelism refers to one or more
  independent tasks running concurrently. Tasks provide two primary
  benefits: </p>
  
  <ul>
  <li><p>More efficient and more scalable use of system resources.
  Behind the scenes, tasks are queued to the ThreadPool, which has been
  enhanced with algorithms that determine and adjust to the number of
  threads and that provide load balancing to maximize throughput. This
  makes tasks relatively lightweight, and you can create many of them to
  enable fine-grained parallelism.</p></li>
  <li><p>More programmatic control than is
  possible with a thread or work item. Tasks and the framework built
  around them provide a rich set of APIs that support waiting,
  cancellation, continuations, robust exception handling, detailed
  status, custom scheduling, and more.</p></li>
  </ul>
</blockquote>

<p><strong>Edit:</strong></p>

<p>For your second question, a <code>lock</code> is the means to synchronize access to shared resources across threads. So yes, it would <strong>make it</strong> thread-safe to use a <code>lock</code>.</p>

<p><strong>Edit 2:</strong></p>

<p>As for your third question, you can use a <code>CancellationTokenSource</code> and pass its <code>CancellationToken</code> to the created Task:</p>

<pre><code>var cts = new CancellationTokenSource();
var cancellationToken = cts.Token;

Task.Run(() =&gt;
 {
    cancellationToken.ThrowIfCancellationRequested();
    myfunction();
 }, cancellationToken);

cts.Cancel();
</code></pre>

<p>If <code>cts.Cancel</code> is called before <code>cancellationToken.ThowIfCancellationRequested</code>, it will cause that method call to throw a <code>OperationCanceledException</code> and the task will return in a cancelled state. Note you have to pass <code>Task.Run</code> the CancellationToken. If you dont, it will end up in a faulted state instead of cancelled.</p>

<p>You can read to extent on <a href="http://msdn.microsoft.com/en-us/library/dd997396(v=vs.110).aspx" rel="nofollow"><em>Task Cancellation</em></a></p>

<p><strong>Edit 3:</strong> </p>

<p>I am assuming this is what you wanted:</p>

<pre><code>var cancellationToken = cts.Token;

Task.Run(() =&gt;
 {
    cts.Cancel();
     cancellationToken.ThrowIfCancellationRequested();

    myfunction();
 }, cancellationToken);
</code></pre>
