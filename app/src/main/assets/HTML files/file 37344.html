<p>The function you are using is way too short (i.e. doesn't take enough time to compute), so you spend all your time in the synchronization between processes, that has to be done in a serial manner (so why not on a single processor). Try this:</p>

<pre><code>import multiprocessing as mp


def square(x):
    for i in range(10000):
         j = i**2
    return x**2


if __name__ == '__main__':
    # pool=mp.Pool(processes=4)
    # pool.map(square,range(1000))
    # pool.close()
    for i in range(1000):
        square(i)
</code></pre>

<p>You will see that suddenly the multiprocessing works well: it takes ~2.5 seconds to accomplish, while it will take 10s without it.</p>

<p><strong>Note:</strong> If using python 2, you might want to replace all the <code>range</code> by <code>xrange</code></p>

<p><strong>Edit:</strong> I replaced <code>time.sleep</code> by a CPU-intensive but useless calculation</p>

<p><strong>Addendum:</strong> In general, for multi-CPU applications, you should try to make each CPU do as much work as possible without returning to the same process. In a case like yours, this means splitting the range into almost-equal sized lists, one per CPU and send them to the various CPUs.</p>
