<p>This is what I did to make it work for my application. </p>

<pre><code>import numpy as np
import pandas as pd
import itertools as it
import string

# Test data frame
N = 6
col_ids = string.letters[:N]
df = pd.DataFrame(
     np.random.randint(20, size=(5,N)),
     columns=['{}_z'.format(letter) for letter in col_ids])

N_lim = int(0.5*N*(N-1))
result_index = ['Dz_{}'.format(tag) for tag in range(1,N_lim+1)]

def cart_dist_2(A): # Cartesian distance function
    return [y - x for x, y in it.combinations(A, 2)]

test_2 = df.apply(lambda x: pd.Series(cart_dist_2(x),index=result_index),axis=1)
</code></pre>

<p>Where the test data frame looks as such</p>

<pre><code>  A_z  B_z  C_z  D_z  E_z  F_z
0   18   19    7    5   14    5
1   17    9    2   17    1    5
2   16   10   18   14   14    3
3    7    2   10    9    9   10
4   18    5   10   10    3   11
</code></pre>

<p>Again, we are looking for the difference between all possible combinations of entries per row. The resultant <code>test_2</code> data frame is given as:</p>

<pre><code>print test_2.values

[[  1 -11 -13  -4 -13 -12 -14  -5 -14  -2   7  -2   9   0  -9]
 [ -8 -15   0 -16 -12  -7   8  -8  -4  15  -1   3 -16 -12   4]
 [ -6   2  -2  -2 -13   8   4   4  -7  -4  -4 -15   0 -11 -11]
 [ -5   3   2   2   3   8   7   7   8  -1  -1   0   0   1   1]
 [-13  -8  -8 -15  -7   5   5  -2   6   0  -7   1  -7   1   8]]
</code></pre>

<p>Hope this is useful for someone else. </p>

<p>To recap: I ignored grouping it and applied the function straight away to the rows of the data frame.</p>
