<p>There are a number of ways to do this</p>

<p>You could just tweak the power limits <a href="http://matplotlib.org/api/ticker_api.html#matplotlib.ticker.ScalarFormatter.set_powerlimits" rel="nofollow">(doc)</a></p>

<pre><code>ax1.xaxis.get_major_formatter().set_powerlimits((0, 1))
</code></pre>

<p>which set the powers where <code>ScalerFormatter</code> switches to scientific notation</p>

<p>Or, you could use a <code>FuncFormatter</code> which gives you a good deal of control (but you can blow your foot off).</p>

<pre><code>scale_pow = 2
def my_formatter_fun(x, p):
    return "%.2f" % (x * (10 ** scale_pow))
ax1.get_xaxis().set_major_formatter(ticker.FuncFormatter(my_formatter_fun))
ax1.set_xlabel('my label ' + '$10^{{{0:d}}}$'.format(scale_pow))
</code></pre>

<p><code>FuncFormatter</code> <a href="http://matplotlib.org/api/ticker_api.html#matplotlib.ticker.FuncFormatter" rel="nofollow">(doc)</a> takes a 2 argument function that returns a string and uses that function to format the label.  (Be aware, this will also change how the values are displayed in the corner of interactive figures).  The second argument is for 'position' which is an argument handed when the formatter makes the labels.  You can safely ignore it, but you must take it (other wise you will get errors from wrong number of arguments).  This is a consequence of the unified API of all the formatters and using the formatter for displaying the location of the mouse in interactive.</p>
