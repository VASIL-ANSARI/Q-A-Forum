<p>This is the cause:</p>

<pre><code>c_style_path = (char *)path.c_str();
//...
delete[] c_style_path;
</code></pre>

<p>as it is <code>delete[]</code>ing memory that it should not and probably results in a double free when <code>path</code> goes out of scope at the end of the function.</p>

<p>Just use <code>path.c_str()</code> when you require <code>const char*</code>:</p>

<pre><code>dir = opendir (path.c_str());  
</code></pre>

<p>Note that storing the pointer returned by <code>std::string::c_str()</code> is quite dangerous as it can easily lead to a dangling pointer if the <code>std::string</code> instance goes out of scope.</p>
