<p>Read (entire) file into a buffer whose size is the same as the file size.  No <code>realloc</code>.</p>

<p>Close your file and don't worry about leaking the handle later in your program.</p>

<p>Scan said buffer for line breaks.  Count them.  Don't worry about the numbers.</p>

<p>Allocate your array of numbers now that you know how many there are.  No <code>realloc</code>.  Write into that array as you scan the buffer again.</p>

<p>Free your buffer if you don't need it anymore.</p>

<p>Unless you're talking about a pipe to some other process, a socket, or a 4+ GB file, there's no sense in buffering human-language data in a low-level language.  Or if you're writing code that's going to run on an elevator controller or microwave or electric razor or something - but then you don't have any files, eh?  If your file fits in your address space (the VAST majority of files do, now) then buffering is a premature optimization of your memory footprint that will cost you time, both write-time and run-time.</p>
