<p>I'm not sure if I'm following your question entirely, but it appears that you can just set <code>end=true</code> whenever you detect the end of the message you're receiving:</p>

<pre><code>char buf[20];
memset(buf,'\0',20);
while(!end)
{
    nbytes_read=recv(sclient,(char *)ress,sizeof(ress),0);
    if(strcmp(ress,"1")==0)
    {
        printf("Details: %s (%i)\n",buf,nbytes_read);
        while(strcmp(buf,"\r\n\r\n") != 0)
        {
            nbytes_read=recv(sclient,(char *)buf,sizeof(buf),0);
            cout.flush();
            printf("Details: %s (%i)\n",buf,nbytes_read);
        }
    }
    if(strcmp(buf,"\r\n\r\n")==0)
    {
        end = true; // &lt;--- This should do it for you, right?
        printf("The End\n");
    }
    cout.flush();
}
</code></pre>

<p>However, if the client is still connected and writing the next message to the socket, then you just need to start reading the next message. So what happens with the client once the message is written? Does it start writing the next message or does it close the socket connection?</p>

<p>In addition: you need to take what's in your buffer and create a message from it. When the current message is done, then consider creating a new message with the contents of the buffer from the next message.</p>
