<p>AFAICT, in the line:</p>

<pre><code>return USBH_CtlReq(pdev, phost, &amp;ADK_Machine.protocol , 2 );
</code></pre>

<p>the <code>ADK_Machine.protocol</code> is an <code>uint16_t</code>. If that's true, than, taking its address will yield a <code>uint16_t *</code>, which is not convertible to <code>uint8_t*</code> that <code>USBH_CtlReq</code> expects.</p>

<p>A lot of low-level "sending" functions in C declare arguments as <code>uint8_t*</code> or <code>unsigned char*</code>, to indicate that they are expecting "bytes". In principle, they could just as well declare <code>void*</code>.</p>

<p>But, in this case, the only thing to do is cast, like:</p>

<pre><code>return USBH_CtlReq(pdev, phost, (uint8_t*)&amp;ADK_Machine.protocol , 2 );
</code></pre>

<p>Of course, you need to be mindful that this will not take care of endianness.</p>
