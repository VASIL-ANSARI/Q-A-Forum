<p>I would create the data templates as resources and refer to them elsewhere in the XAML.  For example:</p>

<pre><code>&lt;Window ....&gt;

    &lt;Window.Resources&gt;
        &lt;DataTemplate x:Key="SearchResultTemplate" TargetType="SearchResults"&gt;
            &lt;TextBlock Text={Binding PropertyValue}"
        &lt;/DataTemplate&gt;

        &lt;DataTemplate x:Key="ViewModelTemplate" TartgetType="ViewModel"&gt;
            &lt;StackPanel&gt;
                &lt;TextBlock Text={Binding Result.Id}/&gt;
                &lt;StackPanel Orientation="Horizontal"&gt;
                    &lt;ItemsControl ItemsSource={Binding ResultProperties} ItemTemplate="{StaticResource SearchResultTemplate}" /&gt;
                &lt;/StackPanel&gt;
            &lt;/StackPanel
        &lt;/DataTemplate&gt;

    &lt;/Window.Resources&gt;

    &lt;StackPanel&gt;
        &lt;ItemsControl ItemsSource={Binding SearchResults} ItemTemplate="{StaticResource ViewModelTemplate}" /&gt;
&lt;/Window&gt;
</code></pre>

<p>I'm not sure, but I think that the bindings you're using are telling the XAML parser to look for properties of the ViewModel class called <code>ResultProperties</code> and <code>PropertyValue</code>.  The XAML parser doesn't see that they're properties of the object bound to that instance of the collection.  Splitting it up like this should make it plain that the properties belong to the instance that the template is being applied to.</p>
