<blockquote>
  <p>The code is compiling even if I pass a long as the parameter to the get method of the HashMap which is declared to have only Integer as the keys. I was expecting a compilation error here, because I somehow feel this violates the strict typing.</p>
</blockquote>

<p>Did you look at the signature of <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Map.html#get%28java.lang.Object%29"><code>Map.get</code></a>?</p>

<pre><code>V get(Object key)
</code></pre>

<p><em>Any</em> object can be used as the key. There are other Stack Overflow questions about that design decision; I'll find one later.</p>

<blockquote>
  <p>When I pass the long variable containing the error code as the parameter to the get method of the HashMap() the map returns null.</p>
</blockquote>

<p>Yes, it would - because it will be boxed to a <code>Long</code>, and a <code>Long</code> isn't equal to an <code>Integer</code>. So the entry isn't found in the map.</p>

<blockquote>
  <p>When I downcast the same long parameter to an int and pass it to the get method of the hash map, the map returns the proper Enum.</p>
</blockquote>

<p>Yes, it would - because then it will be boxed to an <code>Integer</code>, which will be equal to the appropriate key.</p>

<p>Basically you're being fooled by the fact that you <em>can</em> compare <code>int</code> and <code>long</code> values - that's just the compiler automatically promoting <code>int</code> to <code>long</code> for you; if you think of <code>Integer</code> and <code>Long</code> as entirely separate types, with no automatic conversion between them, the behaviour of your map makes perfect sense.</p>
