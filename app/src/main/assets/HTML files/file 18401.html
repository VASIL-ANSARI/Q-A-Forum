<p>Client-side <code>async</code> (compared to synchronous code) generally improves responsiveness at a slight <em>cost</em> of memory.</p>

<p>Server-side <code>async</code> (compared to synchronous code) generally improves scalability by reducing memory/thread usage. These advantages also apply to client-side <code>async</code> (compared to multithreaded code).</p>

<p>Both of these are extreme generalizations and there are certainly situations where they're wrong.</p>

<p><strong>Update:</strong></p>

<blockquote>
  <p>My observation concludes that if we use Async-Await ..., then it will consume lesser threads.</p>
</blockquote>

<p><code>async</code> / <code>await</code> enable maintainable asynchronous code. By themselves, they don't have anything to do with creating threads. However, they are often used with <code>Task.Run</code> (or <code>Task.Factory.StartNew</code>) to create background tasks.</p>

<blockquote>
  <p>As i am learning async - await, i want to prove its worth by some sort of comparison and solid code.</p>
</blockquote>

<p><code>async</code> and <code>await</code> are compiler transformations. They make it easier to write asynchronous programs - that is all.</p>

<p>If you compare them to synchronous code, then you'll usually see improved responsiveness and/or scalability. If you compare them to existing asynchronous code, then they'll usually be <em>slightly</em> less efficient but more than make up for that in terms of code maintainability.</p>
