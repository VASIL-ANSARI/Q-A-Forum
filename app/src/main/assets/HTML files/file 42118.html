<p>The index <code>i</code> is used twice in different for-loops in your code. Bad copy paste ?</p>

<pre><code>[...]
  for(i=0;i&lt;5;i++)
{

for(i=0;i&lt;a;i++)
{
[...]
</code></pre>

<p>Then you copy the 2nd Ã©lement in the fisrt one, and the loop for go on. The copied second Ã©lÃ©ment will not be check with the 3rd element value.</p>

<p>lets gets an example :</p>

<p>here is the input table AAABD with index : {{A0},{A1},{A2},{B3},{D4}}</p>

<p>for iteration i=0: </p>

<p>test is <code>A0 = A1</code>   => the table becomes {{A1},{A2},{B3},{D4}}</p>

<p>for iteration i=1: </p>

<p>test is <code>A2 != B3</code>   => the table is not changed. You have to redone the test on i=0 once.</p>

<h1>EDIT</h1>

<p>This recursive function shall do it. As it is recursive, it could be greedy.
(( I have nothing to test it right now but I think the code is ok ))</p>

<pre><code>// for null terminated string
void my_function (char*table)
{ 
  int i;
  int j;
  for(i=0;i&lt;strlen(table)-1;i++)
  {
      if(table[i]==table[i+1])
      {
        my_function(table + i + 1);
        for(j=i;j&lt;strlen(table);j++)
        {
            table[j]=table[j+1];
        }
      }
  }
}
</code></pre>

<h1>EDIT 2 : to reply to sp2danny comment</h1>

<pre><code>// for non null terminated string
void my_function (char*table,int *size)
{ 
  int i;
  int j;
  for(i=0;i&lt;*size-1;i++)
  {
      if(table[i]==table[i+1])
      {
        *size -= i+1;
        my_function(table + i + 1,size);
        for(j=i;j&lt;*size;j++)
        {
            table[j]=table[j+1];
        }
      }
  }
}
</code></pre>
