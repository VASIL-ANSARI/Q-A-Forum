<p>Synchronization depends on sharing a lock, so if you see behavior where multiple threads are calling something that's synchronized concurrently, it means they're not using the same lock. It sounds like sync_foo is called on different objects. Using <code>synchronized</code> on the method means that the monitor on the object instance is acquired by a thread that wants to enter the method, so if the method is called on different objects there's no shared lock and nothing stopping a thread from entering the method on one object while another thread is executing the method on a different object.</p>

<p>You could make a class-level lock like this:</p>

<pre><code>public static final Object LOCK = new Object();
</code></pre>

<p>and change your method to</p>

<pre><code>private void sync_foo() {
    synchronized(LOCK) {
        final Logger log = Logger.getLogger(getClass());
        log.info("start");
        log.info("still alive");
        ...
        log.info("finish");
    }
}
</code></pre>

<p>so all the objects that sync_foo is called on will use the same lock regardless of what instance it's called on.</p>
