<p>How about this:</p>

<pre><code># row, column indices of the lower triangle of B
r, c = np.tril_indices_from(B)

# flip the column indices by subtracting them from r, which is equal to the number
# of nonzero elements in each row minus one
B[r, c] = B[r, r - c]

print(repr(B))
# array([[ 1.  ,  0.  ,  0.  ,  0.  ],
#        [ 0.75,  0.25,  0.  ,  0.  ],
#        [ 0.7 ,  0.2 ,  0.1 ,  0.  ],
#        [ 0.1 ,  0.4 ,  0.3 ,  0.2 ]])
</code></pre>

<p>The same approach will generalize to any arbitrary <em>N</em>-dimensional array that consists of multiple lower triangular submatrices:</p>

<pre><code># creates a (200, 20, 4, 4) array consisting of tiled copies of B
B2 = np.tile(B[None, None, ...], (200, 20, 1, 1))

print(repr(B2[100, 10]))
# array([[ 1.  ,  0.  ,  0.  ,  0.  ],
#        [ 0.25,  0.75,  0.  ,  0.  ],
#        [ 0.1 ,  0.2 ,  0.7 ,  0.  ],
#        [ 0.2 ,  0.3 ,  0.4 ,  0.1 ]])

r, c = np.tril_indices_from(B2[0, 0])
B2[:, :, r, c] = B2[:, :, r, r - c]

print(repr(B2[100, 10]))
# array([[ 1.  ,  0.  ,  0.  ,  0.  ],
#        [ 0.75,  0.25,  0.  ,  0.  ],
#        [ 0.7 ,  0.2 ,  0.1 ,  0.  ],
#        [ 0.1 ,  0.4 ,  0.3 ,  0.2 ]])
</code></pre>

<p>For an upper triangular matrix you could simply subtract <code>r</code> from <code>c</code> instead, e.g.:</p>

<pre><code>r, c = np.triu_indices_from(B.T)
B.T[r, c] = B.T[c - r, c]
</code></pre>
