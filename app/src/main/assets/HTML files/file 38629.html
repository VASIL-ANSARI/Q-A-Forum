<p>This <code>const</code> can be used (as pointed by 0x499602D2) to capture <code>const</code> member functions.</p>

<p>Consider the following example :</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

class foo
{
    public:
     void bar1() { cout &lt;&lt; "bar1\n"; }
     void bar2() const { cout &lt;&lt; "bar2\n"; }
};

template &lt;typename T, void (T::*mf)() const&gt;
struct Test
{
   void call(T &amp; obj) { (obj.*mf)(); }
};

int main()
{
  foo f;
  //Test&lt;foo, &amp;foo::bar1&gt; t; // Doesn't compile
  //t.call(f);

  Test&lt;foo, &amp;foo::bar2&gt; t2;
  t2.call(f);
  return 0;
}
</code></pre>

<p>The template <code>Test</code> is able to capture only const member functions (doesn't compile otherwise). You can easily imagine specializations based on constness of member functions, which might be what your code is doing (impossible to tell without more context)</p>

<hr>

<p><strong><a href="http://coliru.stacked-crooked.com/a/6b5f678f8e9c4657" rel="nofollow">Live Demo</a></strong></p>
