<p>What you could do is to write your <code>bar</code> classs as a template class. And as <a href="http://stackoverflow.com/questions/33693670/how-to-not-care-about-class-member-template#comment-55159049">@nwp</a> suggested, you could make a <code>make_bar</code> function as a helper to avoid expliciting your types when creating a <code>bar</code> from a <code>foo</code>, like so :</p>

<pre><code>template &lt;class T1, class T2&gt;
class foo {
    //something here
};

template&lt;class T1, class T2&gt;
class bar {
    public:
        bar()=delete;
        bar(const foo&lt;T1,T2&gt;&amp; a): a(a){}
    private:
        foo&lt;T1, T2&gt; a;
};

template&lt;class T1, class T2&gt;
bar&lt;T1, T2&gt; make_bar(foo&lt;T1,T2&gt; const&amp; f) {
    return bar&lt;T1, T2&gt;{f};
}

int main() {

    auto myFoo = foo&lt;int, double&gt;{};
    auto barintdouble = make_bar(myFoo);

}
</code></pre>
