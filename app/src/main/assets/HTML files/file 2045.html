<p>What you need to pass to <code>Enumerable.Where</code> is a <a href="http://msdn.microsoft.com/en-us/library/bfcke1bz.aspx" rel="nofollow"><code>Predicate&lt;T&gt;</code></a>. A <code>Predicate&lt;T&gt;</code> is a delegate that can eat instances of <code>T</code> and return a bool; you can think of a predicate as representing a property that is either <code>true</code> or <code>false</code> about instaces of <code>T</code>. </p>

<p>Now, there is a larger issue which is that unless you put a constraint on <code>T</code>, the compiler has no way of knowing that <code>T</code> has a publicly readable property named <code>IsActive</code>. Thus, you have to define an interface (or a base class) that both <code>A</code> and <code>B</code> implement (or derive from) and tell the method <code>GetAllActive</code> that <code>T</code> implements (or derives from) this interface (or base class). You can do this by constraining <code>T</code> in the definition of <code>DataAccessBase</code>. Thus:</p>

<pre><code>interface IIsActive {
    bool IsActive { get; set; }
}

class A : IIsActive {
    public bool IsActive { get; set; }
}
class B : IIsActive {
    public bool IsActive { get; set; }
}

public class DataAccessBase&lt;T&gt; where T : class, IIsActive {
    public IList&lt;T&gt; GetAllActive() {
    return dataContext.GetTable&lt;T&gt;()
                      .Where(x =&gt; x.IsActive)
                      .ToList();
    }
}
</code></pre>
