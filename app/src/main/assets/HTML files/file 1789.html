<p>Yes, you are right, this would be a bug if your setter/getters were serializing/deserializing the objects. But this is not the case. Instead you are passing based on reference. </p>

<p>So what's basically happening is that the first line in your example gets the item via the get, and Count is called based on that. Then the seccond line is going out and calling get again, returning the same object, running clear, and then the third line is doing the same as the first.</p>

<p>If you had written your setter/getter something like this, you would have a "bug"</p>

<pre><code>protected IList&lt;Stuff&gt; RelevantSessionData
{
    get
    {
        return (IList&lt;Stuff&gt;) JSON.ConvertFromString(Session["relevant_key"]);
    }
    set
    {
        Session["relevant_key"] = JSON.ConvertToString(value);
    }
}
</code></pre>

<p>In this case, a new object would be created and for each call to the get block. But since your example above is simply passing around the reference to the same object, you're not going to see this "bug". </p>

<p>And I say "bug" since it's not really a bug, it's just more of a misunderstanding of what's happening behind the scenes. </p>

<p>I hope this helps.</p>
