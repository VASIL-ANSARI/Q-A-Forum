<p>There is no build in functionality.
for INT and BIGINT you can use <code>CONVERT(VARCHAR(100),CAST(3 AS VARBINARY(100)),2)</code> to get the hex representation as a string. then you can do a simple search replace as every hex digit represents exactly 4 binary digits. However, with values outside of the BIGINT range there is no standard as to how they are represented internally. You might get the right result or not and that behavior might even change between versions.</p>

<p>There is also no standard as to how negative numbers are represented. Most implementations of integers use the <a href="http://en.wikipedia.org/wiki/Two%27s_complement" rel="nofollow">two's-complement representation</a>. In that representation the top most bit indicates the sign of the number. How many bits you have is a metter of convention and fully dependent on your environment. </p>

<p>In mathematics -3 woud be -11 in binary and not 11111101.</p>

<p>To solve your problem you can either use a CLR function or you go through your number the old fashioned way:</p>

<pre><code>Is it odd? -&gt; output a 1
Is it even? -&gt; output a 0
integer divide by 2
repeat until the value is 0
</code></pre>

<p>This will give you the digits in opposite order, so you have to flip the result. To get the two's-complement representation of a negative number n calculate 1-n, convert the result to binary using the above algorithm but with reversed digits (0 instead of 1 and vice versa). After flipping the digits into the right order prepend with enough 1s to fill your "box".</p>
