<p>Is this what you're looking for:</p>

<p>Â§3.10/7</p>

<blockquote>
  <p>Whenever an lvalue appears in a context where an rvalue is expected, the lvalue is converted to an rvalue; see 4.1, 4.2, and 4.3.</p>
</blockquote>

<p>And I think when you write <code>int y = x</code>, it basically copies the <em>value</em> contained in the object <code>x</code> which is a lvalue, but the <em>value</em> itself is an rvalue, hence the context expects an rvalue. </p>

<p>Â§4.1/2 says,</p>

<blockquote>
  <p>The value contained in the object indicated by the lvalue is the rvalue result.</p>
</blockquote>

<p>Maybe these two quotations clarify your doubt. Correct me if my understanding is wrong. I would like to learn <em>new</em> things.</p>

<hr>

<p>@Tomalak's  comment:</p>

<blockquote>
  <p>My problem with this is that int&amp; y = x; is valid, so in this case of course x may not be an rvalue. I don't know how irrelevant the difference in my example makes that, though</p>
</blockquote>

<p>Well <code>int &amp;y = x</code> does NOT copy the value. It just creates an alias of the object itself. But as I previously said <code>int y = x</code>, basically <strong>copies</strong> the <em>value</em> which is an rvalue. Hence, the context expects an rvalue, as a copying is being done here.</p>
