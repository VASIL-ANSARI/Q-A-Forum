<p>As a possible starting point, the Fisher-Yates shuffle goes like this.</p>

<pre><code>def swap(xs, a, b):
    xs[a], xs[b] = xs[b], xs[a]

def permute(xs):
    for a in xrange(len(xs)):
        b = random.choice(xrange(a, len(xs)))
        swap(xs, a, b)
</code></pre>

<p><s>Perhaps this will do the trick?</p>

<pre><code>def derange(xs):
    for a in xrange(len(xs) - 1):
        b = random.choice(xrange(a + 1, len(xs) - 1))
        swap(xs, a, b)
    swap(len(xs) - 1, random.choice(xrange(n - 1))
</code></pre>

<p></s></p>

<p>Here's the version described by Vatine:</p>

<pre><code>def derange(xs):
    for a in xrange(1, len(xs)):
        b = random.choice(xrange(0, a))
        swap(xs, a, b)
    return xs
</code></pre>

<p>A quick statistical test:</p>

<pre><code>from collections import Counter

def test(n):
    derangements = (tuple(derange(range(n))) for _ in xrange(10000))
    for k,v in Counter(derangements).iteritems():
        print('{}   {}').format(k, v)
</code></pre>

<p><code>test(4)</code>:</p>

<pre><code>(1, 3, 0, 2)   1665
(2, 0, 3, 1)   1702
(3, 2, 0, 1)   1636
(1, 2, 3, 0)   1632
(3, 0, 1, 2)   1694
(2, 3, 1, 0)   1671
</code></pre>

<p>This does appear uniform over its range, and it has the nice property that each element has an equal chance to appear in each allowed slot.</p>

<p>But unfortunately it doesn't include all of the derangements. There are 9 derangements of size 4. (The formula and an example for <em>n=4</em> are given on <a href="https://en.wikipedia.org/wiki/Derangement" rel="nofollow">the Wikipedia article</a>).</p>
