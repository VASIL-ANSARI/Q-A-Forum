<p>Structs are value types, when you pass a struct, it creates a <strong>copy</strong> of the struct. This is especially a problem with mutable structs since when you pass the struct to a method (or get it out of a property) the struct is copied <strong>by value</strong> and then you are modifying the copy, not the original.</p>

<p>The fix is to avoid mutable structs and to use a class instead. Only use structs where the value (of all its fields) is fixed during construction. </p>

<p><strong>Edit</strong></p>

<p>To expand on this a little bit, we can examine the line:</p>

<pre><code>pieceDict[pCode].pCode = pCode;
</code></pre>

<p>What is happening here is that the first part, <code>pieceDict[pCode]</code> returns a <strong>copy</strong> of the value (in the case of a value type), which is then operated on by the <code>.pCode</code> part, which you assign it to <code>pCode</code>, but because you are working on a copy, and not what is stored in the dictionary, it will not be saved. The compiler is smart enough to notice that you are trying to assign to it and that it will be thrown away anyway, so it gives you the error. </p>

<p>In my opinion the error could be better worded, something like <em>"assignment to a copy of a value type does not result in an assignment of the underlying value"</em>, because as a new-ish programmer when it says that the assignment fails because its not a variable is a little confusing. The dictionary is a variable, the item that went in is a variable, so its hard to understand why the value is not a variable.</p>
