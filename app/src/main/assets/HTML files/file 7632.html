<p>It sounds like you just need the <a href="http://msdn.microsoft.com/en-us/library/bb360913.aspx" rel="nofollow"><code>OfType</code></a> method instead:</p>

<pre><code>string store = heart.OfType&lt;int&gt;().Where(item =&gt; item &gt; 5).Count().ToString();
</code></pre>

<p><code>OfType</code> only returns values which are of the approriate type, ignoring others. See my <a href="https://msmvps.com/blogs/jon_skeet/archive/2011/01/13/reimplementing-linq-to-objects-part-33-cast-and-oftype.aspx" rel="nofollow">Edulinq blog post on it</a> for more information.</p>

<p>As Sven shows, you can also use the overload of <code>Count</code> which takes a predicate, to remove the <code>Where</code> call:</p>

<pre><code>string store = heart.OfType&lt;int&gt;().Count(item =&gt; item &gt; 5).ToString();
</code></pre>

<p>(I've changed the variable type given that you're calling <code>ToString</code> at the end... again, you may want to think about this decision. It depends on how you're using it of course.)</p>

<p>However, I'd <em>strongly</em> advise you to use a strongly-typed collection instead of <code>ArrayList</code>. Think about what the collection is meant to hold - it seems odd to hold both strings and integers. What are you trying to do with it?</p>
