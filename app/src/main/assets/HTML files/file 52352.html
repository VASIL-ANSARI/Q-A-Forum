<p>I took the code and removed <code>hwnd</code> - replacing with nullptr and found the following.</p>

<pre><code>    if (_thread.joinable())
        _thread.join();
</code></pre>

<p>This code doesn't work in the thread function <code>TimerThread</code>, so when Stop is called, you get a deadlock exception thrown as explained <a href="http://en.cppreference.com/w/cpp/thread/thread/join" rel="nofollow">cppreference : thread join</a></p>

<p>I think the fix should be to just set _running to false in the function.  But it is not clear what is really being required from the code.</p>

<h2>Other notes</h2>

<p>Also the global timer destruction may occur too late - when globals are destroyed, this is as the C++ runtime is unloading, and a thread::join at this time would probably fail.</p>

<p>An interval would be more effective timing mechanism, where you measured the time before hand and then read it later.</p>

<p>The std::chrono features ways of reading clocks and getting timings.  <a href="http://en.cppreference.com/w/cpp/header/chrono" rel="nofollow">cppreference: chrono</a></p>

<pre><code>auto start = std::chrono::high_resolution_clock::now();
/* do some stuff */
auto end = std::chrono::high_resolution_clock::now();
std::chrono::duration&lt;double&gt; diff = end-start;
</code></pre>
