<p>i think you'd have to multiply with 255 instead of 256 (in some cases). why? because if you multiply a [0,1] value range with 256 you get a [0,256] value range -> 257 individual values -> overflow (largest 0-based 8bit number is 255)</p>

<p>EDIT: seems like a classical 1-off error. if you divide a [0,256] range through 256, you get a [1/256,1] range. eg. </p>

<pre><code>color.r = float(int(real_Position.x) / 256) / 255.0;
</code></pre>

<p>should be the correct calculation in this case. also, if you multiply a [0,1] value with 256 and assign this value to a byte, the result would be the same until you actually hit 1, where the byte would be 0 again. why that? (254/255) * 256 = 254.99 = 254 (because of int rounding), but 1*256=256 (byte range is [0,255]). so everywhere you are converting between color [0,1] floats and bytes, you have to multiply/divide with 255 while everywhere you convert between 8-bit and 16-bit values you have to multiply/divide with 256.</p>

<p>in general equations:</p>

<pre><code>lb=w%256    //lower byte from 16bit
hb=w/256    //higher byte from 16bit
w=lb+hb*256 //16bit from bytes
b=f*255     //byte from [0,1] float (0-&gt;0, 1-&gt;255)
f=b/255.0   //[0,1] float from byte (0-&gt;0, 255-&gt;1)
</code></pre>
