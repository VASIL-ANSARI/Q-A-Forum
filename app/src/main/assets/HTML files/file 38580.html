<p>Using complex optimizers (<a href="http://docs.scipy.org/doc/scipy/reference/optimize.html" rel="nofollow">http://docs.scipy.org/doc/scipy/reference/optimize.html</a>) for such a problem is rather a bad idea.</p>

<p>It looks like a problem which can be quite easily solved in under <code>O(n^2)</code> where <code>n=max(|x|,|y|)</code>, simply:</p>

<ol>
<li>sort <code>x,y,f(x),f(y)</code> creating <code>sorted(x), sorted(y), sorted(f(x)), sorted(f(y))</code></li>
<li>for each <code>x</code> find the positions in <code>sorted(y)</code> for which <code>I^2 &gt;= x^2+y^2</code> holds and similarly for <code>f(x)</code> and <code>sorted(f(y))</code> and <code>V^2 &gt;= f(x)^2 + f(y)^2</code> (two binary searches, as <code>I^2 &gt;= x^2+y^2 &lt;=&gt; |y| &lt;= sqrt(I^2-x^2)</code> so you can find the "barrier"in constant time and then use bin searches to find actual data points which are the closest ones "on the right side of inequality")</li>
<li>Iterate through <code>sorted(x)</code> and for each <code>x</code>:
<ul>
<li>Iterate simultanously through elements of <code>y</code> and <code>f(y)</code> and discard (in this loop) points which are not in borth intervals found in step 2. (linear complexity)</li>
<li>Record argument pairs <code>x_max,y_max</code> for which <code>f(x_max,y_max)</code> is maximized</li>
</ul></li>
<li>Return <code>x_max,y_max</code></li>
</ol>

<p>Total complexity is under quadratic, as step 1 takes <code>O(nlgn)</code>, each iteration of loop in step 2 is <code>O(lgn)</code> so the whole step 2 takes <code>O(nlgn)</code>, loop in step 3 is <code>O(n)</code> and loop in first substep of step 3 is <code>O(n)</code> (but in real life it should be almost constant due to the constraints), which makes the whole algorithm <code>O(n^2)</code> (and in most cases it will behave as <code>O(nlgn)</code>). It also does not depend on the definition of <code>f(x,y)</code> (it uses it as a black box) so you can optimize an arbitrary function is such a way.</p>
