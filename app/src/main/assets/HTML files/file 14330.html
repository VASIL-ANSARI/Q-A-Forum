<p>The short (slightly over-simplified) answer is, "it will fail for anything other than a simple-type-specifier".</p>

<p>5.2.3/1 says:</p>

<blockquote>
  <p>A <em>simple-type-speciï¬er</em> (7.1.6.2) or <em>typename-speciï¬er</em> (14.6) followed
  by a parenthesized <em>expression-list</em> constructs a value of the speciï¬ed
  type given the expression list.</p>
</blockquote>

<p>A <em>simple-type-specifier</em> can be either a one-word name for a type (optionally plus some <code>::</code> stuff for the scope, and/or template arguments which themselves need not be simple type specifiers) or a <code>decltype</code> expression. The possibilities are listed in 7.1.6.2.</p>

<p><code>unsigned int</code> and <code>int*</code> aren't <em>simple-type-specifiers</em>. Any compound type specifier will fail, so cv-qualification, array types, function types, pointer types including pointer-to-function and pointer-to-member would all need a typedef.</p>

<p>Also ruled out are the multi-word type identifiers like <code>unsigned char</code>, <code>long double</code>. For your first example, <code>unsigned</code> would work in place of <code>unsigned int</code>.</p>

<p>A <em>typename-specifier</em> is a type preceded by <code>typename</code>, used in templates to assert that a dependent name is indeed a type, not a data member or member function.</p>

<p>Finally of course, once you get past this restriction the type has to actually be constructible or convertible from the <em>expression-list</em>. So for example you can't create a temporary of function type using this or any other syntax.</p>
