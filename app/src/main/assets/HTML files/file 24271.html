<p><strong>Closures</strong> are your problem here. </p>

<p>Basically, instead of grabbing the value when you create the lambda (in the loop), it grabs it when it needs it. And computers are so fast that by the time that happens, it's already out of the loop. And the value's 3.
Here's an example (don't run it yet):</p>

<pre><code>private void buttonDoSomething_Click(object sender, EventArgs e)
{
    List&lt;Thread&gt; t = new List&lt;Thread&gt;();
    for (int i = 0; i &lt; 3; i++)
    {
        t.Add(new Thread (() =&gt; Console.Write(i)));
        t[i].Start();
    }
}
</code></pre>

<p>Think about what you'd expect the result to be. Would it be <code>012</code> you're thinking?</p>

<p>Now run it.</p>

<p>The result will be <code>333</code>. </p>

<p>Here's some modified code that'll fix it:</p>

<pre><code>private void buttonDoSomething_Click(object sender, EventArgs e)
{
    List&lt;Thread&gt; t = new List&lt;Thread&gt;();
    string[] bla = textBoxBla.Lines;
    for (int i = 0; i &lt; bla.Length; i++)
    {
        int y = i; 
        //note the line above, that's where I make the int that the lambda has to grab
        t.Add(new Thread (() =&gt; some_thread_funmction(bla[y]))); 
        //note that I don't use i there, I use y.
        t[i].Start();
    }
}
</code></pre>

<p>Now it'll work fine. This time the value goes out of scope when the loop finishes, so the lambda has no choice but to take it before the loop finishes. That will get you your expected result, and no exception.</p>
