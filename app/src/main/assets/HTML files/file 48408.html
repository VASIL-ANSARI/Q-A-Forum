<p>You can further develop your idea using a tagged union:</p>

<pre><code>enum typeNode {TERMINAL_NODE, FUNCTION_NODE};

class node
{
    union
    {
      int i;
      func f;
    };

    typeNode type;

    // ...
};
</code></pre>

<p>Only one of the types can be in use at any one time and the <code>type</code> field explicitly indicates which one is in use.</p>

<p>Along this way you could also use <a href="http://www.boost.org/doc/libs/1_58_0/doc/html/variant.html" rel="nofollow">boost::variant</a> in place of the anonymous union.</p>

<p>A different approach is using a <code>symbol</code> base class:</p>

<pre><code>class symbol
{
public:
  virtual int eval(int [] = nullptr) = 0;

  // ...
};

class terminal : public symbol
{
public:
  virtual int eval(int []) override;
  {
    return i;
  }

  // ...

private:
  int i;
};

class function1 : public symbol
{
public:
  virtual int eval(int params[]) override;
  {
    return f(params[0], params[1]);
  }

  // ...

private:
  func f;
}
</code></pre>

<p>and the <code>node</code> class is something like:</p>

<pre><code>class node
{
  node *left, *right, *parent;
  symbol *s;

  // ...
};
</code></pre>

<p>Since the <code>function</code> class is stateless, you need to pass some parameters to the <code>eval</code> function. This is an annoyance but helps to keep simple other parts of the genetic program (e.g. building the tree, tree recombination...).</p>
