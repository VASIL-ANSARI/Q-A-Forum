<p>Google states that: "Some people, including some textbook authors, recommend using <code>unsigned</code> types to represent numbers that are never negative. This is intended as a form of self-documentation."</p>

<p>I personally use <code>unsigned int</code>s as index parameters.</p>

<pre><code>int foo(unsigned int index, int* myArray){
    return myArray[index];
}
</code></pre>

<p>Google suggests: "Document that a variable is non-negative using assertions. Don't use an unsigned type."</p>

<pre><code>int foo(int index, int* myArray){
    assert(index &gt;= 0);
    return myArray[index];
}
</code></pre>

<p><em>Pro for Google:</em> If a negative number is passed in debug mode my code will hopefully return an out of bounds error. Google's code is guaranteed to assert.</p>

<p><em>Pro for me:</em> My code can support a greater size of <code>myArray</code>.</p>

<p>I think the actual deciding factor comes down to, how clean is your code? If you clean up <em>all</em> warnings, it will be clear when the compiler warns you know when you're trying to assign a signed variable to an unsigned variable. If your code already has a bunch of warnings, the compiler's warning is going to be lost on you.</p>

<p>A final note here: Google says: "Sometimes gcc will notice this bug and warn you, but often it will not." I haven't seen that to be the case on Visual Studio, checks against negative numbers and assignments from signed to unsigned are always warned. But if you use gcc you might have a care.</p>
