<p>I'll try to answer to both your questions.<br>
Regarding the first question (the filtered selected index vs the real list index):</p>

<ul>
<li>I assume that you bound the table using BeansBinding, via <code>createJTableBinding</code>. So, the client-side filtering might be applied through the use of swing TableRowSorter and RowFilter. Am I right ? if so, you could use the method<br>
<code>int row = myTable.convertRowIndexToModel(myTable.getSelectedRow());</code><br>
to convert the selected row in the filtered view to the actual selected row in the model.</li>
</ul>

<p>For the second question (bean to keep the selected item of table)</p>

<ul>
<li>You could also create a binding using <code>this</code> as the source/target object, and create a property <code>selectedElement</code> in the class containing the table. Thus, you won't need another class. The code will be : <code>createAutoBinding(UpdateStrategy.READ_WRITE, myTable,<br>
ELProperty.create("${selectedElement}"), this, BeanProperty.create("selectedElement"), "selectedElementBinding");</code><br>
(note also that READ_WRITE binding is not really used, as beans binding does not support changing the selected  element from the bound property)</li>
</ul>
