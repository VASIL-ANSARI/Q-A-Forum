<p>What CR is trying to say is that in:</p>

<pre><code>using (DataTable dt =  DataAccess.ExecuteDataTable ... 
</code></pre>

<p>you are not <em>using</em> the declaration of <code>dt</code>; the variable remains untouched after.</p>

<p>The refactor button will transform this to</p>

<pre><code>using ( DataAccess.ExecuteDataTable ... 
</code></pre>

<p>i.e. it will still be a <code>using</code> statement but you won't have a variable to refer to it.</p>

<p>While you're doing that, you can do some Inline Result transformations, yielding:</p>

<pre><code>    try
    {
        using (DataAccess.ExecuteDataTable("[dbo].[udp_Customers_ups]",
            DataAccess.Parameter(CustomerIdColumn, CustomerId),
            DataAccess.Parameter(CodeColumn, Code),
            DataAccess.Parameter(CompanyColumn, Company),
            DataAccess.Parameter(IsDeletedColumn, IsDeleted),
            DataAccess.Parameter(LastUpdatedColumn, LastUpdated),
            DataAccess.Parameter(UpdatedByColumn, UpdatedBy)))
            return true;
    }
    catch
    {
        return false;
    }
</code></pre>

<p>I'll let others question whether wrapping calls like this in a <code>catch</code> block is a good idea...</p>
