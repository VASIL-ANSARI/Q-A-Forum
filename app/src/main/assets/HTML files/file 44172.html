<p>In the first version, you're binding the <code>this</code> value, but <code>forEach</code> passes 3 arguments to its callback, which are the item, the index and the original array.</p>

<p>In the second version, you're manually passing only the first argument given to the callback, and ignoring the last two.</p>

<hr>

<p>So (for illustration of the issue) you can force your second version to behave like the first like this...</p>

<pre><code>    this.children.forEach(function(child, idx, arr){
        target.append(child, idx, arr); // Passing all 3 args
    });
</code></pre>

<p>Now it's clearer that <code>.append()</code> is receiving 3 values on each iteration.</p>

<p>There's not really any way around this using <code>.bind()</code>. If <code>.append()</code> were made to only recognize the first argument passed, then it would work.</p>

<hr>

<p>One thing you could do would be to create your own custom <code>.bindN</code> method. Instead of being able to bind <code>this</code> and individual arguments, it could bind <code>this</code> and receive a "limiter" that will limit the number of arguments it's allowed to receive.</p>

<p>It could look like this:</p>

<pre><code>Function.prototype.bindN = function(thisArg, n) {
    var origFunc = this;
    return function() {
        return origFunc.apply(thisArg, Array.prototype.slice.call(arguments, 0, n));
    }
};
</code></pre>

<p>Then use it like this:</p>

<pre><code>this.children.forEach(this.target.append.bindN(this.target, 1));
</code></pre>
