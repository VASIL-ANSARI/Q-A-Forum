<p>There is no real "pure unit test" way of testing *ReflectionClass**. Normally, you would do a unit test by providing a <strong>mocked</strong> instance of that class to your production code; then you could use the mocking framework to verify that the expected method was called.</p>

<p>But in your case, you created code that is simply <strong>hard</strong> to test (if you want to learn how to address that part, you might want to watch these <a href="https://www.youtube.com/playlist?list=PLD0011D00849E1B79" rel="nofollow">videos</a>). You are basically calling "new" directly in your production code; thus there is  no way to insert a mocked object. And beyond that, you also can't mock those reflection methods.</p>

<p>The only option to <strong>maybe</strong> get this code tested would be to use Mokito together with PowerMock. But I am not an expert in that area, and can't promise you that it will work. </p>

<p>My recommendation to you: step back first and figure if you can get <strong>away</strong> from using reflection, or at least: to separate concerns here. Because as said: your <strong>production design</strong> looks <strong>weird</strong>; and instead of spending hours to get that somehow unit tested; you should rather spent a fraction of that time to improve your design! "Hard to test" typically means "design could be improved"!</p>

<p>Meaning: first you create an <strong>interface</strong> that denotes the function that you want to test. Then you separate your production code of <em>ReflctionClass</em>, like:</p>

<ol>
<li>One part is responsible for providing an instance of that interface (and that code could be using <strong>reflection</strong> to do its job, if that is really required)</li>
<li>The other part then calls the method(s) you want to be called on that interface object.</li>
</ol>

<p>By doing so, you get <strong>two</strong> parts that you can test independently of each other!</p>

<p>Edit: what I mean by "bad design" - why are you using reflection to do both - <em>object creation</em> and <em>method invocation</em>? You see, you could simply cast that created object to its correct class (at least if you have an interface defined there) and then do a ordinary method call on that typed object.</p>
