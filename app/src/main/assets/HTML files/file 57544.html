<p>With <code>df</code> as the dataframe and the column <code>a</code> already being sorted, here's an approach -</p>

<pre><code>df[np.append(np.diff(df['a'])&gt;0,True)]
</code></pre>

<p>The basic idea is that we perform differentiation along the sorted column <code>a</code> and look for positive change with <code>(&gt;0)</code>, giving us a boolean array. The <code>true</code> elements in the boolean array would signal the end of the "group" in that column. Since, there is no change for the last element of the last group, we need to append with a <code>True</code> element to that boolean array at the end. Finally, index <code>df</code> with such a boolean array to select rows off it and give us the desired output.</p>

<p>Another approach could be suggested with <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.unique.html" rel="nofollow"><code>np.unique</code></a> using its optional argument <code>return_index</code> that would give us each group's first occurring element's index. So, to make it work for the last element, just flip the column <code>a</code>, use <code>np.unique</code> and get the first occurring indices and then subtract them from the total number of rows in <code>df</code>. Finally, index into <code>df</code> with those for the final output. Thus, the implementation would be -</p>

<pre><code>df.iloc[df.shape[0] - np.unique(df['a'][::-1],return_index=True)[1] - 1]
</code></pre>

<p>Sample run -</p>

<pre><code>&gt;&gt;&gt; df
    a   b   x
0   1  26  46
1   1  17  32
2   1  12  65
3   1  31  96
4   1  34  10
5   1   7  80
6   1  64  50
7   1   0  34
8   1  93  28
9   2  18  92
10  2  59  22
11  2  87  31
&gt;&gt;&gt; df[np.append(np.diff(df['a'])&gt;0,True)]
    a   b   x
8   1  93  28
11  2  87  31
&gt;&gt;&gt; df.iloc[df.shape[0] - np.unique(df['a'][::-1],return_index=True)[1] - 1]
    a   b   x
8   1  93  28
11  2  87  31
</code></pre>
