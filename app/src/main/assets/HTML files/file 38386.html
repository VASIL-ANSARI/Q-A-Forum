<pre><code>template &lt;typename T&gt; class Movie;

template&lt;class T&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Movie&lt;T&gt;&amp; movie);

template&lt; class T&gt;
class Movie {
  friend std::ostream&amp; operator&lt;&lt; &lt;T&gt;(std::ostream&amp; os, const Movie&lt;T&gt;&amp; movie);
};

template&lt;class T&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Movie&lt;T&gt;&amp; movie){
    return os;
}
</code></pre>

<p>In your original code, you befriend a non-template function that just happens to take the right instantiation of <code>Movie&lt;&gt;</code> as a parameter. So, every time a <code>Movie&lt;T&gt;</code> is instantiated, a corresponding non-template <code>operator&lt;&lt;</code> is declared (but not defined) in the enclosing namespace scope. <code>friend</code> declarations are strange this way.</p>

<p>In addition, you declare and define a function template named <code>operator&lt;&lt;</code> (which is not a friend of any instantiation of <code>Movie</code>). However, overload resolution prefers non-templates, other things equal.</p>
