<p>The issue is in your <code>move()</code> method, you always fail in the last case(<code>else if (snake.contains(newPoint))</code>), because the new point you've created is always inside of your current snake.</p>

<p>I'm working on a solution for you.</p>

<p><strong>EDIT:</strong></p>

<p>This section is wrong:</p>

<pre><code>if(newPoint.equals(fruit))
{
    score += 10;
    Point addPoint = (Point) newPoint.clone();
    //the snake has hit the fruit
    switch(direction){
    case Direction.North:
        newPoint = new Point (head.x, head.y -1);
        break;
    case Direction.South:
        newPoint = new Point(head.x,head.y +1);
        break;
    case Direction.West:
        newPoint = new Point(head.x -1,head.y);
        break;
    case Direction.East:
        newPoint = new Point(head.x + 1,head.y);
        break;
    }
    snake.push(addPoint);
    PlaceFruit();
}
</code></pre>

<p><strong>EDIT 2:</strong>  Brainless Box is right that the points and addPoint should be in the check for hitting the fruit.  I also added some logic to handle the fruit a bit better.</p>

<pre><code>public void Move(){ //directions

    Point head = snake.peekFirst(); //head of snake, allows us to have body follow in chronological order
    Point newPoint = head;

    snake.remove(snake.peekLast()); //removes end of tail


    Point addPoint = (Point) newPoint.clone();
    switch(direction) {
    case Direction.North:
        newPoint = new Point (head.x, head.y -1);
        break;
    case Direction.South:
        newPoint = new Point(head.x,head.y +1);
        break;
    case Direction.West:
        newPoint = new Point(head.x -1,head.y);
        break;
    case Direction.East:
        newPoint = new Point(head.x + 1,head.y);
        break;
    }

    //the snake has hit the fruit
    if(newPoint.equals(fruit))
    {
        score += 10;
        fruit = null;
        snake.push(addPoint);
    }
    else if (newPoint.x &lt; 0 || newPoint.x &gt; (gridWidth - 1)){
        //we went out of bounds, reset game
        GenerateDefaultSnake();
        return;
    }
    else if (newPoint.y &lt; 0 || newPoint.y &gt; (gridHeight - 1 )){
        //we went out of bounds, reset game
        GenerateDefaultSnake();
        return;
    }
    else if (snake.contains(newPoint)){
        //we ran into ourselves, reset game
        GenerateDefaultSnake();
        return;
    }

    //if we reach this point of the game, we are still good 
    PlaceFruit();
    snake.push(newPoint); //pushes all points one point ahead when you eat fruit and adds fruit that you ate at the end
}
</code></pre>

<p>In addition to that, add <code>if (fruit != null) return;</code> as the first line of your <code>PlaceFruit()</code> method.</p>
