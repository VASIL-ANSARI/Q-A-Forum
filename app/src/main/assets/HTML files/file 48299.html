<p>You can write a comparator to sort the elements with same <code>num</code>. This comparator will actually depend upon the first list.</p>

<p>First convert your first list  <code>['A', 'Z', 'D', 'E', 'B', 'H', 'C']</code> to map.</p>

<pre><code> map - &gt; [A,1] [Z,2] ......[C,7]
</code></pre>

<p>Once you get the sorted list like </p>

<pre><code> list -&gt; [{id:D, num:5},{id:A,num:5}, {id:C,num:3}, {id:Z,num:3}]
</code></pre>

<p>Follow this:</p>

<pre><code>result;
currentIndex=0;
while currentIndex &lt; list.size()
   currentNum = list.get(currentIndex).getNum();
   while(currentIndex &lt; lis.size() &amp;&amp; list.get(currentIndex).getNum() == currentNum)
          add current item to currentList
          currentIndex++;
   Collections.sort(currentList,new CustomComparator());
   result.addAll(currentList)
</code></pre>

<p>Your comparator will be :</p>

<pre><code>  int compare(obj1,obj2){
     if(map.get(obj1.getId() &lt; map.get(obj1.getId())
         return -1;
     else if map.get(obj1.getId() &gt; map.get(obj1.getId()
          return 1;
     else return 0;
  }
</code></pre>
