<p>First, I'll recommend testing out different possibilities using LINQPad, which is free and awesome.</p>

<p>I can't quite remember what you can do from the table adapter, but you should be able to use the DataSet to get at the data you want, e.g.</p>

<pre><code>string spec = myDataSet.MyTable.Rows[0] // or FindBy... or however you are choosing a row
    .Specification;
</code></pre>

<p>So you might be able to do</p>

<pre><code>foreach(var row in myDataSet.MyTable.Rows) {
    string spec = row.Specification;
    ...
}
</code></pre>

<p>Or</p>

<pre><code>return (from row in myDataSet.Specification
    select new ClassSpecification()
    {
        Specification = row.Specification,
        SpecificationType = row.SpecificationType,
        StatusChange = row.StatusChange,
        Spec = row.Spec,
    }).ToList&lt;ClassSpecification&gt;();
</code></pre>

<p>Or even</p>

<pre><code>return myDataSet.Specification.Cast&lt;ClassSpecification&gt;()
</code></pre>

<p>Not sure if the last one will work, but you can see that there are several ways to get what you want. Also, in my tests the row is strongly typed, so you shouldn't need to create a new class in which to put the data - you should just be able to use the existing "SpecificationRow" class. (In fact, I believe that this is the <a href="http://blog.decayingcode.com/2009/02/anti-pattern-anemic-domain-model.html" rel="nofollow">anemic domain model anti-pattern</a>.)</p>
