<p>OK, finally I have found a workaround.</p>

<ol>
<li>I have a web page encoded in UTF-8 (this will be very important on some next steps);</li>
<li>Generate the signature:
<ul>
<li>If the user uses Mozilla/Firefox/Chrome - the signature is generated using the <code>window.crypto</code>. For more information read <a href="http://docs.oracle.com/cd/E19957-01/816-6152-10/index.htm" rel="nofollow">this</a></li>
<li>If the user uses Internet Explorer - the signature is generated using the CAPICOM (Crypot Application Interface COM object). For more information read read <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa375732%28v=vs.85%29.aspx" rel="nofollow">MSDN</a>
Both - <code>window.crypto</code> and CAPICOM are not very well documented for web using (CAPICOM is not only for web!)</li>
</ul></li>
<li>The text string and the signature are being sent to the webserver by POST request.</li>
<li>The sever (Linux, Apache and PHP) have to verify the signature.</li>
</ol>

<p>Now the problems:</p>

<ol>
<li>The <code>openssl_verify()</code> function of PHP is also not well documented and always returns zero - signature not valid.</li>
<li>The CMD tool openssl also is not validating the signature.</li>
<li>Because my web server requires SSL certificate authentication I wanted that the user signs the text string with the same certificate he is logged in.</li>
</ol>

<p>So what is the workaround:</p>

<ol>
<li>I found that CAPICOM is converting the signed string to UTF-16LE before signing it. Unfortunately the webbrowser sends the text string to the webserver encoded in UTF-8. It means you have to convert the string from UTF-8 to UTF-16LE before verifying the signature. But this is valid only if the signature was generated by CAPICOM.</li>
<li>The openssl CMD tool is working proper now. The difference between the CMD tool and the PHP function are:
<ul>
<li>The signature and the source are sent to PHP function as strings. In case of using the CMD tool the signature and the source are sent as file paths. So if you are using the CMD instead of PHP function you have first to save the signature and the source as files. Remember to convert the encoding if needed.</li>
<li>The PHP function expects as a parameter to receive the public key of the signer. So before this you have to check if the certificate is issued by a trusted Certificate Authority (CA). Instead - the CMD tool expects as a parameter to receive a file which contains a list of root certificates of trusted Certificate Authorities. This means - you have to check the signer before verifying.</li>
</ul></li>
<li>It seems that under Firefox/Mozilla/Chrome browsers it is not possible to limit the user exactly which certificate to use for signing. But it is possible to limit the options. Of course this is not documented at all (or I didn't find any proper information about this). So the <code>signText()</code> function expects a third parameter which must be the trusted Certificate Authority names. First I expected that this must be the CN of the issuer of the client's certificate. But actually it is not. It must be all the issuer string separated with comas like: <code>"C=Country,ST=State,L=Location,O=Organization,CN=CommonName,STREET=Address"</code> Unfortunately this string is slightly different from the issuer string from openssl which looks like <code>issuer=/streetAddress=Address/CN=CommonName/O=Organization/L=Location/ST=State/C=Country</code>. If someone have a Firefox under Linux it will be very interesting to check if this string is formatted the same way. I don't know how to separate more CA names in a single string.</li>
<li>Under Internet Explorer, using CAPICOM it is possible to send only one certificate object to the signing object so it will not open the dialog to select a certificate from a list. You can find the proper certificate by comparing the root certificate fingerprint (A SHA1 hash of the BASE64 65 chr/line encoded certificate excluding the header and footer) and the serial number of the certificate. Just read the MSDN it is well documented.</li>
</ol>

<p>Now. What my source code looks like:</p>

<ol>
<li>If the signature was generated by CAPICOM of <code>window.crypto</code> (I receive an additional parameter from the webbrowser how the signature was generated) If CAPICOM is used I convert the source data like this: <code>$_POST['source'] = iconv('UTF-8', 'UTF-16LE', $_POST['source'])</code></li>
<li>I generate 2 temporary files. The names of the files can be generated using the PHP function <a href="http://php.net/manual/en/function.uniqid.php" rel="nofollow">uniqid()</a>. The default temp directory can be found using the <a href="http://php.net/manual/en/function.sys-get-temp-dir.php" rel="nofollow">sys_get_temp_dir()</a>.</li>
<li>The source file is saved exactly as received from the POST array. If the signature was generated by CAPICOM it must be converted to UTF-16LE.</li>
<li>The signature comes from the web browser BASE64 encoded. Do not decode it. Just save it in a new file and add a special header and footer like this: <code>"-----BEGIN PKCS7-----\n".$_POST['signature']."\n-----END PKSC7-----"</code> Note that the header and footer must be on separate lines. The lines separator must be only \n (ASCII #10) not \r (ASCII #13) of \r\n (ASCII #13#10).</li>
<li>You must have a file which contains all trusted CA root certificates. The format of this file must be as follows:
<ul>
<li>A header "-----BEGIN CERTIFICATE-----"</li>
<li>BASE64 encoded certificate</li>
<li>A footer "-----END CERTIFICATE-----"</li>
<li>empty line</li>
<li>If you have more than one trusted CA root - each certificate must start with a header and end with a footer string. All certificates are stored in a single file</li>
</ul></li>
<li>Run the CMD tool openssl using next parameters:
<ul>
<li><code>smime</code> - to use the SMIME function of the CMD tool</li>
<li><code>-verify</code> - to do a verification</li>
<li><code>-in filepath</code> - the path to the signature file created in step 4</li>
<li><code>-inform PEM</code> - the forat of the signature is BASE64 encoded file with header and footer</li>
<li><code>-binary</code> - prevents translation of the source from binary to text</li>
<li><code>-content filepath</code> - the path to the source file created in step 3</li>
<li><code>-CAfile filepath</code> - the path to the trusted CA root certificates file created in step 5
So the final command looks like this: <code>openssl smime -verify -in file.pem -inform PEM -binary -content source.txt -CAfile root.pem</code></li>
</ul></li>
<li>Now call this from PHP using the <a href="http://bg2.php.net/manual/en/function.shell-exec.php" rel="nofollow">shell_exec()</a> function and read the output.
<ul>
<li>If the output string starts with <code>Verification successful</code> - the signature is OK</li>
<li>If the output string starts with <code>Verification failure</code> - the signature is not OK</li>
<li>If the output string is different - some error have occurred. The error description is stored in the output string.</li>
</ul></li>
</ol>

<p>The above works for me. Unfortunately openssl, CAPICOM and <code>window.crypto</code> are very tricky and it is always possible that a problem occurs. Hope this will help somebody.</p>

<p>Best Regards</p>
