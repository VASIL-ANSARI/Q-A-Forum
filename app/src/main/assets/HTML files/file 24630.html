<p>Try replacing <code>struct tuple *arr;</code> with <code>struct tuple arr[5];</code> or perhaps <code>struct tuple arr[sizeof(num)/sizeof(struct tuple)];</code>.  When you declare <code>arr</code> as a pointer, it doesn't allocate any space for the array it's pointing to.  When you declare it as an array, it will decay to a pointer in the <code>memcpy</code> call and blit the int array over top of the stack-(or static-)allocated struct array.</p>

<p>Alternatively, you could initialize <code>arr</code> with a call to <code>malloc(sizeof(num))</code>, but be sure to match such a call with a call to <code>free()</code>.</p>

<p>Also, as pointed out by comments, you need to pass <code>arr</code> and <code>num</code> rather than <code>&amp;arr</code> and <code>&amp;num</code>.  You want to copy the data, not the pointers (although it may be that <code>&amp;num</code> is equivalent to <code>num</code> as a pointer, in this case).</p>
