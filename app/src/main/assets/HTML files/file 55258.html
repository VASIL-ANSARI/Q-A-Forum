<p>The problem is not the ViewHolder. The problem is that you are not taking into account what happens when your view is recycled.</p>

<p>Suppose for position <code>0</code> you add two <code>Light</code>s to the <code>Relativelayout</code>. Then the user scrolls and the view gets recycled to another position (let's say position <code>10</code>). The <code>RelativeLayout</code> you are given already has two <code>Light</code>s in it before you do anything.</p>

<p>You either need to remove all the previous <code>Light</code>s first, or you need to be able to re-use ones that are there (and still you might have to remove some in case the row you're creating has fewer <code>Light</code>s than are already present).</p>

<p>The <code>TextView</code> is not repeated because you are not creating a <code>TextView</code> every time the view is recycled; you are only creating it when a new row is being inflated.</p>

<hr>

<p>A few other suggestions:</p>

<ul>
<li>There should be no reason to call <code>notifyDataSetInvalidated()</code> and <code>notifyDataSetChanged()</code> inside of <code>getView()</code>.</li>
<li>I discourage the use of holding lists of <code>View</code>s (in this case, <code>Light</code>s) in your data model. You don't have a clear separation between data and presentation, and I think it will only complicate your code. It would be easier to just store how many lights a Track needs and handle the actual <code>View</code>s separately.</li>
<li>I would also try to avoid creating, adding, and removing <code>View</code>s inside of <code>getView()</code>. For instance, if you know there's a small, limited number of lights a Track can have (suppose it's five), then it's easy enough to have that many corresponding views in the row layout already and just toggle their visibility appropriately. Or, you can make a custom <code>View</code> that knows how to draw up to that number of lights and you just change the number inside of <code>getView()</code>.</li>
</ul>
