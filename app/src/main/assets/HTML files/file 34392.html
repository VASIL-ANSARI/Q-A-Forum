<p>There's two major parts to this. First, ciphering a single letter; and second, applying that to the whole string. We'll start with the first one.</p>

<p>You said you had a list with the alphabet in it. Suppose, too, that we have a letter.</p>

<pre><code>&gt;&gt;&gt; letter = 'F'
</code></pre>

<p>If we want to replace that letter with the letter two spaces down in the alphabet, first we'll probably want to find the numerical value of that letter. To do that, use <code>index</code>:</p>

<pre><code>&gt;&gt;&gt; alphabet.index(letter)
5
</code></pre>

<p>Next, you can add the offset to it and access it in the list again:</p>

<pre><code>&gt;&gt;&gt; alphabet[alphabet.index(letter) + 2]
'H'
</code></pre>

<p>But wait, this won't work if we try doing a letter like <code>Z</code>, because when we add the index, we'll go off the end of the list and get an error. So we'll wrap the value around before getting the new letter:</p>

<pre><code>&gt;&gt;&gt; alphabet[(alphabet.index('Z') + 2) % len(alphabet)]
'B'
</code></pre>

<p>So now we know how to change a single letter. Python makes it easy to apply it to the whole string. First putting our single-letter version into a function:</p>

<pre><code>&gt;&gt;&gt; def cipher_letter(letter):
...     return alphabet[(alphabet.index(letter) + 2) % len(alphabet)]
...
</code></pre>

<p>We can use <code>map</code> to apply it over a sequence. Then we get an iterable of ciphered characters, which we can join back into a string.</p>

<pre><code>&gt;&gt;&gt; ''.join(map(cipher_letter, 'HELLOWORLD'))
'JGNNQYQTNF'
</code></pre>

<p>If you want to leave characters not in <code>alphabet</code> in place, add a test in <code>cipher_letter</code> to make sure that <code>letter in alphabet</code> first, and if not, just <code>return letter</code>. VoilÃ .</p>
