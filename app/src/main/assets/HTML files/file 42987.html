<p><code>cast</code> can be translated to <code>resolve</code>. <code>defer</code> should <a href="http://stackoverflow.com/q/23803743/1048572">indeed not be used</a>.</p>

<p>You'd create your loop only by chaining and nesting <code>then</code> invocations onto an initial <code>Promise.resolve(undefined)</code>.</p>

<pre><code>function promiseWhile(predicate, action, value) {
    return Promise.resolve(value).then(predicate).then(function(condition) {
        if (condition)
            return promiseWhile(predicate, action, action());
    });
}
</code></pre>

<p>Here, both <code>predicate</code> and <code>action</code> may return promises. For similar implementations also have a look at <a href="http://stackoverflow.com/q/24660096/1048572">Correct way to write loops for promise.</a> Closer to your original function would be</p>

<pre><code>function promiseWhile(predicate, action) {
    function loop() {
        if (!predicate()) return;
        return Promise.resolve(action()).then(loop);
    }
    return Promise.resolve().then(loop);
}
</code></pre>
