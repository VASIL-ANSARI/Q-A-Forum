<p>In general, bit fields are poorly defined in C and should be avoided if possible. Due to memory padding, endianness etc. it is hard to tell how the bits will be aligned in memory. But to adress some specifics of your code: </p>

<p>First of all you have to change the structure members to <code>unsigned char</code> or <code>unsigned int</code>, otherwise you will loose one bit for representing the sign.
The <code>tft_op</code>-member is only three bits wide, but you try to assign a value which requires 4 bits (0x8 = 0b1000). It ends up being assigned three zeros in memory (on this machine anyway, this again will depend on the endianness etc). It successfully sets the <code>e_bit</code> to 1. The <code>no_of_pkt</code> has the same problem as <code>tft_op</code>, 0x10 (=0b10000) needs five bits, but the field is only 4 bits wide. Hence that member is assigned zeros. In the end your bit field looks like this: <code>000:1:0000</code>, or <code>0001000</code>, or <code>0x8</code>.</p>
