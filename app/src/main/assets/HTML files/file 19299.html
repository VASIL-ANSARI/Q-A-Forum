<p>If you add a reference table, you create an n:n relationship, which you don't want.</p>

<p>So just add a <code>parent_id</code> to the table. 
Make it nullable so you can define a category as the root. </p>

<p>Everything you want to select is quite easy, except for the <strong>child tree</strong>, but an extra table won't help with that. In Oracle you got <code>connect by</code> to select tree-like data, but MySQL unfortunatly doesn't support that, although alternative solutions are often <a href="http://stackoverflow.com/questions/5688376/mysql-select-tree-parent-ids">requested and provided</a>.</p>

<p>There are some obstacles:</p>

<ol>
<li><p>Since you cannot make <code>parent_id</code> unique (multiple childs can have the same parent), you will have to add a trigger to enforce only one category being the root, although maybe you can live without that check for the moment.</p></li>
<li><p>You could theoretically create a loop: Make a the parent of b, b the parent of c, and c the parent of a. To check if this is the case, you should follow the path to the root. If on that path you'll find any category twice, you're in trouble. I think you could use a trigger to validate this as well, although maybe you can live without that check for the moment. It all depends on how you edit your data, but if you are going to query a full tree, you don't want to get into endless loops because of corrupt data.</p></li>
</ol>
