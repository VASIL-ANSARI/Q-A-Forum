<p>If specified, it's under their constructor and (if assignable) assignment operator subclause. For <code>shared_ptr</code> we have:</p>

<p><code>Â§20.7.2.2.1 [util.smartptr.shared.const]</code></p>

<pre><code>shared_ptr(shared_ptr&amp;&amp; r) noexcept;
template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
</code></pre>

<blockquote>
  <p>p20 <em>Remark:</em> The second constructor shall not participate in overload resolution unless <code>Y*</code> is convertible to <code>T*</code>.<br>
  p21 <em>Effects:</em> Move-constructs a <code>shared_ptr</code> instance from <code>r</code>.<br>
  p22 <em>Postconditions:</em> <code>*this</code> shall contain the old value of <code>r</code>. <code>r</code> shall be <em>empty</em>. <code>r.get() == 0</code>.</p>
</blockquote>

<p>The assignment operators of <code>shared_ptr</code> are basically describes by copy-and-swap with a temporary constructed from the (moved if rvalue) argument:</p>

<p><code>Â§20.7.2.2.3 [util.smartptr.shared.assign]</code></p>

<pre><code>shared_ptr&amp; operator=(shared_ptr&amp;&amp; r) noexcept;
template&lt;class Y&gt; shared_ptr&amp; operator=(shared_ptr&lt;Y&gt;&amp;&amp; r) noexcept;
</code></pre>

<blockquote>
  <p>p4 <em>Effects:</em> Equivalent to <code>shared_ptr(std::move(r)).swap(*this)</code>.<br>
  p5 <em>Returns:</em> <code>*this</code>.</p>
</blockquote>

<p>If not specified, <a href="http://stackoverflow.com/a/8522879/500104">what @AProgrammer said</a> applies.</p>
