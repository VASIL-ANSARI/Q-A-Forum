<p>Yes, you can stand up the old store with the old model and then fetch data out of it and manually insert it into the new stack.  Then delete the old store afterwards.  The actual workflow would be:</p>

<ul>
<li>New model is a completely separate file</li>
<li>New store is a completely separate file (new file name)</li>
</ul>

<p>Then:</p>

<ol>
<li>Look for old file name on disk.  If it doesn't exist just stand up the stack</li>
<li>Stand up old stack.</li>
<li>Stand up new stack.</li>
<li>Copy data from old stack to new stack.</li>
<li>Save new stack.</li>
<li>Release old stack and delete old store file from disk.</li>
</ol>

<p>No migration needed.</p>

<blockquote>
  <p>i added old model file. then in the psc method, i detect if compatible and if not, stand up old stack, initiating model and psc both pointing to old one i just added and then creating context. added old class files for entity i need and fetched just the favorites and it worked! i know i can create new objects and insert to new stack, but what's the best way to save the new stack and release old when done? i still seem to be able to fetch even after removeitematurl. and is app delegate best place for all this? </p>
</blockquote>

<p>First, the AppDelegate is <strong>NOT</strong> the place for this.  Create a <code>DataController</code> that subclasses <code>NSObject</code>.  Put all your Core Data code there and then pass that <code>DataController</code> around.</p>

<p>Next, you are not looking for a migration state.  You are looking for files on disk with <code>NSFileManager</code>.  If the old file exists then stand up the old store and the new store, copy data over.  Then remove the old file.</p>

<p>To release the old stack, just set the references (MOM, PSC and MOC) to <code>nil</code>.  ARC will remove them from memory.</p>
