<p>yes.</p>

<p>Using native sql it looks as follows:</p>

<pre><code>Query query = session.createSQLQuery( "SELECT {T_master.*}, {T_joined.*} FROM schema.t_master AS T_master OUTER LEFT JOIN schema.T_joined AS T_joined ON T_master.ENTRY_DATE = T_joined.ENTRY_DATE AND T_master.MASTER_ID = T_joined.JOINED ID " /*WHERE ... */ );
query.setEntity( "T_master", T_master.class);
query.setJoin( "T_joined", "T_master.joinedSet"); //joinedSet is the one-to-many mapping
query.setJoin( "T_master", "T_joined.master" );
</code></pre>

<p>Thus, you get to be very verbose on your query, and hibernate only acts as an object mapper.</p>

<p>Using Criteria or HQL, it is impossible to have OUTER LEFT JOIN ON some field other than primary keys.  This is why if you have such an option, use native SQL code.</p>
