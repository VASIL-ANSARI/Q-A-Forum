<p>Have you tried handling FocusableChanged event 
<a href="http://msdn.microsoft.com/en-us/library/system.windows.uielement.focusablechanged.aspx" rel="nofollow">http://msdn.microsoft.com/en-us/library/system.windows.uielement.focusablechanged.aspx</a></p>

<p>You can check IsFocused inside FocusableChanged event handler. if IsFocused is true, you can call SelectAll
Following is the pseudo code</p>

<pre><code>textBox.FocusableChanged += (s,e) =&gt;
{
   if(textBox.IsFocused)
     testBox.SelectAll();
}
</code></pre>

<p>EDIT1<br>
 As Above is not working,  You can try FocusManger.GetFocusedElement.<br>
<a href="http://blogs.msdn.com/b/luc/archive/2010/08/05/silverlight-wpf-debugging-determining-the-focused-element.aspx" rel="nofollow">determining-the-focused-element</a></p>

<pre><code>public DebugFocusedElementProxy()
{
    var timer = new DispatcherTimer();
    timer.Interval = TimeSpan.FromMilliseconds(100);
    timer.Tick += (o, ea) =&gt;
    {
        var fe = FocusManager.GetFocusedElement();
        if (fe != null)
        {
            var element = fe as FrameworkElement;
            if (!string.IsNullOrEmpty(element.Name) &amp;&amp;
                 String.Equals(element.Name, textBox))
            {
                textBox.SelectAll();
            }
        }
    };
    timer.Start();
}
</code></pre>

<p>//Beware that textBox.SelectAll might require to be called on <a href="http://www.switchonthecode.com/tutorials/working-with-the-wpf-dispatcher" rel="nofollow">Dispatcher Thread</a></p>
