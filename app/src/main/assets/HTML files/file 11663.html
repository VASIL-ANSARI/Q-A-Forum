<p>Syntax errors non-withstanding, you cannot <code>dynamic_cast</code> a non-polymorphic type.  <code>static_cast</code> is the cast you would use in this case, if you know that it is in fact an object of the target type.  </p>

<p>The reason why:  <code>static_cast</code> basically has the compiler perform a check at compile time "Could the input be cast to the output?"  This is can be used for cases where you are casting up or down an inheritance hierarchy of pointers (or references).  But the check is only at compile time, and the compiler assumes you know what you are doing.</p>

<p><code>dynamic_cast</code> can only be used in the case of a pointer or reference cast, and in addition to the compile time check, it does an additional run time check that the cast is legal.  It requires that the class in question have at least 1 virtual method, which allows the compiler (if it supports RTTI) to perform this additional check.  However, if the type in question does not have any virtual methods, then it cannot be used.</p>

<p>The simplest case, and probably worthwhile if you're passing pointers around like this, is to consider making the base class's destructor virtual.  In addition to allowing you to use dynamic cast, it also allows the proper destructors to be called when a base class pointer is deleted.</p>
