<p>A good way to do this would be to use a dictionary. The logic is very much like JPeroutek describes. You go through list b, store the corresponding number in list a, and if you encounter a value in b you've already seen, then you add the new number in a it. You might try something like this to generate it:</p>

<pre><code>res = {}
for ix in xrange(len(b)):
    cur_b = b[ix] # grab the next number in b
    cur_a = a[ix] # grab the corresponding number in a
    try: # if we've seen cur_b before then we can add cur_a to it
        res[cur_b] += cur_a 
    except KeyError: # otherwise we've never seen cur_b before so we set it to cur_a
        res[cur_b] = cur_a
</code></pre>

<p>In case the try &amp; except doesn't make sense you can rewrite those four lines to look like this</p>

<pre><code>if cur_b in res:  # this asks if cur_b is in the set of keys of res
    res[cur_b] += cur_a
else:
    res[cur_b] = cur_a
</code></pre>

<p>This will result in a dictionary that looks like the following:</p>

<pre><code>{(1, 25), (2, 41), (3, 28)}
</code></pre>

<p>It's important to note that the dictionary may not preserve the order that you want. For example:</p>

<pre><code>b = [3, 3, 2, 1]
a = [12, 4, 6, 6]
</code></pre>

<p>would result in</p>

<pre><code>{(1, 6), (2, 6), (3, 15)}
</code></pre>

<p>If ordering is important, this would pose a problem with the next step.</p>

<hr>

<p>You can split the dictionary into ret_a and ret_b by messing with the result of     </p>

<pre><code>res.items()
</code></pre>

<p>for instance:</p>

<pre><code>ret_a = [t[1] for t in res.items()]
ret_b = [t[0] for t in res.items()]
</code></pre>
