<p>You can create an anonymous class in your tests:</p>

<pre><code>describe A do
  let(:extended_class) { Class.new { extend A } }
  let(:including_class) { Class.new { include A } }

  it "works" do
    # do stuff with extended_class.say_hello
    # do stuff with including_class.new.say_hello
  end
end
</code></pre>

<p>To see something similar in real code, I've used this strategy for <a href="https://github.com/barsoom/attr_extras/blob/master/spec/attr_private_spec.rb">testing my attr_extras lib</a>.</p>

<p>That said, <code>include</code> and <code>extend</code> are standard features of Ruby, so I wouldn't test that every module works both when including and when extending â that's usually a given.</p>

<p>If you create a named class in the test, like you do in your question, I believe that class will exist globally for the duration of your test run. So this class will leak between every test of your test suite, potentially causing conflicts somewhere.</p>

<p>If you use <code>let</code> to create an anonymous class, it will only be available inside this particular test. There is no global constant pointing to it that could conflict with other tests.</p>
