<p>As the elements are added dynamically, use delegated events handlers:</p>

<pre><code>$(document).ready(function(){
  $(document).on('click', ".div2 .roles", function(){
    var role = $(this)
    $(".div1").append(role);
  });
});

$(document).ready(function(){
  $(document).on('click', ".div1 .roles", function(){
    var role = $(this)
    $(".div2").append(role);
  });
});
</code></pre>

<p>These work by delegating responsibility (hence the name <em>delegated</em>) to an unchanging ancestor element (<code>document</code> is the best default if nothing else is closer/convenient). In your example <code>.div1</code> &amp; <code>.div2</code> would probably do (if they never change).</p>

<p>e.g.</p>

<pre><code>$(document).ready(function(){
  $('.div2').on('click', ".roles", function(){
    var role = $(this)
    $(".div1").append(role);
  });
});

$(document).ready(function(){
  $('.div1').on('click', ".roles", function(){
    var role = $(this)
    $(".div2").append(role);
  });
});
</code></pre>

<p>This works by listing for the events (e.g. click) to bubble up to the ancestor. It <em>then</em> applies the jQuery selector to only the elements in the bubble chain. It <em>then</em> applies the function to only the matching elements that caused the event. The upshot is the elements need only exist at click time and not when the click was registered.</p>

<h2>Notes:</h2>

<ul>
<li>At the moment you have 3 DOM ready handlers. You could put a single DOM ready around the 3 blocks of code.</li>
<li>A shorter version of the <em>DOM ready</em> handler is as follows:</li>
</ul>

<p>e.g.</p>

<pre><code>$(function(){
   // Your code here
});
</code></pre>
