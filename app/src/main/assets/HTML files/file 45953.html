<p>There are shared components in CPU like last level cache, execution units (between hardware threads within one core), so under heavy loads you will get jitter, because even if your application executed exactly the same amount of instructions, each instructions may take more cycles (waiting for memory because data was evicted from cache, available execution unit), and more cycles means more time to execute (assuming that Turbo Boost won't compensate).</p>

<p>If you seek for precise instrument, look at <a href="https://en.wikipedia.org/wiki/Hardware_performance_counter" rel="nofollow">hardware counters</a>.</p>

<p>It is also important to consider factors like the number of cores available on the physical CPU, hyper-threading and other BIOS settings like Turbo Boost on Intel CPUs, and threading techniques used when coding when looking at timing metrics for CPU intensive tasks.  </p>

<p>Parallelization tools like <a href="http://openmp.org/wp/" rel="nofollow">OpenMP</a> provide built-in functions for calculating computation and wall time like <code>omp_get_wtime( );</code> which are often times more accurate than <code>clock()</code> in programs that make use of this type of parallelization.</p>
