<p>Here is <a href="http://ideone.com/gRchrJ" rel="nofollow">working Java code</a> tested on various test cases.</p>

<p>The algorithm basically uses a sliding window to examine different windows within which an answer may lie. Each character in the string str2 is analyzed at most twice. Thus the running time of the algorithm is linear, ie <code>O(N)</code> in the lengths of the three strings. This is infact the most optimal solution for this problem.</p>

<pre><code>String str1 = "spqrstrupvqw";
String str2 = "sprt";
String str3 = "q";
char[] arr = str1.toCharArray();
HashSet&lt;Character&gt; take = new HashSet&lt;Character&gt;();
HashSet&lt;Character&gt; notTake = new HashSet&lt;Character&gt;();
HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();

void run()throws java.lang.Exception{
    System.out.println(str1 + " " + str2 + " " + str3);

    //Add chars of str2 to a set to check if a char has to be taken in O(1)time.
    for(int i=0; i&lt;str2.length(); i++){
        take.add(str2.charAt(i));
    }

    //Add chars of str3 to a set to check if a char shouldn't be taken in O(1) time.
    for(int i=0; i&lt;str3.length(); i++){
        notTake.add(str3.charAt(i));
    }

    int last = -1;
    int bestStart = -1;
    int bestLength = arr.length+1;

    // The window will be from [last....next]

    for(int next=last+1; next&lt;arr.length; next++){
        if(notTake.contains(arr[next])){ 
            last = initLast(next+1); //reinitialize the window's start. 
            next = last;
        }else if(take.contains(arr[next])){
            // take this character in the window and update count in map.
            if(last == -1){
                last = next;
                map.put(arr[last], 1);
            }else{
                if(!map.containsKey(arr[next])) map.put(arr[next], 1);
                else          map.put(arr[next], map.get(arr[next])+1);
            }
        }

        if(last &gt;= arr.length){ // If window is invalid
            break;
        }

       if(last==-1){
            continue;
        }

        //shorten window by removing chars from start that are already present.
        while(last &lt;= next){
            char begin = arr[last];

            // character is not needed in the window, ie not in set "take"
            if(!map.containsKey(begin)){
                last++;
                continue;
            }

            // if this character already occurs in a later part of the window
            if(map.get(begin) &gt; 1){
                last++;
                map.put(begin, map.get(begin)-1);
            }else{
                break;
            }
        }

        // if all chars of str2 are in window and no char of str3 in window, 
// then update bestAnswer
        if(map.size() == str2.length()){
            int curLength = next - last + 1;
            if(curLength &lt; bestLength){
                bestLength = curLength;
                bestStart  = last;
            }
        }
    }

    if(bestStart==-1){
        System.out.println("there is no such window");
    }else{
        System.out.println("the window is from " + bestStart + " to " + (bestStart + bestLength-1));
        System.out.println("window " + str1.substring(bestStart, bestStart+bestLength));
    }

}

// Returns the first position in arr starting from index 'fromIndex'
// such that the character at that position is in str2.
int initLast(int fromIndex){

    // clear previous mappings as we are starting a new window
    map.clear();
    for(int last=fromIndex; last&lt;arr.length; last++){
        if(take.contains(arr[last])){
            map.put(arr[last], 1);
            return last;
        }
    }
    return arr.length;
}
</code></pre>

<p>Moreover, your code fails on many trivial test cases. One of them is when str1 = "abc", str2 = "ab", str3 = "c".</p>

<p>PS. If you are having a hard time understanding this code, first try reading <a href="http://www.geeksforgeeks.org/find-the-smallest-window-in-a-string-containing-all-characters-of-another-string/" rel="nofollow">this easier post</a> which is very similar to the problem that has been asked.</p>
