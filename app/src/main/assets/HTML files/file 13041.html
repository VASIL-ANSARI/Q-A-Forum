<p>I hope I understood you right. Then I suggest using a singleton design pattern encapsulating motion manager access in a specialised class. Some pseudo code:</p>

<p>MotionHandler.h</p>

<pre><code>@interface MotionHandler {
    CMMotionManager* motionManager;

    + (MotionHandler*) getInstance;
}
</code></pre>

<p>MotionHandler.c:</p>

<pre><code>@interface MotionHandler {

    static MotionHandler* instance;

    + (MotionHandler*) getInstance {
        if (instance == nil) {
            instance = [[self alloc] init];
        }
        return instance;
    }

    - (id)init {
        if ((self = [super init])) {
            motionManager = [[CMMotionManager alloc] init];
            // initialise CMMotionManager
        }
    }
}
</code></pre>

<p>So there is one instance of MotionHandler only which manages access to CMMotionManager. You can accesss your CMMotionManager instance from everywhere with <code>MotionHandler.getInstance.motionManager</code>. </p>

<p>If you need access to CoreMotion from several classes, I recommend total encapsulation of CMMotionManager access. That means make it @private and provide methods like getDeviceMotion, setReferenceAttitude, ...
This helps to avoid complications like starting it twice or access to CMDeviceMotion before start and makes it more convenient to debug.</p>
