<p>The simplest is to implement <code>forwardingTargetForSelector:</code>. When you receive messages you don't respond to, this method will be called, and whatever object it returns will be sent the message.</p>

<p>For example:</p>

<pre><code>@implementation SecondLevelObject
- (id)forwardingTargetForSelector:(SEL)aSelector {
    // Often you would actually check the selector here
    return self.thirdLevelObject;
}
@end
</code></pre>

<p>The problem is that now <code>SecondLevelObject</code> doesn't appear to conform to the protocol, and that will generate warnings. You can suppress that warning (since you really do conform to the protocol) using a pragma:</p>

<pre><code>#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
@implementation SecondLevelObject
...
@end
#pragma clang diagnostic pop
</code></pre>

<p>This turns off the protocol-checking for the whole object, though, so you need to be very careful with it. In most cases I find it much easier and clearer to just write the forwarding code. If there's a lot of it, it sometimes indicates a different design problem. Perhaps LevelThreeObject should really be the delegate itself, or maybe looser systems like notifications or KVO would have been better. But forwarding does still come up quite legitimately, and this is one technique to consider.</p>
