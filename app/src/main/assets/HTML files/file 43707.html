<p>Well you could always keep the address of the malloc'd memory is a separate pointer:</p>

<pre><code>char* test = malloc(~~~)
char* toFree = test;
test = substr(test,1,2);
free(toFree);
</code></pre>

<p>But most of the features and capabilities of shuffling this sort of data around has already been done in string.h. One of those functions probably does the job you want get done. <code>movemem()</code> as others have pointed out, could move the substring to the start of your char pointer, viola!  </p>

<p>If you specifically want to make a new dynamic string to play with while keeping the original separate and safe, and also want to be able to overlap these pointers.... that's tricky. You could probably do it if you passed in the source and destination and then range-checked the affected memory, and free'd the source if there was overlap... but that seems a little over-complicated.  </p>

<p>I'm also loathe to malloc memory that I trust higher levels to free, but that's probably just me. </p>

<p>As an aside,</p>

<pre><code>char* test = "test";
</code></pre>

<p>Is one of those niche cases in C. When you initialize a pointer to a string literal (stuff in quotes), it puts the data in a special section of memory just for text data. You can (rarely) edit it, but you shouldn't, and it can't grow. </p>
