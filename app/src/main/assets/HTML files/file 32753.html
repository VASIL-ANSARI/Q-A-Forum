<p>There are only those three elements, and no missing close tags. It looks as if furthermore there are no attributes on the tags, and aren't even any elements inside elements. There's no whitespace inside tags either.</p>

<p>Then <em>you are not parsing HTML</em>. You are parsing a special language that is a subset of HTML (well, not even really a subset since your document doesn't validate).</p>

<p>You might have a good reason not to want to use an HTML parser to parse this special language. For example, the code for a full HTML parser is large-ish and perhaps wouldn't otherwise need to be on the very tiny embedded device you're writing for. More likely this is a learning assignment, and the goal is for you to manipulate strings <em>not</em> to choose the best tool to produce the output you need. I will assume that you must avoid using an HTML library without further consideration why.</p>

<p>So, how to parse this special language? How to parse anything. Given all the restrictions I have listed above, you could do it very simply:</p>

<ul>
<li>Look for the first instance in the string of any one of three substrings <code>&lt;p&gt;</code>, <code>&lt;h2&gt;</code>, <code>&lt;h3&gt;</code>. This is your opening tag.</li>
<li>Find the first instance of the corresponding close tag.</li>
<li>Everything between is the contents of the element. In your example you additionally trim whitespace at each end of the content. Construct an <code>Elements</code> object and add it to your vector (btw consider using a singular class name, not plural).</li>
<li>Repeat on the remainder of the string.</li>
</ul>

<p>That's it. You could do that using a regular expression, but my general feeling is that since you <em>said</em> you wanted to do it in C++ then you may as well just do it in C++. No need to bring another language into it, and whatever the merits and limits of regexes, they certainly are another language.</p>

<p><em>However</em>, maybe the extra limits I listed above aren't guaranteed. What if you later want to support spaces inside tags? And attributes? And XML namespaces? And comments? Then you'll wish you'd just used an HTML parser. Therefore what you do for a fixed trivial subset of HTML is different from what you do for a significant subset or one that might become significant in future.</p>
