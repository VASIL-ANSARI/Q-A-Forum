<p>Here's how we solved this problem. We attached a function to the target that watches the scroll event. The target gets a quick mask element that when scrolled the mask is shown thereby preventing the event bubble to scroll the target.</p>

<p>Since the outer element is being scrolled the target element will not keep the scroll event for a prolonged period of time. Attach a timeout of say 500ms will allow for the target to know that you are wanting to scroll the target.</p>

<pre><code>function scrollUninterruptable(elem) {
var scrollTimer = null,
scrollMask = $('&lt;div&gt;', { 'style': 'position: absolute; right: 0; left: 0; top: 0; bottom: 0;', 'class': 'scrollMask' }).hide();
elem = $(elem);
elem.append(scrollMask);
elem.parent().off('scroll.uninterruptably').on('scroll.uninterruptably', function() {
    elem.css('position', 'relative');
    scrollMask.show();
    if (scrollTimer) {
        clearTimeout(scrollTimer);
    }
    scrollTimer = setTimeout(function() {
        elem.css('position', '');
        scrollMask.hide();
    }, 500);
});
}
</code></pre>

<p>Again this just watches the scroll event attaches a 500ms timeout then hides the mask which will allow the scroll event to fire on the target.</p>
