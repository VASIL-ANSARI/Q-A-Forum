<blockquote>
  <p>Is it because I cannot run SDL_PollEvents twice?</p>
</blockquote>

<p>Your problem isn't what I'd expect, but, yes, it's a bad idea to run <code>SDL_PollEvents</code> twice. SDL keeps an event stack which is added to as your program runs. <code>SDL_PollEvents</code> pops events from the stack until it is empty. As a result, running two polling loops, one will remove events which the other will then not see. Blind luck (or execution bottlenecks) will determine which loop is more likely to see any particular event occur. (See <a href="http://wiki.libsdl.org/SDL_PollEvent" rel="nofollow">http://wiki.libsdl.org/SDL_PollEvent</a>).</p>

<p>If you really want to run two polling loops, you can store unhandled events in your default case, and push the list of events back after each loop with <code>SDL_PushEvent</code>: <a href="http://wiki.libsdl.org/SDL_PushEvent" rel="nofollow">http://wiki.libsdl.org/SDL_PushEvent</a></p>

<p>This said, I'm surprised that your events "get through" after a delay: I would expect them to vanish. Are you holding the keys down? Then, your OS key-repeat delay might be what you're seeing, after which the event queue is being flooded between each loop. You might want to check the repeat flag of the key event: <a href="http://wiki.libsdl.org/SDL_KeyboardEvent" rel="nofollow">http://wiki.libsdl.org/SDL_KeyboardEvent</a></p>

<p>I would say this points to a design problem. You should ask yourself, why does the Display delegate the Game ending? Would it not be more sensible to inform the Display, along with everything else, of this fact?</p>
