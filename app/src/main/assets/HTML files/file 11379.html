<p>You want to write the code you wish you had. In C style languages/statically compiled languages, the above would not even compile, as you correctly stated the code does not exist. This is fine, you would then implement the bare minimum to make the code build in order to run your tests. In other words, your tests drive your design.</p>

<p>My Ruby is very rusty but in the above example something along the lines of <code>method_missing</code> will be thrown for the methods/properties that do not exist. Therefore you would create them.</p>

<pre><code>class Person
  attr_accessor :firstname, :lastname

  def fullname

  end
end
</code></pre>

<p>If you run your test now you will get nil returned from fullname. Therefore we would implement the fullname method. The point to note here is that message has changed, rather than Ruby moaning about missing methods, the test is moaning that we have not implemented the methods correctly.</p>

<pre><code>def fullname
   return @firstname + " " + @lastname
end
</code></pre>

<p>Now your test will pass. </p>

<p>Basically you want to either change the message that your test displays after running (this will prove you are getting somewhere) or you want to make it pass. After the test is passing, you can refactor. The above method is simple, but you could drop the return statement, use string formatting or whatever. As long as the test passes after, you know you're good to go.</p>
