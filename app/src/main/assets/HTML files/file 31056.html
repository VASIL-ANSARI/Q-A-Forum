<p>Yes, you're never locking the <em>variable</em> that holds the reference, you're always locking the <em>instance</em>.</p>

<p>In your case you're copying the <em>reference</em>, not the <em>object</em>, so it's the same objects you're working on that is in those fields.</p>

<p>Locking on those should work just fine.</p>

<p>Just know that:</p>

<ol>
<li>Locking an object does not in any way prevent other threads from accessing the same object. If that other thread <em>does not lock</em>, it will waltz right in and change the object oblivious to your lock.</li>
<li>Don't lock on objects you don't own, and objects you publish to others. You need to be sure that <em>your code</em> is the only one locking that object, otherwise your careful synchronization code might stop abruptly if some other code also holds a lock on it.</li>
<li><strong>Never lock on value types</strong>, even if you have them in an <code>object</code> variable. Every time you copy the value type into an <code>object</code> variable, you get <em>a new copy</em>, which will have its own lock.</li>
</ol>

<p>To counteract nbr. 2 you usually do this:</p>

<pre><code>private readonly object fLockReadQuests = new object();
</code></pre>

<p>and then lock on that instead.</p>

<p>But again, your assumptions in the question holds.</p>
