<p>I ended up solving this with a combination of storyboard and code, using <a href="http://stackoverflow.com/questions/30267591/replace-entire-text-string-in-nsattributedstring-without-modifying-other-attribu">this answer</a> as a reference.</p>

<p>To start with, the attributed string I used on the storyboard just applied a 1.5 line spacing to the whole string, so it was easier to set the text on code preserving the storyboard's label formatting.</p>

<p>The storyboard contains a UILabel with the text property set as Attributed and a 1.5 line height multiple.</p>

<p>On my view controller code I have a setupUI method and a outlet for that UILabel.</p>

<pre><code>@interface MyClass ()
@property (weak, nonatomic) IBOutlet UILabel *aLabel;
@end

@implementation MyClass
- (void)setupUI {
    NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithAttributedString:self.aLabel.attributedText];
    [attributedString.mutableString setString:NSLocalizedString(@"This is the label text which should be localisable.", "")];
    self.aLabel.attributedText = attributedString;
}
@end
</code></pre>

<p>With the above code, the variable attributedString stores all the formatting set on the storyboard, so when I change the attributedString text I don't have to set the formatting again. And, of, course, the label text appears on the Localizable.strings when I execute the "Export for Localizations" command.</p>

<p>This wouldn't work as well if the attributedString had different formatting for its internal substrings. In that case the formatting would have to be set up manually on code (or using rtf files as suggested by the answer posted on the comment by Jelly).</p>
