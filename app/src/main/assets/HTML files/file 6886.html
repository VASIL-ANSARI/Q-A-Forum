<p>We made the same mistake with our L2S data layer. Our load options are ridiculous in some cases. It was a hard lesson learned.</p>

<p>This is known as the SELECT N+1 problem. 1 for the parent entity, and N for the number of associated entities being eager-loaded. You'd expect L2S to just be smart enough and get it all in one giant query, but this is unfortunately not the case. It will create one giant query, which tells it the IDs of the associations to load, then one by one retrieves those associations.</p>

<p>Perhaps the best work-around is to use projection so your LINQ query returns a new object, rather than an entity. For example:</p>

<pre><code>var fooDtos = from foo in db.Foo
              where foo.bar == "What a great example"
              select new fooDTO { FooName = foo.Name, FooBar = foo.Bar };
</code></pre>

<p>This query returns an IEnumerable&lt;FooDTO> instead of IQueryable&lt;Foo>. This has two benefits. First of all you're instructing L2S specifically which columns to retrieve, so it doesn't do a SELECT *. Also, you don't need DataLoadOptions anymore because you can query any table you want in the query and select from any table to generate the DTO.</p>
