<p>So your problem is that you are using scanf wrongly. If you use scanf with the %f conversion specifier and you give it a letter ('q' for example), it will fail. You can verify by checking the output of scanf.</p>

<p>BUT this failure will also keep that last input in the scanf buffer if you don't explicitly flush the buffer. This means that each time that scanf statement runs, it automatically takes that 'q' value you fed it without prompting you.</p>

<p>A better way of going about this would be to do this:</p>

<pre><code>if ( scanf_s("%f", &amp;Rain) &lt; 1)
{
  return;
}
sum = sum + Rain;
</code></pre>

<p>This would be a convoluted and not recommended method of allowing you use any non-numeric character or string to stop the request.</p>

<p>Now, it would be a much better idea to do something more like this:</p>

<pre><code>&lt;start of input function&gt;

char rain_s[MAX_STRING_SIZE_EXPECTED];
.
.
.
scanf_s("%s", &amp;Rain_s) &lt; 1
if (strcmp(Rain_s)."q")
{
  return;
}
else
{
  Rain = atof(Rain_s)
}

sum = sum + Rain;
.
.
.
</code></pre>

<p>This method would ensure you don't run into any future problems.</p>

<p>Now instead of reading in a floating point value, you are reading in a string. You are doing a check to see if the user actually wants to quit and didn't just have a typo, and then you are converting that string into a floating point value which you can then use elsewhere.</p>

<p>Edit:
And while the comma you have in your while statement is not a syntax error, that is most likely still a programming error. Essentially, only the second expression is evaluated for the if statement.</p>
