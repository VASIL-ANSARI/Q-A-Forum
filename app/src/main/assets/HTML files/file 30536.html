<p>The two examples <em>do</em> differ. When a method is marked with the <code>async</code> keyword, the compiler generates a state-machine behind the scenes. This is what is responsible for resuming continuations once an awaitable has been awaited.</p>

<p>In contrast, when a method is <em>not</em> marked with <code>async</code> you are losing the ability to <code>await</code> awaitables. (That is, within the method itself; the method can still be awaited by its caller.) However, by avoiding the <code>async</code> keyword, you are no longer generating the state-machine, which can add a fair bit of overhead (lifting locals to fields of the state-machine, additional objects to the GC).</p>

<p>In examples like this, if you are able to avoid <code>async-await</code> and return an awaitable directly, it should be done to improve the efficiency of the method.</p>

<p>See <a href="http://stackoverflow.com/q/19098143/921321">this question</a> and <a href="http://stackoverflow.com/a/19098209/921321">this answer</a> which are very similar to your question and this answer.</p>
