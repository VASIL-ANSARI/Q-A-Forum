<p>Huh?</p>

<p>If you're certain that the <code>unsigned long long</code> is big enough, then why are you bothering with the manual implementation? Why not just use an <code>unsigned long long</code> variable?</p>

<p>There's some brokenness in your loop; the expression <code>(counter-&gt;data[m] &lt;&lt; m * 8)</code> does not have type <code>unsigned long long</code> so will likely drop a lot of bits.</p>

<p>Use something like this:</p>

<pre><code>for(m = 0; m &lt; COUNTER_LENGTH; ++m)
{
  a &lt;&lt;= 8;
  a |= counter-&gt;data[m];
}
</code></pre>

<p>The above should also be endian-safe; it always OR:s in the most significant byte first (as determined by the <code>counter</code> representation).</p>
