<p>This is happening because Backbone is handing you a reference to an object that it then reuses.</p>

<p>As you probably know, the <code>mouseenter</code> event is followed by a <code>mouseover</code> event. You don't have a handler for <code>mouseover</code>, so normally, you wouldn't care.</p>

<p>When a <code>mouseenter</code> event occurs, your handler is called with this object <code>e</code>. This is a reference to some object within Backbone; you log its <code>type</code>, but then you retain a reference to that object in your <code>delay</code> handler.</p>

<p>Then, your event handler returns, and control is given back to the Javascript thread. The <code>mouseover</code> event fires. Your code may ignore it, but Backbone goes ahead and reuses the object it handed you and puts the information about the <code>mouseover</code> event in to it.</p>

<p>Then, your delay expires, and you use <code>e</code> to find out the type of the event... now its got all the <code>mouseover</code> event data in it, so that's what you see.</p>

<p>This should be a salutary lesson to us all. First, be aware that JS deals in object references and, if you store an object that something other than your code has created, and then break the thread, that object can change underneath you.
Equally, if you have methods that return arrays or objects, know that your are returning a reference to that array or object... thus, if calling code changes the contents of said array or object, this can mess you up; this is particularly dangerous when you have a private field with a public getter. If you're not careful, you can hand over a reference that allows code to change your objects internals, without you meaning to!</p>
