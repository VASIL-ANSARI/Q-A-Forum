<p>Sure, you can update it "animated", but you have to use a repeating timer, and add one (or whatever interval you want) to the count each time the timer's selector is called. Include a test for the final value, and invalidate the timer when you get there.</p>

<p><strong>After Edit:</strong></p>

<p>If you want the speed of the count to slow down toward the end, I wouldn't use a timer, I would use performSelector:withObject:afterDelay:. To make it repeat, you would call this method from within its selector. You would need to do some test to see if you're near the end of the count up, and then add a little bit of time to the delay with each pass. Something like this:</p>

<pre><code>-(IBAction)countUp:(id)sender {
    [self performSelector:@selector(countUpLabel) withObject:nil afterDelay:.1];
}

-(void)countUpLabel {
    static float delay = .01;
    num+= 1;
    label.text = [NSString stringWithFormat:@"%d",num];
    if (num &lt; 40) {
        [self performSelector:@selector(countUpLabel) withObject:nil afterDelay:.1];
    }else if (num &gt; 35 &amp;&amp; num &lt;50) {
        [self performSelector:@selector(countUpLabel) withObject:nil afterDelay:.1 + delay];
        delay += 0.01;
    }
}
</code></pre>
