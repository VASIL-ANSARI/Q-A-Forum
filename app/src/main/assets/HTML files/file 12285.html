<p>If your code is correct, then virtual functions will work as expected. The compiler may, as an optimization, transform virtual function calls into normal function calls if it is 100% certain <strike>about the static type</strike> that the dynamic type is of "static" nature for the scope of this call, i.e. it is certain at compile time that the call happens on a compiletime-known type that cannot change, and thus the function cannot possibly be anything else than exactly one concrete function.<br>
Most of the time, this is the case because you explicitly tell the compiler either with a cast or scope resolution. Regardless, it will <em>still</em> work as expected with no observable difference (different machine code and more efficient for sure, but same behaviour).</p>

<p>This is irrespective of generation of a vtable. The vtable is generated anyway (if the compiler uses vtables to implement virtual inheritance, which most/all do, but strictly do not <em>have</em> to).</p>

<p>If it does not work as expected, you probably <a href="http://www.parashift.com/c++-faq-lite/strange-inheritance.html#faq-23.9" rel="nofollow">hide</a> the virtual function (unintentionally).</p>
