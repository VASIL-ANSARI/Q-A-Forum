<p>You can get this behaviour by generating the indices:</p>

<pre><code>template&lt;unsigned...&gt; struct indices{};

template&lt;unsigned N, unsigned... Indices&gt;
struct indices_gen : indices_gen&lt;N-1, N-1, Indices...&gt;{};

template&lt;unsigned... Indices&gt;
struct indices_gen&lt;1, Indices...&gt;{
  using type = indices&lt;1, Indices...&gt;;
};

#include &lt;array&gt;

template&lt;unsigned N&gt;
struct fibonacci{
  static constexpr unsigned value = N; // yes, lazyness on my part
};

template&lt;class IPack&gt;
struct first_n_fib_impl;

template&lt;unsigned... Is&gt;
struct first_n_fib_impl&lt;indices&lt;Is...&gt;&gt;
{
  using arr_type = std::array&lt;unsigned, sizeof...(Is)&gt;;
  static constexpr arr_type value = {{ fibonacci&lt;Is&gt;::value... }};
};

template&lt;unsigned... Is&gt;
constexpr std::array&lt;unsigned, sizeof...(Is)&gt; first_n_fib_impl&lt;indices&lt;Is...&gt;&gt;::value;

template&lt;unsigned N&gt;
struct first_n_fib
  : first_n_fib_impl&lt;typename indices_gen&lt;N&gt;::type&gt;
{
};
</code></pre>

<p><a href="http://liveworkspace.org/code/d75b980c311dc5bed696ce25ac6b4cac" rel="nofollow">Live example (to show that <code>[1..7]</code> is indeed generated).</a></p>
