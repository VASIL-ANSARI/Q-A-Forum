<p>FYI, your example is using mostly reserved words and makes it horrid for us to attempt to program against.  If you've got the real table columns, gives those to us.  This is postgres:</p>

<pre><code>select name,value, max(date)
from the_table_name_you_neglect_to_give_us
group by 1,2
</code></pre>

<p>That'll give you a list of first name,value,max(date)...though I gotta ask why give us a column called value if it doesn't change in the example?</p>

<p>Lets say you do have an id column...we'll be consistent with your scheme and call it 'ID'...</p>

<pre><code> select b.id from
(select name,value, max(date) date
from the_table_name_you_neglect_to_give_us
group by 1,2) a
inner join the_table_name_you_neglect_to_give_us b on a.name=b.name and a.value=b.value and a.date = b.date
</code></pre>

<p>This gives a list of all ID's that are the max...put it together:</p>

<pre><code>select name,value, max(date)
from the_table_name_you_neglect_to_give_us
group by 1,2
</code></pre>

<p>union all</p>

<pre><code>select name,value, max(date)
from the_table_name_you_neglect_to_give_us
where id not in
(select b.id from
(select name,value, max(date) date
from the_table_name_you_neglect_to_give_us
group by 1,2) a
inner join the_table_name_you_neglect_to_give_us b on a.name=b.name and a.value=b.value      and a.date = b.date)
</code></pre>

<p>Hoping my syntax is right...should be close at any rate.  I'd put a bracket around that entire thing then select * from (above query) order by name...gives you the order you want.</p>
