<p>I think I understand; you're making a balanced binary tree from <strong>cnodes</strong> with the <strong>previous</strong> and <strong>next</strong> pointers being reused for the left and right sub-trees.</p>

<p>... so that's your algorithm.</p>

<ul>
<li>Find the middle node of the binary tree (which you've already done).</li>
<li>Turn the left half into a binary tree.  The left half is the original head, with the last element (middle->previous) now having a <strong>next</strong> pointer of NULL.</li>
<li>Link this left half to <strong>middle->previous</strong> (hijacked as the left sub-tree).</li>
<li><p>Turn the right half into a binary tree; this is headed by <strong>middle->next</strong>.  Make it the new value of <strong>middle->next</strong>.</p></li>
<li><p>You have to keep the original head as the pointer to the left sub-tree.</p></li>
<li>You'll want your routine to return the binary tree's root, so the previous call can link it into the level above.</li>
<li>You still have to pick a termination condition, such as the head pointer being <strong>NULL</strong>.</li>
</ul>

<p>Does that get you moving to a solution?</p>
