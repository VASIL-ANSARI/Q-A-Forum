<p>The short answer is that PHP does not have a built in function to do this, so you will have to write one.  Most of the time, it does not matter if the sort moves the element up or down if it is considered equal to the adjoining element.  An example would be any array of integers.  If two are the same, who cares what order they are in as long as they are together.</p>

<p>For the cases where you DO need to maintain the order of the lists, Sreid has written a very good function for this.  It is actually on the usort page at php.net.  I am pasting it here for your convenience.  Be aware that I am giving sreid full credit for this code, and I have already mentioned where his original code can be found in a public forum:</p>

<pre><code>function mergesort(&amp;$array, $cmp_function = 'strcmp') {
// Arrays of size &lt; 2 require no action.
if (count($array) &lt; 2) return;
// Split the array in half
$halfway = count($array) / 2;
$array1 = array_slice($array, 0, $halfway);
$array2 = array_slice($array, $halfway);
// Recurse to sort the two halves
mergesort($array1, $cmp_function);
mergesort($array2, $cmp_function);
// If all of $array1 is &lt;= all of $array2, just append them.
if (call_user_func($cmp_function, end($array1), $array2[0]) &lt; 1) {
    $array = array_merge($array1, $array2);
    return;
}
// Merge the two sorted arrays into a single sorted array
$array = array();
$ptr1 = $ptr2 = 0;
while ($ptr1 &lt; count($array1) &amp;&amp; $ptr2 &lt; count($array2)) {
    if (call_user_func($cmp_function, $array1[$ptr1], $array2[$ptr2]) &lt; 1) {
        $array[] = $array1[$ptr1++];
    }
    else {
        $array[] = $array2[$ptr2++];
    }
}
// Merge the remainder
while ($ptr1 &lt; count($array1)) $array[] = $array1[$ptr1++];
while ($ptr2 &lt; count($array2)) $array[] = $array2[$ptr2++];
return;
</code></pre>

<p>} </p>
