<p><br/>
Firstly, your test:</p>

<blockquote>
  <p>[allViewControllers removeObjectIdenticalTo: @"NonLogginedViewController"];</p>
</blockquote>

<p>...is testing for a string, not a view controller. So that won't work.</p>

<p>If you know where the view controller is in the navigation controller's stack then this is easy. Say for example you've just pushed a new controller and now you want to remove the one before that. You could do this:</p>

<pre><code>NSMutableArray *allControllers = [self.navigationController.viewControllers mutableCopy];
[allControllers removeObjectAtIndex:allControllers.count - 2];
[self.navigationController setViewControllers:allControllers animated:NO];
</code></pre>

<p>But I think in your case you want to find a certain controller and remove it.  One way to do this would be to look for a certain class, e.g. LoginController. Set up a new array by copying the old one, and then iterate through this new array:</p>

<pre><code>NSArray *allControllersCopy = [allControllers copy];

for (id object in allControllersCopy) {
   if ([object isKindOfClass:[LoginController class]])
      [allControllers removeObject:object];
}
</code></pre>

<p><br/>
...then set the allControllers array for the viewControllers property, as before.</p>

<p>NOTE: If you're manipulating a <code>UINavigationController</code>'s stack from a containing view controller â perhaps once that view controller appears â you should wait until the view is fully onscreen. A good place for that is in the <code>viewDidAppear:</code> override, for example:</p>

<pre><code>- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated]; 
    NSMutableArray *allControllers = ...
}
</code></pre>
