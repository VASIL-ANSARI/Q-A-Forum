<p>You can either change it to</p>

<pre><code>template&lt;typename U = T, typename std::enable_if&lt;
   !std::is_base_of&lt;BaseClass, U&gt;::value&gt;::type* = nullptr&gt;
void print_line()
{
   std::cout &lt;&lt; "Parameter of general Type T" &lt;&lt; std::endl;
}
</code></pre>

<p>or </p>

<pre><code>template&lt;typename U = T&gt;
typename std::enable_if&lt;!std::is_base_of&lt;BaseClass, U&gt;::value, void&gt;::type print_line()
{
   std::cout &lt;&lt; "Parameter of general Type T" &lt;&lt; std::endl;
}
</code></pre>

<p>and the other one accordingly.</p>

<p>The idea behind both is to produce an error for one of the methods during the instantiation of the function templates. Due to the error, the corresponding method is not considered during overload resolution such that there is only one method (the one that did not produce the error) available, which will then be called. 
<code>std::enable_if</code> is used to produce this error, because if its first parameter is <code>false</code> it does not define a <code>type</code> member so the function template cannot be instantiated and will be removed from overloading resolution.</p>

<p>Search for SFINAE for more detailed information.</p>
