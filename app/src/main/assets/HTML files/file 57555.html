<p>Django CharField is a character-oriented format. You need to pass it Unicode strings.</p>

<p>CSV is a byte-oriented format. When you read data out of a CSV file you get byte strings.</p>

<p>To get from bytes to characters you have to know what encoding was used when the original characters were turned into bytes as the CSV file was exported. Ideally that would be UTF-8, but if the file has come out of Excel it probably won't be. Maybe it's Windows-1252 (âANSIâ code page for Western European installations). Maybe it's something else.</p>

<p>(Django/Python 2 lets you get away with writing byte strings to Unicode properties when you have only ASCII bytes in it (bytes 0â127) because those have the same mapping in a lot encodings. ASCII is a âbest guessâ at Do What I Mean, but it's not reliable and Python 3 prefers to raise errors if you try.)</p>

<p>So:</p>

<pre><code>new_order = Order(order=row[0].decode('windows-1252'))
</code></pre>

<p>or, to decode the whole row at once:</p>

<pre><code>row = [s.decode('windows-1252') for s in row]
</code></pre>
