<p>Are you thinking of something like this?</p>

<pre><code>enum Importance {

    High,
    Medium,
    Low;
}

class Thing implements Comparable&lt;Thing&gt; {

    private Importance importance = Importance.Medium;

    public Importance getImportance() {
        return importance;
    }

    public void setImportance(Importance importance) {
        this.importance = importance;
    }

    @Override
    public int compareTo(Thing o) {
        return importance.compareTo(o.importance);
    }

}
</code></pre>

<p>Alternatively - if you want to control the relativity of each object then record that in a Map. You will need to be careful to tightly control the map to ensure there are no cycles - if there is then your sorting will become unstable.</p>

<pre><code>static Map&lt;Thing, Set&lt;Thing&gt;&gt; moreImportant = new HashMap&lt;&gt;();

class Thing implements Comparable&lt;Thing&gt; {

    @Override
    public int compareTo(Thing o) {
        Set&lt;Thing&gt; more = moreImportant.get(this);
        return more == null ? 0 : more.contains(o) ? 1 : -1;
    }

}
</code></pre>
