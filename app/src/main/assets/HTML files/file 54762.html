<p>Clang provides an API called AST Matcher <a href="http://clang.llvm.org/docs/LibASTMatchersReference.html" rel="nofollow">(reference)</a>. </p>

<p>Compiling your code with <code>clang -Xclang -ast-dump -fsyntax-only test.c</code> dumps the AST. </p>

<pre><code>`-FunctionDecl 0x3b0a750 &lt;test_ast.cpp:1:1, line:9:1&gt; line:1:6 f 'void (void)'
  `-CompoundStmt 0x3b51958 &lt;col:10, line:9:1&gt;
    |-DeclStmt 0x3b0a8c8 &lt;line:2:3, col:13&gt;
    | `-VarDecl 0x3b0a848 &lt;col:3, col:11&gt; col:7 used a 'int' cinit
    |   `-IntegerLiteral 0x3b0a8a8 &lt;col:11&gt; 'int' 10
    `-ForStmt 0x3b51920 &lt;line:3:3, line:8:3&gt;
      |-DeclStmt 0x3b0a970 &lt;line:3:8, col:17&gt;
      | `-VarDecl 0x3b0a8f0 &lt;col:8, col:16&gt; col:12 used i 'int' cinit
      |   `-IntegerLiteral 0x3b0a950 &lt;col:16&gt; 'int' 0
      |-&lt;&lt;&lt;NULL&gt;&gt;&gt;
      |-BinaryOperator 0x3b0a9e8 &lt;col:19, col:23&gt; '_Bool' '&lt;'
      | |-ImplicitCastExpr 0x3b0a9d0 &lt;col:19&gt; 'int' &lt;LValueToRValue&gt;
      | | `-DeclRefExpr 0x3b0a988 &lt;col:19&gt; 'int' lvalue Var 0x3b0a8f0 'i' 'int'
      | `-IntegerLiteral 0x3b0a9b0 &lt;col:23&gt; 'int' 10
      |-UnaryOperator 0x3b0aa38 &lt;col:27, col:28&gt; 'int' postfix '++'
      | `-DeclRefExpr 0x3b0aa10 &lt;col:27&gt; 'int' lvalue Var 0x3b0a8f0 'i' 'int'
      `-CompoundStmt 0x3b51900 &lt;col:32, line:8:3&gt;
        `-IfStmt 0x3b518d0 &lt;line:4:5, line:7:5&gt;
          |-&lt;&lt;&lt;NULL&gt;&gt;&gt;
          |-BinaryOperator 0x3b51640 &lt;line:4:9, col:13&gt; '_Bool' '&gt;'
          | |-ImplicitCastExpr 0x3b51628 &lt;col:9&gt; 'int' &lt;LValueToRValue&gt;
          | | `-DeclRefExpr 0x3b515e0 &lt;col:9&gt; 'int' lvalue Var 0x3b0a848 'a' 'int'
          | `-IntegerLiteral 0x3b51608 &lt;col:13&gt; 'int' 10
          |-CompoundStmt 0x3b518a8 &lt;col:17, line:7:5&gt;
          | |-DeclStmt 0x3b51760 &lt;line:5:7, col:21&gt;
          | | `-VarDecl 0x3b51678 &lt;col:7, col:19&gt; col:11 used b 'int' cinit
          | |   `-BinaryOperator 0x3b51738 &lt;col:15, col:19&gt; 'int' '+'
          | |     |-ImplicitCastExpr 0x3b51720 &lt;col:15&gt; 'int' &lt;LValueToRValue&gt;
          | |     | `-DeclRefExpr 0x3b516d8 &lt;col:15&gt; 'int' lvalue Var 0x3b0a848 'a' 'int'
          | |     `-IntegerLiteral 0x3b51700 &lt;col:19&gt; 'int' 20
          | `-CompoundStmt 0x3b51888 &lt;line:6:7, col:25&gt;
          |   `-DeclStmt 0x3b51870 &lt;col:9, col:23&gt;
          |     `-VarDecl 0x3b51788 &lt;col:9, col:21&gt; col:13 c 'int' cinit
          |       `-BinaryOperator 0x3b51848 &lt;col:17, col:21&gt; 'int' '+'
          |         |-ImplicitCastExpr 0x3b51830 &lt;col:17&gt; 'int' &lt;LValueToRValue&gt;
          |         | `-DeclRefExpr 0x3b517e8 &lt;col:17&gt; 'int' lvalue Var 0x3b51678 'b' 'int'
          |         `-IntegerLiteral 0x3b51810 &lt;col:21&gt; 'int' 10
          `-&lt;&lt;&lt;NULL&gt;&gt;&gt;
</code></pre>

<p>You can use AST Matchers to walk through the AST and match against <code>CompoundStmt</code> which will give you nodes of the AST corresponding to scopes in C/C++. From this you can start tracking all <code>VarDecl</code> to find variable declartions inside the scopes. There is no out-of-the-box solution for what you want but Clang gives you the tools to implement it. </p>

<p>You can also read this blog post <a href="http://eli.thegreenplace.net/2014/05/01/modern-source-to-source-transformation-with-clang-and-libtooling" rel="nofollow">(link)</a> from Eli Bendersky. He demonstrates how you can use AST Matchers and Clang's rewriting facilities to write the tool you want. </p>
