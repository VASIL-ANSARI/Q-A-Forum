<p>You cannot pass an array to/from a function in C. But you can pass a pointer. And that can point to an array.</p>

<p>So, you need a function like:</p>

<pre><code>#define COLS 2

int (*getValid(int blank[2]))[COLS]
{
    static int valid[4][COLS];
    ...
    return valid;
}
</code></pre>

<p>Mind the parenthesis. I also use <code>COLS</code> for the innter dimension's length. This avoids <em>magic numbers</em>, i.e. repeating constants throughout your code. Use that macro for all declarations the array is involved, including the definition.</p>

<p>This is a "function without arguments returning a pointer to an 1D array with <code>COLS</code> <code>int</code>s". For details about arrays and pointers in C, please see a good C book and do some research on your own. Just keep in mind that while they are different types, they have a lot in common <em>in practical use</em> (language mechanisms behind are more difficult to understand).</p>

<p>Simply said, if you use <code>return valid</code> with the above declaration of the function, the name of the array is converted to a pointer to the first element. Which is exactly what you shall return.</p>

<p>The caller need to use the same pointer type (pointer to 1D array) for the result:</p>

<pre><code>int (*arr)[COLS] = getValid(...);
</code></pre>

<p>The elements are accessed like for the original array:</p>

<pre><code>arr[row][col]
</code></pre>

<hr>

<p>Additional information: You should not use a static array in the function, unless you want to safe state between calls. Better allocate the array dynamically with <code>malloc</code>:</p>

<pre><code>int (*arr)[COLS];
arr = malloc(sizeof(*arr) * 4); // 4 rows of the inner array
</code></pre>

<p>Don't forget to check if <code>malloc</code> failed and take appropriate measures.</p>

<p>Also don't forget to release the dynamically allocated array once you're done with it (<strong>but not earlier</strong>):</p>

<pre><code>free(arr);
</code></pre>
