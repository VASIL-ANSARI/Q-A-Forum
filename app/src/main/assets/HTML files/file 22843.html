<p>Try this:</p>

<pre><code>template &lt;typename T, typename=void&gt;
struct B : A
{
  ...
};

temlate &lt;typename T&gt;
struct B&lt;T, typename std::enable_if&lt;...some condition...&gt;::type&gt;:
  A
{
  virtual int f() const override { return 1; }
};
</code></pre>

<p>where we have two versions of <code>B&lt;T&gt;</code>, one for which the condition is true (the <code>enable_if</code> one), one for which the condition is false (the default one).</p>

<p>If you wanted to be able to reuse your default <code>B</code> implementation, you could even do this:</p>

<pre><code>template &lt;typename T, typename=void&gt;
struct B : A
{
  ...
};

temlate &lt;typename T&gt;
struct B&lt;T, typename typename std::enable_if&lt;...some condition...&gt;::type&gt;:
  B&lt;T, bool&gt;
{
  virtual int f() const override { return 1; }
};
</code></pre>

<p>where we inherit from the "false" case in the "true" case.  But that is a bit dirty to me -- I'd rather put the common implementation in some third spot (<code>B_impl</code>) rather than that hack.  (That also lets you static assert that the second argument is <code>void</code> in the first case of <code>B</code>).</p>
