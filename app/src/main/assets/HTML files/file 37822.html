<p>In the main you show the JFrame:</p>

<pre><code>new JavaGame().setVisible(true);
</code></pre>

<p>and then you return from main.</p>

<p>In the background there is a thread running, called EDT, event dispatching thread.
On that thread button clicks, repainting and so on are handled.</p>

<p>That should be done in a short period, to keep the user interface responsive, not freezed.</p>

<p>So you need to work <strong>event driven</strong>: you can often add a listener for some specific event, like closing the JFrame, menu items, buttons. Those listeners are called with an event object specifying what happened. You called addActionListener.</p>

<p>The control flow is to keep the button click responsive, and doing hard work a bit later:</p>

<pre><code>@Override
public void actionPerformed(ActionEvent evt) {
    EventQueue.invokeLater(new Runnable() {
        @Override
        public void run() {
            JavaGame.this.createANewAvatar();
        }
    });
}
</code></pre>

<p>And then somewhere have a</p>

<pre><code>private void createNeewAvatar() { ... }
</code></pre>

<p>This hard to follow control-flow (because fragmentary) needs a good naming, and organized sources.</p>
