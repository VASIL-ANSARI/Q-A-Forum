<p>Let us add <code>System.out.println(name + " :: waits");</code> before <code>count.wait()</code> call.</p>

<p>Then the first case log:</p>

<pre><code>T2 :: waits
T1 :: 1
T1 :: waits
T2 :: 2
T2 :: waits
T1 :: 3
T1 :: waits
T2 :: 4
T2 :: waits
T1 :: 5
T1 :: waits
T2 :: 6
T2 :: waits
T1 :: 7
T1 :: waits
T2 :: 8
T2 :: waits
T1 :: 9
T1 :: waits
T2 :: 10
</code></pre>

<p>The 2nd case log:</p>

<pre><code>T1 :: 1
T1 :: waits
T2 :: 2
T2 :: 3
T1 :: 4
T1 :: 5
T1 :: 6
T1 :: 7
T1 :: 8
T1 :: 9
T1 :: 10
T1 :: 11
T2 :: 12
T2 :: 13
T2 :: 14
T2 :: 15
T2 :: 16
T2 :: 17
T2 :: 18
</code></pre>

<p>As you can see in the 2nd case threads don't sleep. Why? Because in the second case each thread increases counter <strong>twice</strong> (one time in first <code>if</code> and one time in second <code>if</code>) (and do it in synchronized way). <em>(I can assume that you didn't want this logic and this is the error you made).</em> What the difference between the cases? In the first case <code>T2</code> starts earlier and goes to wait in the first if and after been notified it wakes up and goes to the second if, i.e. it increases (and prints) the counter only one time per iteration. That's why.</p>
