<p>Yes. All local variables (variables defined within a method) will be on their own Stack frame. So, they will be thread safe, provided a reference is not <em>escaping</em> the scope (method)</p>

<p>Note : If a <em>local</em> reference escapes the method (as an argument to another method) or a method works on some class level or instance level fields, then it is <em>not</em> thread-safe. </p>

<p><strong>Does it mean that every thread gets a "copy" of the method even if it belongs to the same instance</strong></p>

<p>No, there will be only <strong>one</strong> method. every thread shares the <em>same</em> method. But each Thread will have its own Stack Frame and local variables will be on that thread's Stack frame. Even if you use synchronize on local Objects, <em>Escape Analysis</em> proves that the JVM will optimize your code and remove all kinds of synchronization.</p>

<p>example :</p>

<pre><code>public static void main(String[] args) {

    Object lock = new Object();
    synchronized (lock) {
        System.out.println("hello");
    }
}
</code></pre>

<p>will be effectively converted to :</p>

<pre><code>public static void main(String[] args) {

        Object lock = new Object(); // JVm might as well remove this line as unused Object or instantiate this on the stack
        System.out.println("hello");

}
</code></pre>
