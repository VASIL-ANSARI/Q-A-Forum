<p>This is not an answer, but I have a lot to say, it wouldn't fit in comments.</p>

<p><strong>Some fact:</strong> EF context is not thread safe and doesn't support parallel execution:</p>

<blockquote>
  <p>While thread safety would make async more useful it is an orthogonal feature. It is unclear that we could ever implement support for it in the most general case, given that EF interacts with a graph composed of user code to maintain state and there aren't easy ways to ensure that this code is also thread safe.</p>
  
  <p>For the moment, EF will detect if the developer attempts to execute two async operations at one time and throw.</p>
</blockquote>

<p><strong>Some prediction:</strong>
You say that:</p>

<blockquote>
  <p>The parallel execution of the other four tasks has been in production for months without deadlocking.</p>
</blockquote>

<p>They can't be executing in parallel. One possibility is that the thread pool cannot assign more than one thread to your operations, in that case they would be executed sequentially. Or it could be the way you are initializing your tasks, I'm not sure. Assuming they are executed sequentially (otherwise you would have recognized the exception I'm talking about), there is another problem:</p>

<p><a href="http://stackoverflow.com/questions/12981490/task-waitall-hanging-with-multiple-awaitable-tasks-in-asp-net?lq=1">Task.WaitAll hanging with multiple awaitable tasks in ASP.NET</a></p>

<p>So maybe it isn't about that specific task <code>SomeProduct</code> but it always happens on the last task? Well, if they executed in parallel, there wouldn't be a "last task" but as I've already pointed out, they must be running sequentially considering they had been in production for quite a long time.</p>
