<p>You can use
<code>string::find_first_of("0123456789")</code> to get the position of the first digit, then <code>string::find_last_of("0123456789")</code> to get the position of the last digit, and finally use an <code>atoi</code> on the substring defined by the two positions. I cannot think of anything simpler (without regex). </p>

<p>BTW, this works only when you have a single number inside the string.</p>

<p>Here is an example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
using namespace std;

int main()
{
    string s = "testing;lasfkj358kdfj-?gt";
    size_t begin = s.find_first_of("0123456789");
    size_t end = s.find_last_of("0123456789");
    string num = s.substr(begin, end - begin + 1);
    int result = atoi(num.c_str());
    cout &lt;&lt; result &lt;&lt; endl;
} 
</code></pre>

<p>If you have more than 1 number, you can combine <code>string::find_first_of</code> with <code>string::find_first_not_of</code> to get the beginning and the end of each number inside the string.</p>

<p>This code is the general solution:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;

using namespace std;

int main()
{
    string s = "testing;lasfkj358kd46fj-?gt"; // 2 numbers, 358 and 46

    size_t begin = 0, end = 0; 

    while(end != std::string::npos)
    {
        begin = s.find_first_of("0123456789", end);
        if(begin != std::string::npos) // we found one
        {
            end = s.find_first_not_of("0123456789", begin);
            string num = s.substr(begin, end - begin);
            int number = atoi(num.c_str());
            cout &lt;&lt; number &lt;&lt; endl;
        }
    }
}
</code></pre>
