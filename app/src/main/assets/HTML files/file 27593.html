<p>SQLite itself does not support <code>GUID</code> as internal type.</p>

<p>Except that, it does! (sort of). Remember, in SQLite any string can be used as type name, and that includes <code>GUID</code> or <code>UUID</code> (read more about <a href="http://www.sqlite.org/datatype3.html">SQLite datatypes</a>).</p>

<p>According to those rules, <code>GUID</code> type has affinity <code>NONE</code>, which is the same as for <code>BLOB</code> fields. With this in mind, you can create column of <code>GUID</code> type, and use following rules to access it:</p>

<ul>
<li><p>Store it as string like <code>X'01020304050607080910111213141516'</code> (X notation is used to represent 16 byte <code>BLOB</code> value).
To insert, use:</p>

<pre><code>INSERT INTO mytable (uuid)
VALUES (X'01020304050607080910111213141516');
</code></pre></li>
<li><p>Read it as 16-byte <code>BLOB</code>. <code>quote(uuid)</code> can be used to format output using X notation:</p>

<pre><code>SELECT quote(uuid)
FROM mytable
</code></pre></li>
</ul>

<p>Such column can be also used as primary key. Unfortunately, there is no AUTOINCREMENT functionality like it exists for integer primary keys - you will have to handle it yourself. You can use something as simple as <code>randomblob(16)</code> for that, but it is not quite <code>UUID</code> as defined <a href="https://en.wikipedia.org/wiki/Uuid">by standard</a>.</p>

<p>Confusingly, you can also store text representation of UUID in the same field (SQLite won't stop you from doing that), but it will take at least 2x more space: BLOB is 16 bytes, UUID as text is at least 32 bytes. </p>
