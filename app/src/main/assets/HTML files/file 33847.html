<p>You might want to look at how <a href="http://www.cgal.org/" rel="nofollow">CGAL</a> is doing things. At least they have <a href="http://doc.cgal.org/latest/Boolean_set_operations_2/group__boolean__join.html#gad52000fb393e22aefbe29eb2842af527" rel="nofollow">a function</a> to join more than one polygon. Looking at the code, I notice a call to a function <code>_devide_and_conquer</code>. Which should translate to <code>boost</code> as well: divide the list of polygons into two, compute the union for each then the union of both. At least if the resulting polygon is still more complex than the original ones, this should give you some improvement.</p>

<p>If that is still not enough, you might give CGAL a try to see if there is any other magic which makes it faster than boost. If not, you might have to implement the computation yourself.</p>

<p>I guess I'd sort polygon edges in order of increasing <code>x</code> value of the left endpoint. Then you can iterate over edges of all polygons in parallel while keeping track of the outer boundaries of your union so far. Any edges which lies fully within the current bounds of the union could be omitted pretty quickly. But making the implementation robust in the face of numeric inexactness is likely a major problem if you tackle this yourself. You might want to look at <a href="http://www.cs.cmu.edu/~quake/robust.html" rel="nofollow">robust predicates</a> for this.</p>
