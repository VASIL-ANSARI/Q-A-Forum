<p>This type of data transformation is known as a <code>PIVOT</code>. Starting in SQL Server 2005 there is a function that will perform this for you.</p>

<p>If you know the values ahead of time, then you can hard-code the query similar to this: </p>

<pre><code>select *
from
(
  select id,
    [Emp_ID], 
    cast([ontime] as date) ontime
  from test
) src
pivot
(
  count(id)
  for ontime in ([2013-02-11], [2013-02-12], [2013-02-13])
) piv
</code></pre>

<p>See <a href="http://www.sqlfiddle.com/#!3/ba823/7" rel="nofollow">SQL Fiddle with Demo</a>.</p>

<p>If you have an unknown number of columns to transform, then you will want to use dynamic SQL. This can be further filtered by using a <code>WHERE</code> clause to find only certain dates:</p>

<pre><code>DECLARE @cols AS NVARCHAR(MAX),
    @query  AS NVARCHAR(MAX)

select @cols = STUFF((SELECT distinct ',' + QUOTENAME(cast([ontime] as date)) 
                    from test
            FOR XML PATH(''), TYPE
            ).value('.', 'NVARCHAR(MAX)') 
        ,1,1,'')

set @query = 'SELECT emp_id,' + @cols + ' from 
             (
                select Emp_ID pivId,
                  [Emp_ID], 
                  cast([ontime] as date) ontime
                from test
            ) x
            pivot 
            (
                count(pivId)
                for ontime in (' + @cols + ')
            ) p '

execute(@query)
</code></pre>

<p>See <a href="http://www.sqlfiddle.com/#!3/ba823/15" rel="nofollow">SQL Fiddle with Demo</a>.</p>

<p>If you want to guarantee that you will return the dates that you want, then you can generate a list of dates first.  So you entire dynamic SQL script will be:</p>

<pre><code>declare @startdate datetime
declare @enddate datetime

set @startdate = '2013-02-11'
set @enddate = '2013-02-13'

;with cte (startdate) as
(
  select @startdate
  union all
  select DATEADD(dd, 1, startdate)
  from cte
  where DATEADD(dd, 1, startdate) &lt;= @enddate
)
select *
into #tempDates
from cte;    

DECLARE @cols AS NVARCHAR(MAX),
    @query  AS NVARCHAR(MAX)

select @cols = STUFF((SELECT distinct ',' + QUOTENAME(cast(startdate as date)) 
                    from #tempDates
            FOR XML PATH(''), TYPE
            ).value('.', 'NVARCHAR(MAX)') 
        ,1,1,'')

set @query = 'SELECT emp_id,' + @cols + ' from 
             (
                select Emp_ID pivId,
                  [Emp_ID], 
                  cast([ontime] as date) ontime
                from test
            ) x
            pivot 
            (
                count(pivId)
                for ontime in (' + @cols + ')
            ) p '

execute(@query)
</code></pre>

<p>See <a href="http://www.sqlfiddle.com/#!3/84ad0/4" rel="nofollow">SQL Fiddle with Demo</a>.  This returns the result:</p>

<pre><code>| EMP_ID | 2013-02-11 | 2013-02-12 | 2013-02-13 |
-------------------------------------------------
|      1 |          2 |          0 |          1 |
|      2 |          1 |          0 |          1 |
|      3 |          0 |          0 |          1 |
</code></pre>

<p>Edit #1, if you want to include all employees, then you will want to use a JOIN on another table and your code would be similar to this:</p>

<pre><code>declare @startdate datetime
declare @enddate datetime

set @startdate = '2013-02-11'
set @enddate = '2013-02-13'

;with cte (startdate) as
(
  select @startdate
  union all
  select DATEADD(dd, 1, startdate)
  from cte
  where DATEADD(dd, 1, startdate) &lt;= @enddate
)
select *
into #tempDates
from cte;    

DECLARE @cols AS NVARCHAR(MAX),
    @query  AS NVARCHAR(MAX)

select @cols = STUFF((SELECT distinct ',' + QUOTENAME(cast(startdate as date)) 
                    from #tempDates
            FOR XML PATH(''), TYPE
            ).value('.', 'NVARCHAR(MAX)') 
        ,1,1,'')

set @query = 'SELECT emp_id, Emp_name,' + @cols + ' from 
             (
                select e.Emp_ID pivId,
                  e.[Emp_ID], 
                  e.Emp_name,
                  cast([ontime] as date) ontime
                from Emp_Table e
                left join test t
                  on e.emp_id = t.emp_id
            ) x
            pivot 
            (
                count(pivId)
                for ontime in (' + @cols + ')
            ) p '

execute(@query)
</code></pre>

<p>See <a href="http://www.sqlfiddle.com/#!3/7e561/5" rel="nofollow">SQL Fiddle with Demo</a></p>
