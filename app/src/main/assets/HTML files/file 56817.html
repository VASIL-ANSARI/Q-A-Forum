<p>When <code>scanf</code> reaches the spot with an invalid character <code>'a'</code> it tries to read it with <code>%d</code> format specifier. Since this does not work, <code>scanf</code> leaves <code>'a'</code> in the buffer, and returns <code>0</code> for the number of items read from the input.</p>

<p>Since your code tries reading <code>%d</code> again, nothing happens: the buffer stays where it was before the read, with <code>'a'</code> as the next character. This continues until the count <code>n</code> is exhausted.</p>

<p>Fix this problem by adding code that reads from the input until it reaches <code>'\n'</code> or <code>EOF</code> after the inner loop is exited:</p>

<pre><code>do {
    ... // This is your reading loop
} while (c != '\n');
// We can reach this line either because `c` is `'\n'`, or because of an error
// If we are here due to an error, read until the next `'\n'`
while (c != '\n') {
    if (fscanf(fp, "%c", &amp;c) == 0) {
        break; // We are at the end of file
    }
}
</code></pre>
