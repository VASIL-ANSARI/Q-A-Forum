<p>The first argument to <code>qsort</code> is the pointer to the start of the array to be sorted. Instead of</p>

<pre><code>qsort(i[5], 5, sizeof(double), sort);
</code></pre>

<p>it should read</p>

<pre><code>qsort(i, 5, sizeof(double), sort);
</code></pre>

<p>Some further observations:</p>

<ol>
<li>The length of <code>i</code>'s initializer is incorrect (<code>i</code> has five elements, yet the initializer has six).</li>
<li>Hard-coding the 5 into the <code>qsort</code> call is asking for trouble later on.</li>
<li>The name "<code>i</code>" is most commonly used for loop counters and the like.</li>
<li>Calling the comparison function <code>sort</code> is confusing.</li>
<li>Your comparison function is wrong. Consider how it would compare the numbers <code>1.1</code> and <code>1.2</code>. Also think about what would happen if the difference between the two values doesn't fit in an <code>int</code>.</li>
</ol>

<p>I would rewrite your entire example like so:</p>

<pre><code>double arr[] = {1.023, 1.22, 1.56, 2, 5, 3.331};

int cmp(const void *x, const void *y)
{
  double xx = *(double*)x, yy = *(double*)y;
  if (xx &lt; yy) return -1;
  if (xx &gt; yy) return  1;
  return 0;
}

int main() {
  qsort(arr, sizeof(arr)/sizeof(arr[0]), sizeof(arr[0]), cmp);
}
</code></pre>

<p>Note that the above comparison function still doesn't correctly handle NaNs; I leave it as an exercise for the reader to fix that.</p>
