<p>You can do it in lot of ways and all will have drawbacks like you already found. I guess there is no "best" way to do that.</p>

<p>A common way for games is to have a "game server". The server recieves input from all clients and decides about the resulting state.</p>

<p>Clients could for example just transmit the keypresses and the server tells them about their location and location of other clients that need to be drawn. Clients do the same math locally and display this state while waiting for confirmation from the server. But that's just a prediction.</p>

<p>When it lags you can observe yourself jumping between positions in a lot of games because actual server calculated position and your prediction got out of sync.</p>

<p>The other advantage of server-side state decisions is that clients can't cheat that easily. It's no foolproof way to prevent every cheat. Aim-bots for example simply simulate a perfectly aiming user by moving the mouse for them and that's basically not detectable. Map hacks / wall hacks (anything where you can see things that you would not see) on the other hand can be prevented by simply not telling the client about currently invisible things. Only the server needs to know the full state.</p>

<p>The server approach can also be used without a dedicated game server. Instead, one of the clients will have the role of the server and decide about the game state. That responsibility can in some games even switch between clients if the original host drops out. A smooth handover if that happens is rather tricky though.</p>

<p>If there is no server and all clients are equally responsible you will have to think about schema which defines which client is responsible for validating which action. For example in a shooter, A shoots in a certain direction, and thinks B is still there but B already moved a bit further and now A thinks "B was hit" and B thinks "shot missed" -> Either the one shooting or the one being hit should decide what happens.</p>

<p>A schema with multiple decision making parties might not work for every game and it is a very complicated task. Not just for games but <a href="http://c2.com/cgi/wiki?DistributedSharedStateConcurrency" rel="nofollow">distributed computing in general</a></p>

<p>Java and Sockets are just tools here. The actual problem is one where you should take pen and paper and think about a schema that works for your scenario.</p>

<p>Regarding coordinates every milisecond: you could also send messages like "I will be at point X,Y at time Z" and other clients interpolate the path of that player so you don't have to transmit every position.</p>
