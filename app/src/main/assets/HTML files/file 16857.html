<p>It will not work this way, you are <em>sharing nodes</em> between trees with same memory location. Think about if you change data on Tree 1, it will affect immediately to Tree 2.</p>

<p>It would be suggested to do <em>Deep Copy</em> on <code>TreeListNode</code> with <code>DeepClone</code> method:</p>

<pre><code>public static class CloneHelper
{
    public static T DeepClone&lt;T&gt;(T obj)
    {
        using (var ms = new MemoryStream())
        {
            var formatter = new BinaryFormatter();
            formatter.Serialize(ms, obj);
            ms.Position = 0;

            return (T) formatter.Deserialize(ms);
        }
    }
}
</code></pre>

<p>Then you can use:</p>

<pre><code>var cloneNodes = nodes.Select(node =&gt; CloneHelper.DeepClone&lt;TreeListNode&gt;(node))
                      .ToArray();

trTree.Nodes.AddRange(cloneNodes);
</code></pre>

<p><strong>Edit:</strong></p>

<p>Of course you need to make sure <code>TreeListNode</code> is marked as [Serializale]</p>

<p>Another approach, you need to re-build the second tree with the data used in the first tree</p>
