<p>Clarified answer, following comment below:</p>

<p>What you say makes no sense at all; You say that you have the raw, unmodified, RGB data. No you don't. You have the <strong>uncompressed</strong> data that has been <strong>reconstructed</strong> from the <strong>compressed</strong> jpeg file.  </p>

<p>The JPEG standards specify how to un-compress an image / video. There is nothing in the standard about how to actually do this compression, so your original image data could have been compressed any one of a zillion different ways. You have no way of knowing the decoding steps that were required to recreate your data, so you cannot reverse them.</p>

<p>Image this. </p>

<blockquote>
  <p>"I have a number, 44, please tell me how I can get the original
  numbers that this came from"</p>
</blockquote>

<p>This is, essentially, what you are asking.</p>

<p>The only way you can do what you want (other than just copy the original file) is to read the image into an array <em>before</em> loading into openCV. Then if you want to save it, then just write the raw array to a file, something like this:</p>

<pre><code>fi = 'C:\\Path\\to\\Image.jpg'
fo = 'C:\\Path\\to\\Copy_Image.jpg'
with open(fi,'rb') as myfile:
    im_array = np.array(myfile.read())

# Do stuff here

image = cv2.imdecode(im_array)

# Do more stuff here

with open(fo,'wb') as myfile:
    myfile.write(im_array)
</code></pre>

<p>Of course, it means you will have the data stored twice, effectively, in memory, but this seems to me to be your only option.</p>

<p>Sometimes, no matter how hard you want to do something, you have to accept that it just cannot be done.</p>
