<p>You've stumbled onto an obscure corner case with <code>.replaceWith()</code> which results in a bug. What happens is:</p>

<ul>
<li>by destroying the first node you also destroy the following sibling yourself</li>
<li><code>.replaceWith</code> calls that destroy function, then tries to insert a new node before the now non-existent sibling</li>
<li>it throws a <code>NotFoundError</code> on the missing node</li>
</ul>

<p>You can work around this fairly simply if you "simulate" what <code>replaceWith</code> does yourself: first append the new element, and only after that call <code>remove</code>:</p>

<pre><code>$("#widget").next().before("&lt;div id=\"secondWidget\"&gt;&lt;/div&gt;");
$("#widget").remove();
</code></pre>

<p>Fiddle: <a href="http://jsfiddle.net/w7Lqfzcc/1/" rel="nofollow">http://jsfiddle.net/w7Lqfzcc/1/</a></p>

<hr>

<p>If this is not an option (as mentioned in the comment) you can do something slightly different: instead of calling <code>.remove</code> directly, just add a class with <code>display:none</code>, and clean it up later:</p>

<pre><code>this.widgetContent.addClass("inactive");

.widgetContent.inactive { display:none; }
</code></pre>

<p>Fiddle: <a href="http://jsfiddle.net/w7Lqfzcc/3/" rel="nofollow">http://jsfiddle.net/w7Lqfzcc/3/</a> [note I replaced the id with a class in the fiddle; using id-s for generated child elements doesn't make much sense]</p>

<p>This is messy, but it's the simplest way to tackle the awkward widget-generated-sibling structure you have. If you feel like cleaning it up, using some sort of widget-level container is the first thing you should look into.</p>
