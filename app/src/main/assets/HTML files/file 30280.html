<p>Putting the implementation of a method in the header file doesn't make it inline. Putting it in the class declaration does. I'll assume that's what you meant from now on.</p>

<p>What is important here is that declaring a function inline is only an information to the compiler, <strong>it does not necessarily make that function inline</strong></p>

<p>Most of the time, the compiler will just ignore this and the method won't be inlined.</p>

<p>It's possible to have a virtual method inline though, as stated in the c++ faq (<a href="http://www.parashift.com/c++-faq-lite/inline-virtuals.html" rel="nofollow">http://www.parashift.com/c++-faq-lite/inline-virtuals.html</a>) : 
"The only time an inline virtual call can be inlined is when the compiler knows the "exact class" of the object which is the target of the virtual function call. This can happen only when the compiler has an actual object rather than a pointer or reference to an object. I.e., either with a local object, a global/static object, or a fully contained object inside a composite."</p>

<p>In short, the compiler will inline a virtual method only if you don't use dynamic link resolution (we could say, "when we don't use the virtual").</p>
