<p>You can still go with the mediator, but implement your business logic inside it. So, instead of <code>mediator.getCertainState()</code>, have a method <code>mediator.canTakeAction()</code> which knows about the widget(s) to query, and determine if the action is allowed.</p>

<p>This will still end up with a mediator which knows the widgets to query, of course. But since we've offloaded the business logic inside the mediator, I think it is OK for it to know of such things. It may even be the entity that creates these widgets. Alternatively, you can use some sort of registration mechanism where you tell your mediator which widget is used for what role when you create them.</p>

<hr>

<p>EDIT: Providing an example in the spirit of the given code samples.</p>

<pre><code>MyApp.DeleteCommand=(function(itemsListBox, readOnlyCheckBox) {
  var self = {};

  self.canExecute = function() {
    return (not readOnlyCheckBox.checked()) &amp;&amp; (itemsListBox.itemCount() &gt; 0);
  }

  return self;
})(MyApp.Widgets.ItemsList, MyApp.Widgets.ReadOnly);
</code></pre>

<p>You can take this two steps further:</p>

<ol>
<li>Register to state changed events of the source widgets, and update a local cache of the canExecute every time a state change occurs on one of the source widgets.</li>
<li>Also take a reference to a third control (say, to the delete button), and enable or disable the button according to the state.</li>
</ol>
