<p>In the first case, why do you care about the file itself, if you're testing file name generation?  You don't want to test FileOutputStream.</p>

<p>I'm assuming your method looks something like this:</p>

<pre><code>public File buildComplexFileStructure() {
    // code
}
</code></pre>

<p>Your test would look something like this:</p>

<pre><code>@Test public void test() throws Exception {
    File expected = &lt;what you expect to be generated&gt;;
    File actual = new DefaultLogService().buildComplexFileStructure();
    assertEquals(expected, actual);
}
</code></pre>

<p>If that method isn't exposed publicly, then just expose it to the test (default or protected).</p>

<p>In the second case, couldn't you pass a ByteArrayOutputStream from your test test into your method, then verify what was written to it?  i.e.:</p>

<pre><code>@Test public void test() throws Exception {
    btye[] expected = &lt;expected data&gt;;
    ByteArrayOutputStream actualStream = new ByteArrayOutputStream();
    new DefaultComplexDataSerializer().write(actualStream, data);
    byte[] actualData = actualStream.toByteArray();
    // compare expected and actualData
}
</code></pre>
