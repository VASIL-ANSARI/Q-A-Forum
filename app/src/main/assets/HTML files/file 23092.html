<p>This is an interesting idea. The easiest way to do this in zipline is to use the Returns transform which adds a returns field to the event-frame (which is an ndict, not a pandas DataFrame as someone pointed out).</p>

<p>For this you have to add the transform to the initialize method:
<code>
self.add_transform(Returns, 'returns', window_length=1)
</code></p>

<p>(make sure to add <code>from zipline.transforms import Returns</code> at the beginning).</p>

<p>Then, inside the batch_transform you can access returns instead of prices:</p>

<pre><code>@batch_transform
def ols_transform(data, sid1, sid2):
    """Computes regression coefficient (slope and intercept)
    via Ordinary Least Squares between two SIDs.
    """
    p0 = data.returns[sid1]
    p1 = sm.add_constant(data.returns[sid2])
    slope, intercept = sm.OLS(p0, p1).fit().params

    return slope, intercept
</code></pre>

<p>Alternatively, you could also create a batch_transform to convert prices to returns like you wanted to do. </p>

<pre><code>@batch_transform
def returns(data):
    return data.price / data.price.shift(1) - 1
</code></pre>

<p>And then pass that to the OLS transform. Or do this computation inside of the OLS transform itself.</p>

<p>HTH,
Thomas</p>
