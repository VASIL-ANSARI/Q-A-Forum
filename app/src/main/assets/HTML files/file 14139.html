<p>Yes, this is expected behavior. Function arguments are evaluated when the function is called. The decorator is a function that's called when the function being decorated is defined. Therefore, the flag is tested when the decorated function is defined. The decorator has no way to know what the test even was; it only sees <code>True</code> or <code>False</code> (or more likely, truthiness or falsiness) so it can't store the condition away for later evaluation.</p>

<p>For <code>skipIf()</code> to work as you want, it would need to take a function (e.g. <code>lambda: Settings.flag==True</code>) rather than a Boolean value. Then it would be able to evaluate this condition later, when the decorated function is actually called. But it doesn't actually work that way. (This would probably be an easy enhancement to add, though.)</p>

<p>You may be able to work around this by not importing the module containing your unit tests until after the value of <code>Settings.flag</code> has been established. This will defer the definition (and thus the decoration) of your test functions until then, and the decorator will have access to the desired value of the flag. Not knowing how your code is structured, I don't know whether this is practical for you.</p>

<p>Additionally, something looks fishy about <code>Settings.flag==True</code>... can't quite put my finger on it... ;-)</p>
