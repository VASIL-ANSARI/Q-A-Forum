<p>You don't seem to understand the concept of <strong>recursion</strong> so I would advise you look it up. Here's an algorithm in C# for reference, not tested beyond the one example in the paper but it should work. I ignored the "and quit if m=1" part as I don't think that's needed. Note how the function Peak() calls itself from within itself, but with changed parameters.</p>

<pre><code>    static void Peak(int[,] map, int left, int right)
    {
        // calculate middle column
        int column = (right + left) / 2;


        // get max row in column
        int arow = 0;
        for (int row = 0; row &lt; map.GetLength(0); row++)
            if (map[row, column] &gt; map[arow, column])
                arow = row;

        int a = map[arow, column];

        // get left value
        int b = 0;
        if (column - 1 &gt;= left) b = map[arow, column - 1];
        // get right value
        int c = 0;
        if (column + 1 &lt;= right) c = map[arow, column + 1];

        // if left is higher, recurse left
        if (b &gt; a) Peak(map, left, column - 1);
        // else if right is higher, recurse right
        else if (c &gt; a) Peak(map, column + 1, right);
        // else, peak
        else Console.WriteLine("Peak: " + arow + " " + column + " " + a);
    }

    static void Main(string[] args)
    {
        int[,] map = { {12, 8, 5},
                       {11, 3, 6 },
                       {10, 9, 2 },
                       { 8, 4, 1 } };
        Peak(map, 0, 2);
        Console.ReadLine();
    }
</code></pre>
