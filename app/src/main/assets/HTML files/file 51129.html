<p>The best way would be to have this structure instead:</p>

<pre><code>public Humanoid(Race race, Gender gender, string firstname, string lastname = null)
{
    this.Limbs = new List&lt;ILimb&gt;();
    this.Limbs.Add(new Legs() { Limbs = new List&lt;Limb&gt;() { new Leg(), new Leg() });
    this.Limbs.Add(new Torso());
    this.Limbs.Add(new Arms() { Limbs = new List&lt;Limb&gt;() { new Arm(), new Arm() });
    this.Limbs.Add(new Heads() { Limbs = new List&lt;Limb&gt;() { new Head() { Limbs = new List&lt;Limb&gt;() .... , ... });
}
</code></pre>

<p>you can tidy the code up but basically it should have a collection of limbs, and limbs should have collections of limbs so that you can have Head > Ears > Ear or whatever hierarchy you wish.</p>

<p>Then in your ILimb interface, give it a Limbs property</p>

<pre><code>public interface ILimb
{
    List&lt;ILimb&gt; Limbs { get; set; }
    List&lt;ILimb&gt; GetAllLimbs { get; }
}
</code></pre>

<p>And create an abstract base class Limb with this method:</p>

<pre><code>public virtual GetAllLimbs()
{
// pseudocode: something like this (basically recurse through the children)
return this.Limbs().foreach (c =&gt; c.GetAllLimbs()).union(this.Limbs());
}
</code></pre>

<p>Then it can crawl down the hierarchy easily and retrieve every limb.</p>

<p>So you could do </p>

<p><code>myHumanoid.GetAllLimbs().Where(c =&gt; c is Arm).TakeDamage(5);</code></p>

<p>for example.</p>
