<ul>
<li><p>Yes, it is very usual to pass a dictionary to Python functions in order to reduce the number of arguments. Dictionary-style configuration with proper key naming is much more readable than just using tuples.</p></li>
<li><p>I consider it rather uncommon to dynamically construct dedicated instances of a custom config class. I'd stick with dictionaries for that. In case your config dict and the consumer of it go out of sync, you get <code>KeyError</code>s, which are pretty good to debug.</p></li>
</ul>

<p><strong>Some recommendations and reasoning:</strong></p>

<p>If some parts of your application require really really complex configuration, I consider it a good idea to have a configuration object that properly represents the current config. However, in my projects I never ended up passing such objects as function arguments. This smells. In some applications, I have a <em>constant</em> global configuration object, set up during bootstrap. Such an object is globally available and treated as "immutable".</p>

<p>Single functions should never be so complex that they require to retrieve a tremendously complex configuration. This indicates that you should split your code into several components, each subunit having a rather simple parameterization.</p>

<p>If the runtime configuration of a function has a somewhat higher complexity than it is easily dealt with normal (keyword)arguments, it is absolutely common to pass a dictionary, so to say as a "leightweight" configuration object. A well thought-through selection of key names makes such an approach very well readable. Of course you can also build up a hierarchy in case one level is not enough for your use case.</p>

<p>Most importantly, please note that in many cases the best way is to explicitly define the parameterization of a function via its signature, using the normal argument specification:</p>

<pre><code>def f(a, b, c, d, e):
    ...
</code></pre>

<p>In the calling code, you can then prepare the values for these arguments in a dictionary:</p>

<pre><code>arguments = {
    a = 1,
    b = 2,
    c = 3,
    d = 4,
    e = "x"
}
</code></pre>

<p>and then use Python's snytactic sugar for keyword expansion upon function call:</p>

<pre><code>f(**arguments)
</code></pre>
