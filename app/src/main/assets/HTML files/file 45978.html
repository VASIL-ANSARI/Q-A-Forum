<p>No. Using an <code>io_service</code> object per connection is definitely a smell. Especially since you're also running each connection on a dedicated thread.</p>

<p>At this point you have to ask yourself what did asynchrony buy you? You can have all the code synchronous and have exactly the same number of threads etc.</p>

<p>Clearly you want to multiplex the connections onto a far smaller number of services. In practice there are a few sensible models like </p>

<ol>
<li><p>a single <code>io_service</code> with a single service thread (this is usually good). No tasks queued on the service may ever block for significant time or the latency will suffer</p></li>
<li><p>a single <code>io_service</code> with a number of threads executing handlers. The number of threads in the pool should be enough to service the max. number of simultaneous CPU intensive tasks supported (or again, the latency will start to go up)</p></li>
<li><p>an io_service per thread, usually one thread per logical core and with thread affinity so that it "sticks" to that core. This can be ideal for cache locality</p></li>
</ol>

<h2>UPDATE: Demo</h2>

<p>Here's a demo that shows the idiomatic style using <strong>option 1.</strong> from above:</p>

<p><strong><kbd><a href="http://coliru.stacked-crooked.com/a/7ab9d4ac677df677" rel="nofollow">Live On Coliru</a></kbd></strong></p>

<pre><code>#include &lt;boost/array.hpp&gt;
#include &lt;boost/asio.hpp&gt;
#include &lt;boost/bind.hpp&gt;
#include &lt;boost/enable_shared_from_this.hpp&gt;
#include &lt;boost/make_shared.hpp&gt;
#include &lt;boost/thread.hpp&gt;
#include &lt;iostream&gt;
#include &lt;istream&gt;
#include &lt;list&gt;
#include &lt;string&gt;

namespace ba = boost::asio;
namespace bs = boost::system;
namespace b  = boost;

typedef ba::ip::tcp::acceptor acceptor_type;
typedef ba::ip::tcp::socket   socket_type;

const short PORT = 11235;

// A connection has its own io_service and socket
class Connection : public b::enable_shared_from_this&lt;Connection&gt;
{
public:
    typedef boost::shared_ptr&lt;Connection&gt; Ptr;
protected:
    socket_type    sock;
    ba::streambuf  stream_buffer; // for reading etc
    std::string    message;

    void AsyncReadString() {
        std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; "\n";

        ba::async_read_until(
            sock,
            stream_buffer,
            '\0',   // null-char is a delimiter
            b::bind(&amp;Connection::ReadHandler, shared_from_this(),
                ba::placeholders::error,
                ba::placeholders::bytes_transferred));
    }
    void AsyncWriteString(const std::string &amp;s) {
        std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; "\n";

        message = s;

        ba::async_write(
            sock,
            ba::buffer(message.c_str(), message.size()+1),
            b::bind(&amp;Connection::WriteHandler, shared_from_this(),
                ba::placeholders::error,
                ba::placeholders::bytes_transferred));
    }
    std::string ExtractString() {
        std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; "\n";

        std::istream is(&amp;stream_buffer);
        std::string s;
        std::getline(is, s, '\0');
        return s;
    }
    void ReadHandler(
        const bs::error_code &amp;ec,
        std::size_t bytes_transferred) 
    {
        std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; "\n";

        if (!ec) {
            std::cout &lt;&lt; (ExtractString() + "\n");
            std::cout.flush();
            AsyncReadString();  // read again
        }
        else {
            // do nothing, "this" will be deleted later
        }
    }
    void WriteHandler(const bs::error_code &amp;ec, std::size_t bytes_transferred) {
        std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; "\n";
    }
public:
    Connection(ba::io_service&amp; svc) : sock(svc) { }

    virtual ~Connection() {
        std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; "\n";
    }

    socket_type&amp; Socket() { return sock;          } 
    void Session()        { AsyncReadString();    } 
    void Stop()           { sock.cancel();        }
};

// a server also has its own io_service but it's only used for accepting
class Server {
public:
    std::list&lt;boost::weak_ptr&lt;Connection&gt; &gt; m_connections;
protected:
    ba::io_service _service;
    boost::optional&lt;ba::io_service::work&gt; _work;
    acceptor_type _acc;
    b::thread thread;

    void AcceptHandler(const bs::error_code &amp;ec, Connection::Ptr accepted) {
        if (!ec) {
            accepted-&gt;Session();
            DoAccept();
        }
        else {
            // do nothing the new session will be deleted automatically by the
            // destructor
        }
    }

    void DoAccept() {
        auto newaccept = boost::make_shared&lt;Connection&gt;(_service);

        _acc.async_accept(
            newaccept-&gt;Socket(),
            b::bind(&amp;Server::AcceptHandler,
                this,
                ba::placeholders::error,
                newaccept
            ));
    }

public:
    Server():
        _service(),
        _work(ba::io_service::work(_service)),
        _acc(_service, ba::ip::tcp::endpoint(ba::ip::tcp::v4(), PORT)),
        thread(b::bind(&amp;ba::io_service::run, &amp;_service))
    {  }

    ~Server() {
        std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; "\n";
        Stop();
        _work.reset();
        if (thread.joinable()) thread.join();
    }

    void Start() {
        std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; "\n";
        DoAccept();
    }

    void Stop() {
        std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; "\n";
        _acc.cancel();
    }

    void StopAllConnections() {
        std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; "\n";
        for (auto c : m_connections) {
            if (auto p = c.lock())
                p-&gt;Stop();
        }
    }
};

int main() {
    try {
        Server s;
        s.Start();

        std::cerr &lt;&lt; "Shutdown in 2 seconds...\n";
        b::this_thread::sleep_for(b::chrono::seconds(2));

        std::cerr &lt;&lt; "Stop accepting...\n";
        s.Stop();

        std::cerr &lt;&lt; "Shutdown...\n";
        s.StopAllConnections(); // interrupt ongoing connections
    } // destructor of Server will join the service thread
    catch (std::exception &amp;e) {
        std::cerr &lt;&lt; __FUNCTION__ &lt;&lt; ":" &lt;&lt; __LINE__ &lt;&lt; "\n";
        std::cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; std::endl;
        return 1;
    }

    std::cerr &lt;&lt; "Byebye\n";
}
</code></pre>

<p>I modified the <code>main()</code> to run for 2 seconds without user intervention. This is so I can demo it <strong><a href="http://coliru.stacked-crooked.com/a/7ab9d4ac677df677" rel="nofollow">Live On Coliru</a></strong> (of course, it's limited w.r.t the number of client processes).</p>

<p>If you run it with a lot (a <strong><em>lot</em></strong>) of clients, using e.g.</p>

<pre><code>$ time (for a in {1..1000}; do (sleep 1.$RANDOM; echo -e "hello world $RANDOM\\0" | netcat localhost 11235)&amp; done; wait)
</code></pre>

<p>You will find that the two second window handles them all:</p>

<pre><code>$ ./test | sort | uniq -c | sort -n | tail
Shutdown in 2 seconds...
Shutdown...
Byebye
      2 hello world 28214
      2 hello world 4554
      2 hello world 6216
      2 hello world 7864
      2 hello world 9966
      2 void Server::Stop()
   1000 std::string Connection::ExtractString()
   1001 virtual Connection::~Connection()
   2000 void Connection::AsyncReadString()
   2000 void Connection::ReadHandler(const boost::system::error_code&amp;, std::size_t)
</code></pre>

<p>If you really go berserk and raise <code>1000</code> to e.g. <code>100000</code> there, you'll get things similar to:</p>

<pre><code>sehe@desktop:/tmp$ ./test | sort | uniq -c | sort -n | tail
Shutdown in 2 seconds...
Shutdown...
Byebye
      2 hello world 5483
      2 hello world 579
      2 hello world 5865
      2 hello world 938
      2 void Server::Stop()
      3 hello world 9613
   1741 std::string Connection::ExtractString()
   1742 virtual Connection::~Connection()
   3482 void Connection::AsyncReadString()
   3482 void Connection::ReadHandler(const boost::system::error_code&amp;, std::size_t)
</code></pre>

<p>On repeated 2-second runs of the server.</p>
