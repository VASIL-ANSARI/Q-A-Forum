<p>I won't get into the discussion of premature optimization. But the answer is that they will be the same speed.</p>

<p>Any sane compiler will compile them to the same thing. Division/modulus by a power of two will be optimized to bitwise operations anyway.</p>

<p><strong>So use whichever you find (or others will find) to be more readable.</strong></p>

<p>EDIT : As Roland has pointed out, it does sometimes behave different depending on the signness:</p>

<p><strong>Unsigned &amp;:</strong></p>

<pre><code>int main(void)
{
    unsigned x;
    cin &gt;&gt; x;
    x = (x + 1) &amp; 3;
    cout &lt;&lt; x;

    return 0;
}

mov eax, DWORD PTR _x$[ebp]
inc eax
and eax, 3
push    eax
</code></pre>

<p><strong>Unsigned Modulus:</strong></p>

<pre><code>int main(void)
{
    unsigned x;
    cin &gt;&gt; x;
    x = (x + 1) % 4;
    cout &lt;&lt; x;

    return 0;
}

mov eax, DWORD PTR _x$[ebp]
inc eax
and eax, 3
push    eax
</code></pre>

<p><strong>Signed &amp;:</strong></p>

<pre><code>int main(void)
{
    int x;
    cin &gt;&gt; x;
    x = (x + 1) &amp; 3;
    cout &lt;&lt; x;

    return 0;
}

mov eax, DWORD PTR _x$[ebp]
inc eax
and eax, 3
push    eax
</code></pre>

<p><strong>Signed Modulus:</strong></p>

<pre><code>int main(void)
{
    int x;
    cin &gt;&gt; x;
    x = (x + 1) % 4;
    cout &lt;&lt; x;

    return 0;
}

mov eax, DWORD PTR _x$[ebp]
inc eax
and eax, -2147483645            ; 80000003H
jns SHORT $LN3@main
dec eax
or  eax, -4                 ; fffffffcH
</code></pre>
