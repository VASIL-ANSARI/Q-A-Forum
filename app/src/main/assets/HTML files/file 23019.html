<p>This can be done using the following code:</p>

<pre><code>bool GetActiveProcessName(TCHAR *buffer, DWORD cchLen)
{
    HWND fg = GetForegroundWindow();
    if (fg)
    {
        DWORD pid;
        GetWindowThreadProcessId(fg, &amp;pid);
        HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);
        if (hProcess)
        {
            BOOL ret = QueryFullProcessImageName(hProcess, 0, buffer, &amp;cchLen);
            //here you can trim process name if necessary
            CloseHandle(hProcess);
            return (ret != FALSE);
        }
    }
    return false;
}
</code></pre>

<p>and then</p>

<pre><code>TCHAR buffer[MAX_PATH];
if(GetActiveProcessName(buffer, MAX_PATH))
{
    _tprintf(_T("Active process: %s\n"), buffer);
}
else
{
    _tprintf(_T("Cannot obtain active process name.\n"));
}
</code></pre>

<p>Note though that <em>QueryFullProcessImageName</em> function is only available since Windows Vista, on earlier systems you could use <em>GetProcessImageFileName</em> (it is similar, but requires linkage with psapi.dll and returns device path instead of usual win32 path)</p>
