<p><strong>EDIT:</strong> Given that you aren't starting the script, a solution that occurs to me is to put $stdin under your control while using your gem.  I suggest something like:</p>

<pre><code>old_stdin = $stdin.dup
# note that old_stdin.fileno is non-0.
# create a file handle you can use to signal EOF
new_stdin = File::open('/dev/null', 'r')
# and make $stdin use it, instead.
$stdin.reopen(new_stdin)
new_stdin.close
# note that $stdin.fileno is still 0, though now it's using /dev/null for input.
# replace with the call that runs the external program
system('/bin/cat')
# "cat" will now exit.  restore the old state.
$stdin.reopen(old_stdin)
old_stdin.close
</code></pre>

<p><strike>
If your ruby script is creating the tasks, it can use <code>IO::popen</code>.  For example, <code>cat</code>, when run with no arguments, will wait for EOF on stdin before it exits, but you can run the following:</p>

<pre><code>f = IO::popen('cat', 'w')
f.puts('hello')
# signals EOF to "cat"
f.close
</code></pre>

<p></strike></p>
