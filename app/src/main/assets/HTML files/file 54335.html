<p>I faced the same issue a couple of years ago. This is what I found back then.</p>

<p><strong>Short Answer</strong>:
The value 5 gets converted to Integer Object due to Auto-Boxing.
When ArrayList checks for the value, it compares each object with .equals() operator and the .equals of Integer, Short will go ahead with comparing their primitive values (.intValue or .shortValue) only if both the objects are of the same Type.</p>

<p><strong>Long Answer</strong>:</p>

<p>When Performing shortList.contains(5)
The following happens : </p>

<ol>
<li><p>Auto-Boxing kicks in, resulting in 5 Getting converted to Integer Object.</p>

<pre><code>Integer.valueOf(int) line: 830  
</code></pre></li>
<li><p>The ArrayList's Contains method internally calls indexOf API which checks at what Index is the object being searched is present.</p></li>
</ol>

<p>:</p>

<pre><code> public int indexOf(Object o) {
    ...
        // Here Object "o" is of Type Integer in your case, So It calls Integer.equals
        if (o.equals(elementData[i]))
    ...
    // If not equal or not found.
    return -1;
    }
</code></pre>

<ol start="3">
<li>Since the object passed is of Type Integer Wrapper Class, it invokes Integer Class equals() Method.</li>
<li>The Implementation of Integer Class equals is</li>
</ol>

<p>:</p>

<pre><code> public boolean equals(Object obj) {
            if (obj instanceof Integer) {
                return value == ((Integer)obj).intValue();
            }
            return false;
        }
</code></pre>

<p>Since the Object "obj" here is of type "Short", the instanceof operator fails resulting in false as the output.</p>
