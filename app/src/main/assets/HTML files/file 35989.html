<p>Because you work with a copy of the reference value, not with the direct reference. Note that enhanced for loop will use an <code>Iterator</code> behind the scenes for you. It looks like this:</p>

<pre><code>for (Iterator&lt;YourClass&gt; it = yourCollection.iterator(); it.hasNext(); ) {
    YourClass yourClass = it.next();
    //do whatever...
    //and looks like you change yourClass value here
    //which is a local variable, not the real object reference inside your collection

    //also, you cannot add/remove an element here to the collection being iterated
    //because this will throw a ConcurrentModificationException
}
</code></pre>

<p>The solution would be adding all the new elements into a new collection (<code>List</code>, <code>Map</code>, <code>Set</code> or whatever you're using) and, after all your logic, replace your current collection with your new collection. This would be the pseudocode (I cannot provide a more accurate code because you don't provide enough info):</p>

<pre><code>Collection&lt;YourData&gt; newCollection = ... //initialize it
for (... : currentCollection) {
     if (...) {
         YourData yourData = new YourData();
         //fill yourData variable
         //...
         //add it into newCollection
         newCollection.add(yourData);
     }
}
//roughly, you will end doing this or similar
currentCollection = newCollection;
</code></pre>

<p>With your new example, the element to be modified will be a <code>Map</code>, so fill the new key-value pairs into a new <code>Map</code> and, in the end, iterate through this map to replace the elements in your current map:</p>

<pre><code>Map&lt;YourKey, YourValue&gt; newMap = new HashMap&lt;&gt;(); //the implementation doesn't really matter for this one
for(Map.EntrySet&lt;YourKey, YourValue&gt; entrySet : currentMap.entrySet()) {
      if (...) {
          YourValue newValue = ...;
          //compute the newValue data
          //...
          newMap.put(entrySet.getKey(), newValue); 
      }
}
for (Map.EntrySet&lt;YourKey, YourValue&gt; entrySet : newMap.entrySet()) {
    currentMap.put(entrySet.getKey(), entrySet.getValue());
}
</code></pre>
