<p>Specific types such as <code>int</code> and <code>string</code> cannot be cast to <code>T</code>, but <code>object</code> can be. This should work:</p>

<pre><code>if (typeParameterType.Equals(typeof(string)))
{
    callback((T)((object)"my string response"));
}
if (typeParameterType.Equals(typeof(int)))
{
    callback((T)((object)1)); // my int response
}
</code></pre>

<p>However, it's a little strange that you need to do this in the first place: rather than jumping through hoops with generics, you could deal with the problem more gracefully with multiple methods:</p>

<pre><code>public void DoSomething(string key, Action&lt;int&gt; callback) {
    callback(1);
}
public void DoSomething(string key, Action&lt;string&gt; callback) {
    callback("my string response");
}
</code></pre>

<p>Now you can call these methods like this:</p>

<pre><code>DoSomething("hello", new Action&lt;int&gt;(x =&gt; Console.WriteLine("int: {0}", x)));
DoSomething("world", new Action&lt;string&gt;(x =&gt; Console.WriteLine("str: {0}", x)));
</code></pre>

<p>or like this:</p>

<pre><code>DoSomething("hello", (int x) =&gt; Console.WriteLine("int: {0}", x));
DoSomething("world", (string x) =&gt; Console.WriteLine("str: {0}", x));
</code></pre>
