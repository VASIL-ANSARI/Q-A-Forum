<p>The focus behavior that you describe is easily implemented from the codebehind, and doing so does not violate the MVVM pattern.  Consider Josh Smith's post, below:</p>

<p><a href="https://msdn.microsoft.com/en-us/magazine/dd419663.aspx#id0090097" rel="nofollow">https://msdn.microsoft.com/en-us/magazine/dd419663.aspx#id0090097</a></p>

<blockquote>
  <p>The use of a ViewModel here makes it much easier to create a view that
  can display a Customer object and allow for things like an
  "unselected" state of a Boolean property. It also provides the ability
  to easily tell the customer to save its state. If the view were bound
  directly to a Customer object, the view would require a lot of code to
  make this work properly. In a well-designed MVVM architecture, the
  codebehind for most Views should be empty, or, at most, only contain
  code that manipulates the controls and resources contained within that
  view. Sometimes it is also necessary to write code in a View's
  codebehind that interacts with a ViewModel object, such as hooking an
  event or calling a method that would otherwise be very difficult to
  invoke from the ViewModel itself.</p>
</blockquote>
