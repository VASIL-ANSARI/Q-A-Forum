<p>Hi I didnt have MVVMLight so I have used custom Messanger because to make picture clearer how things work.</p>

<blockquote>
  <p>MessageType</p>
</blockquote>

<pre><code>public enum MessageType
{ 
    DataLoaded,
    OpenWindow,
    SetFocus,
    OpenExceptionWindow,
    Refresh
    //etc
}
</code></pre>

<blockquote>
  <p>Message</p>
</blockquote>

<pre><code>public class Message
{
    public Message(MessageType messageType, object message)
    {
        MessageType = messageType;
        MessageObject = message;
    }

    public MessageType MessageType { get; private set; }
    public object MessageObject { get; private set; }
}
</code></pre>

<blockquote>
  <p>Messanger</p>
</blockquote>

<pre><code>    public class Messanger
{
    //Singleton
    private Messanger()
    { }

    static Messanger instance;
    public static Messanger Instance
    { 
        get{return instance ?? (instance=new Messanger());}
    }

    static Dictionary&lt;string, Action&lt;Message&gt;&gt; dictionary = new Dictionary&lt;string, Action&lt;Message&gt;&gt;();

    //View Calls this and register the delegate corresponding to the unique token
    public void Register(string token,Action&lt;Message&gt; action)
    {
        if (dictionary.ContainsKey(token))
            throw new Exception("Already registered");
        if (action == null)
            throw new ArgumentNullException("action is null");

        dictionary.Add(token, action);
    }

    public void UnRegister(string token)
    { 
        if(dictionary.ContainsKey(token))
            dictionary.Remove(token);
    }

    //ViewModel Calls this and pass the token and Message.
    //the registered delegate is looked up in dictionary corresponding to that token and
    //Corresponding register delegate fired.
    public void SendMessage(string token,Message message)
    {
        if (dictionary.ContainsKey(token))
            dictionary[token](message);
    }
}
</code></pre>

<blockquote>
  <p>ViewBase</p>
</blockquote>

<pre><code> public class ViewBase:Window
{
    protected  string Token { get; private set; }

    public ViewBase()
    {
        Token = Guid.NewGuid().ToString();

        //Register to Messanger
        Messanger.Instance.Register(Token, HandleMessages);

        //UnRegister On Closing or Closed
        this.Closing +=(s,e)=&gt; Messanger.Instance.UnRegister(Token);
    }

    //Handle Common Messages to all Windows Here
    void HandleMessages(Message message)
    {
        switch (message.MessageType)
        { 
            case MessageType.OpenExceptionWindow:
                Exception ex = message.MessageObject as Exception;
                ExceptionWindow window = new ExceptionWindow();
                window.Exception = ex;
                window.ShowDialog();
                break;
                //other common cases should be handled here

            default : HandleWindowLevelMessage(message);
                break;

        }

    }

    protected virtual void HandleWindowLevelMessage(Message message)
    { 

    }

}
</code></pre>

<blockquote>
  <p>View</p>
</blockquote>

<pre><code>public partial class Mywindow : ViewBase
{
    public Mywindow()
    {
        InitializeComponent();
        DataContext = new MyViewModel(Token);
    }

    protected override void HandleWindowLevelMessage(Message message)
    {
        //open window according to OP Requirement
        if (message.MessageType == MessageType.OpenWindow)
        {
            string windowName = message.ToString();

            if (windowName != null)
            {
                //logic to get the window . I assume that OP have some logic to get the child window this is just temporary
                var window = Application.Current.Windows.OfType&lt;Window&gt;().FirstOrDefault(s=&gt;s.Name==windowName);
                if (window != null)
                {
                   window.Owner=this;
                    window.Show();
                }
            }
        }

        base.HandleWindowLevelMessage(message);
    }
}
</code></pre>

<blockquote>
  <p>View.xaml Here first element is not Window now</p>
</blockquote>

<pre><code>&lt;local:ViewBase x:Class="WpfApplication4.Mywindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:local="clr-namespace:WpfApplication4"
    Title="Mywindow" Height="300" Width="300"&gt;
&lt;Grid&gt;
    &lt;Button Content="ok" Click="Button_Click_1"/&gt;
&lt;/Grid&gt;
</code></pre>

<p></p>

<blockquote>
  <p>ViewModelBase</p>
</blockquote>

<pre><code>public class ViewModelBase : INotifyPropertyChanged
{
    public ViewModelBase(string token)
    {
        Token = token;
    }

    protected string Token { get; set; }

    public event PropertyChangedEventHandler PropertyChanged;

    void RaisePropertyChanged(string propName)
    {
        if (PropertyChanged != null)
            PropertyChanged(this, new PropertyChangedEventArgs(propName));
    }
}
</code></pre>

<blockquote>
  <p>ViewModel</p>
</blockquote>

<pre><code>public class MyViewModel : ViewModelBase
{
    public MyViewModel(string token)
        : base(token)
    {

    }

    //say OP want to open window on Command Execute
    public void OnCommand()
    {
        Messanger.Instance.SendMessage(Token, new Message(MessageType.OpenWindow, "MyChildWindow"));
    }
}
</code></pre>

<p>I hope this will help. This is simple code to understand feel free to ask.</p>
