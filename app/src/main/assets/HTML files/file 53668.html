<p>With your code, you have to specify which overload you want:</p>

<pre><code>ApplyToFields(&amp;ns1, &amp;ns2, add_print&lt;float&gt;);
ApplyToFields(&amp;ns1, &amp;ns2, sub_print&lt;int&gt;);
</code></pre>

<p>or</p>

<pre><code>ApplyToFields&lt;float&gt;(&amp;ns1, &amp;ns2, add_print);
ApplyToFields&lt;int&gt;(&amp;ns1, &amp;ns2, sub_print);
</code></pre>

<p><a href="http://coliru.stacked-crooked.com/a/62820163c7c490a3" rel="nofollow">Demo</a></p>

<p>That you want is a generic functor</p>

<pre><code>template&lt;typename F&gt;
void ApplyToFields(const NodeStatus &amp;ns1, const NodeStatus &amp;ns2, F func) {
  func(ns1.float_val, ns2.float_val);
  func(ns1.int_val, ns2.int_val);
}

struct add_print
{
    template&lt;typename T&gt;
    void operator() (T a, T b) {
        std::cout &lt;&lt; b + a &lt;&lt; std::endl;
    }
};
</code></pre>

<p><a href="http://coliru.stacked-crooked.com/a/cdc038752bf3ec0d" rel="nofollow">Demo</a></p>
