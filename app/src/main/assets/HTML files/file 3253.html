<p>to "fire and forget" a thread. You can create a class with operator() and member variables with data to write. In the asio accept data handler create one of these classes, then pass it to a boost thread. Boost thread will COPY that class internally and start the thread. If you are careful about how you write the operator() it should terminate when the sql write is done and release its write data. You can call boost::thread::detach to forget about the thread and just let it complete then die. That way you're firing out new threads that write to mysql from your asio handlers. I'm not sure what happens to the member data when the thread class goes out of scope. double check the boost docs, could be a problem if the boost thread isn't completed and the thread still needs data that is gone. Maybe shared pointers can help here. </p>
