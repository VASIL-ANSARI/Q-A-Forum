<p>In general, <code>swap</code> never invalidates iterators.  However, another rule comes into play when the allocators are different.  In that case the behavior depends on <code>allocator_traits&lt;a1&gt;::propagate_on_container_swap::value</code> and <code>allocator_traits&lt;a2&gt;::propagate_on_container_swap::value</code>.  If both are true, the allocators are exchanged along with the data, all iterators remain valid.  If either is false, behavior is undefined, so the particular behavior exhibited by VC++ 2010 is allowed.</p>

<p>From <code>[container.requirements.general]</code> (wording from n3290):</p>

<blockquote>
  <p>Allocator replacement is performed by copy assignment, move assignment, or swapping of the allocator only if <code>allocator_traits&lt;allocatortype&gt;::propagate_on_container_copy_assignment::value</code>,
  <code>allocator_traits&lt;allocatortype&gt;::propagate_on_container_move_assignment::value</code>, or <code>allocator_traits&lt;allocatortype&gt;::propagate_on_container_swap::value</code> is true within the implementation of the corresponding container operation. The behavior of a call to a containerâs swap function is undefined unless the objects being swapped have allocators that compare equal or <code>allocator_traits&lt;allocatortype&gt;::propagate_on_container_swap::value</code> is true.</p>
</blockquote>

<p>and</p>

<blockquote>
  <p>Every iterator referring to an element in one container before the swap shall refer to the same element in the other container after the swap</p>
</blockquote>

<p>and</p>

<blockquote>
  <p>Unless otherwise specified ...  no <code>swap()</code> function invalidates any references, pointers, or iterators referring to the elements of the containers being swapped. </p>
</blockquote>

<p>23.3.6.5 does not specify alternate rules for <code>vector::swap()</code>.</p>
