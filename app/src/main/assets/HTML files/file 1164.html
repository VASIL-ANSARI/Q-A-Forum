<p>Those functions should be declared as an operator () in a class, unfortunately.  Like this:</p>

<pre><code>class VertexSetHashFunction {
  public:
    ::std::size_t operator ()(const ::std::set&lt;Vertex3DXT*&gt; &amp;vertexSet) const;
};
class SetEqual {
  public:
    bool operator ()(const ::std::set&lt;Vertex3DXT*&gt; &amp;a, const ::std::set&lt;Vertex3DXT*&gt; &amp;b) const;
};
</code></pre>

<p>You do not have to modify the arguments to be const references, but I would highly recommend it.  Making a copy of a ::std::set is relatively expensive and you shouldn't do it unless you absolutely have to.</p>

<p>The trailing const is just because the operator doesn't actually modify the class state at all, mostly because there isn't any.  It's just nice to say so explicitly.</p>

<p>Alternately, you could define your own specialization of the ::std::hash template.  I would actually recommend this if there is one standard way you want that particular set hashed because this template is used by default if you do not supply a hash function to <code>unordered_map</code> or <code>unordered_set</code> and anything else that needs a hash function.</p>
