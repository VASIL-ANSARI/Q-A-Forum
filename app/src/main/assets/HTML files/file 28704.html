<p>You said that, <code>I am able to do</code></p>

<pre><code>$offers = Catering::find(1)-&gt;offers;
</code></pre>

<p>and in your <code>Catering</code> model you have</p>

<pre><code>public function offers() {
    return $this-&gt;hasMany('Offer', 'cid');
}
</code></pre>

<p>It seems like you've defined a different foreign key here (<code>cid</code>) to use it instead of the default one that <code>laravel</code> basically supposed to use, so, to do the reverse relation you have to do the same thing in your <code>Offer</code> model's <code>catering</code> function</p>

<pre><code>public function catering() {
    return $this-&gt;belongsTo('Catering', 'cid');
}
</code></pre>

<p>In the <a href="http://laravel.com/docs/eloquent#one-to-many" rel="nofollow">Laravel Documentation</a>, it says that, you may override the conventional foreign key by passing a second argument to the <code>hasMany</code> method, like</p>

<pre><code>return $this-&gt;hasMany('Offer', 'custom_key');
</code></pre>

<p>Same way, to define the inverse of the relationship on the <code>Offer</code> model, you can use the <code>belongsTo</code> method, like</p>

<pre><code>return $this-&gt;belongsTo('Catering', 'custom_key'); // cid
</code></pre>
