<p>If you "unwrap" the call to your function it'll work fine:</p>

<pre><code>$('.a').hover(hover_in, function() {});
</code></pre>

<p>The reason is that jQuery will set <code>this</code> when it calls the given handler, but in your original version you don't do anything to ensure that its value is passed on to your <code>hover_in</code> function when you call it.</p>

<p>If you don't want the event handler to do anything else then there's no advantage in wrapping the whole thing in an anonymous function - quite the opposite, as you've found.</p>

<p>If you want additional stuff to be done in the handler, you could do this:</p>

<pre><code>$('.a').hover(function(ev) {
    hover_in.call(this, ev);   // omit 'ev' if it's not needed
    ...
}, ...);
</code></pre>

<p>which explicitly calls <code>hover_in</code> with the right <code>this</code> value.</p>

<p>Note also that <code>$(this).attr('id') === this.id</code> - the latter is simpler and far more efficient.</p>

<p>Also, if you don't want to pass the second parameter to <code>.hover</code>, just use <code>.mousenter</code> instead.  Better yet:</p>

<pre><code>$('.a').on('mouseenter', hover_in);

function hover_in(){
    var hover_id = this.id;
    ...
};
</code></pre>
