<p>In response to your comments:</p>

<blockquote>
  <p>Unfortunately I do not do error checking</p>
</blockquote>

<p>You should <strong>always</strong> add some OpenGL error checking, it will save you from so many problems. It should look something like the following:</p>

<pre><code>int err = glGetError();
if(err != 0) {
   //throw exception or log message or die or something
}
</code></pre>

<blockquote>
  <p>I used matrix functions because I didn't realize the vertex shader would effect that. I assumed the matrix set to the matrix at the top of the stack (the one I pushed before drawing.) </p>
</blockquote>

<p>This is an incorrect assumption. The only variable which references deprecated the matrix stack is special (though deprecated) variable <code>gl_ModelViewProjectionMatrix</code>. What you currently have there is just an unused, uninitialized matrix, which is totally ignoring your matrix stack.</p>

<blockquote>
  <p>As for indices, I'm not exactly sure what you mean. I just drew the vertices on paper and decided the indices based on that. </p>
</blockquote>

<p>I'm not referring to the indices of the triangle in your index buffer, but rather the first parameter to your glAttrib* functions. I suppose 'attribute location' is a more correct term than index.</p>

<pre><code>glEnableVertexAttribArray(0);
glVertexAttribPointer(0, ...   //attrib location 0

glEnableVertexAttribArray(1);  
glVertexAttribPointer(1, ...   //attrib location 1
</code></pre>

<p>You seem to just be randomly assuming that "0" and "1" map to "position" and "normal". This is not a safe assumption to make. You should be querying the attribute location values for "position" and "normal" with glGetAttribLocation, and then using that value to glEnableVertexAttribArray and glVertexAttribPointer. </p>
