<p>Not a panacea, but the following guideline helps me a lot.</p>

<p>Assuming your code is composed of files like <code>MyClassXyz.cpp</code> with corresponding <code>MyClassXyz.h</code>, one class per source file, every cpp-file should include its corresponding header file <strong>first</strong>. That is, <code>MyClassXyz.cpp</code> <strong>must</strong> start with the following line:</p>

<pre><code>// (possibly after comments)
#include "MyClassXyz.h"
</code></pre>

<p>This ensures that <code>MyClassXyz.h</code> includes all header files (or forward declarations) necessary for its compilation.</p>

<p>I often see code that uses an opposite convention (<code>#include</code>ing most general header files first), for example, <code>MyClassXyz.cpp</code> starts with </p>

<pre><code>#include &lt;vector&gt;
#include &lt;iosfwd&gt;
#include "blah.h"
#include "mytypes.h"
#include "MyClassXyz.h"
</code></pre>

<p>And <code>MyClassXyz.h</code> "goes straight to the point" using stuff defined in the additional headers:</p>

<pre><code>#pragma once
// "#include &lt;vector&gt;" missing - a hidden error!
// "#include &lt;iosfwd&gt;" missing - a hidden error!
class MyClassXyz
{
    std::vector&lt;int&gt; v;
    friend std::ostream&amp; operator&lt;&lt;(...);
    ...
}
</code></pre>

<p>While this compiles OK, it gives enormous headaches of the type you describe, when trying to use the class <code>MyClassXyz</code> in some other source file.</p>
