<p>There's a couple ways around this.  One way is to use namespaces to wrap enums and prevent the values from polluting the global namespace:</p>

<pre><code>namespace direction {
    enum direction {
        LEFT,
        RIGHT,
        UP,
        DOWN,
        NONE
    };
}
namespace color {
    enum color {
       RED,
       GREEN,
       BLUE,
       NONE
    };
}
</code></pre>

<p>You can also use the new C++11 way (if your compiler supports it) and use "strongly-typed enums"</p>

<pre><code>enum class direction {
    LEFT,
    RIGHT,
    UP,
    DOWN,
    NONE
};
enum class color {
   RED,
   GREEN,
   BLUE,
   NONE
};
</code></pre>

<p>Both can be used by the syntax <code>direction::NONE</code> or <code>color::NONE</code> but there is one major difference.  In the first case the enums will still implicitly cast to ints.  This means you can write </p>

<p><code>int foo = direction::NONE;</code> </p>

<p>and everything is fine.  </p>

<p>In the second case, this would be a compiler error since foo is not the same type as direction.  You can get around this by doing</p>

<p><code>direction foo = direction::NONE;</code></p>

<p>which may or may not work for you.  If you need to cast it to an int, you are welcome to use <code>static_cast&lt;int&gt;(foo)</code> to get an integer type.</p>
