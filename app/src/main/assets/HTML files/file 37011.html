<p>Seems like you don't know about <strong>local</strong> and <strong>global</strong> variable.</p>

<p>You can use <strong>pass by reference</strong> to solve the problem as follows:</p>

<pre><code>void aux(bool &amp;x)
{
    std::string text;
    std::getline(std::cin, text);
    if(text.find("be ") != std::string::npos || text.find("do ") != std::string::npos ||
       text.find("can ") != std::string::npos || text.find("but ") != std::string::npos)
            {
                x = true;
            }
else{ 
  x = false;
  }
</code></pre>

<p>}</p>

<pre><code>int main()
{
bool x = false;
if (text.find("7 ") != std::string::npos)
        {
            aux(x);
            //{ un-necessary brackets.
                if (x);
                {
                std::cout&lt;&lt;"A function to equal a group of words" &lt;&lt;std::endl;
                }un-necessary brackets.
            //}
        }
getchar();
return 0;
}
</code></pre>

<p><strong>Problem you have:</strong></p>

<p>You have following mistakes in your code.</p>

<p>1.You have defined a function like this:</p>

<pre><code>void aux(bool x){
//your code here
}
</code></pre>

<p>But you <strong>haven't called it by passing</strong> any variable as parameter/argument. Do as following:</p>

<pre><code>aux(var1);//var1 is boolean variable
</code></pre>

<p>2 . The change in x doesn't appear there because the x will be treated as a new variable inside the <strong>aux(var1)</strong> function. So if you use <strong>pass by reference</strong>, then the changes will be persistence to the variable (here x).</p>
