<p>Your <code>Configuration</code> constructor is declared to throw an <code>IOException</code>.  Any code that instantiates a <code>Configuration</code> using this constructor must catch it.  If you use a variable initializer, then you can't catch it, because you can't supply a <code>catch</code> block; there is no block you can put here, only an expression.  There is no method to declare a <code>throws</code> clause on either.</p>

<p>Your alternatives:</p>

<ul>
<li><p>Instantiate the <code>Configuration</code> in a <code>Toplevel</code> constructor.  You can <code>catch</code> the exception in the constructor body, or you can declare that constructor that it <code>throws</code> the exception.</p>

<pre><code>public class Toplevel {
    Configuration config;
    public Toplevel() {
        try {
            config = new Configuration("testconfig.properties");
        } catch (IOException e) {  // handle here }
    }
    // ...
</code></pre></li>
<li><p>Instantiate the <code>Configuration</code> in an instance initializer in the <code>TopLevel</code> class, where you can <code>catch</code> the exception and handle it.</p>

<pre><code>public class Toplevel {
    Configuration config;

    {
        try {
            config = new Configuration("testconfig.properties");
        } catch (IOException e) {  // handle here }
    }
    // ...
</code></pre></li>
<li><p>Catch and handle the exception in the <code>Configuration</code> constructor, so calling code doesn't have to catch the exception.  This isn't preferred, because you may have an invalid <code>Configuration</code> object instantiated.  Calling code would still need to determine if it's valid.</p>

<pre><code>public class Configuration {
     // Your instance variables
     private boolean isValid;

     public Configuration( String configPath )  {
         try {
             // Your code that might throw an IOE
             isValid = true;
         } catch (IOException e) {
             isValid = false;
         }
     }
</code></pre></li>
</ul>
