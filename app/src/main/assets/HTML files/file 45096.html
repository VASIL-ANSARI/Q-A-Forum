<p>A single C <code>char</code> in Swift is represented as <code>CChar</code>, a typealias for <code>Int8</code>.  </p>

<p>(similarly, C <code>int</code> in Swift is <code>CInt</code>, a typealias for <code>Int32</code>)</p>

<p>If you want a specific character and are using Swift 1.2, thereâs an initializer for <code>UInt8</code> that takes a <code>UnicodeScalar</code>.  Annoyingly, though, you have to then convert it to a <code>Int8</code> to make it compatible with the C method:</p>

<pre><code>    let ch = CChar(UInt8(ascii: "x"))
    let i = CInt(100)
    let s = obj.PatternSetCreator(ch, 
                   detection_time_in_sec: i, 
                   patternLength: i, 
                   maxPatternSetSize: i)
</code></pre>

<p>You should not need to do anything special to turn the returned <code>NSString</code> to a <code>String</code>.  The bridging will do that automatically.</p>

<p>(or rather, itâll return a <code>String!</code> â but if the objective c code is guaranteed to return a valid string every time and never a null pointer, the definition can be changed to <code>-(nonnull NSString *) PatternSetCreator: etcâ¦</code> which means it will return a <code>String</code> instead)</p>
