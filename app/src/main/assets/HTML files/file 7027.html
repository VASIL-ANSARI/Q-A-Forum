<p>Looks like the restriction of not allowing you to take the absolute values is a big one. It is possible to modify the code you have slightly to handle the case there Rg1>0 and Rg2&lt;0. </p>

<p>Instead of taking the absolute value of the negative number, you just change signs in places where Rg2 is used - and also change signs on the output. You seem to have started that way, but forgot the little bit of negating your divisor (what's left over in Rg3 after you are done). You can do that in two ways: keep the algorithm as-is, but set <code>Rg3=(Rg3^0xff + 1)</code> after the eight iterations. Alternatively, instead of shifting in 0 for negative, and 1 for positive, you can revert it in the main loop by shifting in 1 when r is negative, and 0 otherwise (this is the equivalent of calculating <code>Rg3 ^ 0xff</code> implicitly) and add 1 after the eight iterations. To see why you need the plus 1, divide 1 by -2, and see r always staying negative - causing all <code>1</code>s to be shifted in <code>Rg3</code>. After eight iterations, you'll have 0xff (or -1), but it should have been 0. So you add 1.</p>

<p>By the way, there is a bug in <code>bits</code> function. The line <code>char bit = 0x80</code> should read <code>unsigned char bit = 0x80</code>, because a signed char of value 0x80 becomes 0xC0 when shifted right - and that messes up your bit values.</p>

<p>In any case. I don't know how to handle the case of <code>Rg1&lt;0</code> regardless of the sign of <code>Rg2</code>. I will update the answer if I can think of anything. In the end, your division will have to choose one of the four algorithms to do the job depending on the sign of each input parameter.</p>

<hr>

<p>EDIT:</p>

<p>I am not sure how to explain it exactly, but for the case of <code>Rg1&lt;0</code>, <code>Rg2&gt;0</code>, the solution is to simply change initial value of <code>r</code> to <code>0xff</code>, and change the sign check of <code>r</code> down below to <code>r &gt;= 0</code>. The result for <code>-19/8</code> is <code>-2*8-3</code>, and for <code>-29/4</code> is <code>-7*4-1</code>. If you want the remainder to be always positive, you need to subtract 1 from Rg3, and add Rg2 to r.</p>

<p>I chose <code>0xFF</code> initial value, because <code>r</code> is simply the sign extension of <code>Rg1</code> to 16 bits. Since <code>r</code> is now always negative, checking whether it becomes zero or positive after adding <code>Rg2</code> is only natural.</p>

<p>You should be able to handle the case of <code>Rg1&lt;0</code>, <code>Rg2&lt;0</code> quite easily: simply revert the signs of <code>Rg2</code> operations again. It may also be possible to combine the four different routines into one that handles all four cases, but I'll leave that up to you as well. :)</p>
