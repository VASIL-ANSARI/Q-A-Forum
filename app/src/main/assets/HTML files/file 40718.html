<p>First off, you should recurse first and only then sort the outer range. Otherwise you'll get somewhat random results as the inner containers are not in any canonical order. To make matters worse, the later sort will change the order of elements causing the outer vectors to be apparently out of order. Seems you want to have a conditional version of <code>my_sort()</code> dependent on whether the type <code>T</code> defines an associated <code>iterator</code> type. Since you use only <code>std::vector&lt;T&gt;</code>s an easier approach is to simply rely on partial ordering of templates, though:</p>

<pre><code>template &lt;typename T&gt;
void my_sort(T const&amp;) {
    // this function delibarately does nothing
}
template &lt;typename T&gt;
void my_sort(std::vector&lt;T&gt;&amp; v) {
    std::for_each(v.begin(), v.end(), [](T&amp; value) { my_sort(value); });
    std:sort(v.begin(), v.end());
}
</code></pre>

<p>BTW, since this function actually never calls itself, neither directly nor indirectly, it is actually not really a recursive function: each instantiation of the function template is a different function.</p>
