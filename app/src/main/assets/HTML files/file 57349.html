<p>I would suggest the following approach:</p>

<p>1) fork and execute the <code>mysql</code> command line client. Set up a pair of pipes, to mysql's standard input and output.</p>

<p>2) At this point you should be able to execute simple commands by piping them to mysql via the standard input pipe, and read the output from the standard output pipe.</p>

<p>You will need to make careful notes as to the output format of each mysql command, so that you know when you finished reading its output, and you can send the next command.</p>

<p>3) As the first order of being, execute:</p>

<pre><code>show tables;
</code></pre>

<p>The output that comes back will list all tables in the database. Parsing the output into a list of table names is trival. Then execute for each table:</p>

<pre><code>show create table &lt;tablename&gt;;
</code></pre>

<p>The resulting output shows all fields in the table, its keys, and constraints. Pretty much all of this table's schema. Lather, rinse, repeat, for every table.</p>

<p>4) In this manner you can capture a basic schema of the entire database, for comparison purposes. If necessary, use the same approach to capture the triggers, and other objects. You'll likely need to do some minor massaging of the data, and exclude a few bits. "show create table", for example, will include the current <code>AUTO_INCREMENT</code> values, which you can ignore.</p>

<p>This general approach, of driving a mysql process via its standard input and output, is bit wobbly, of course. With a little bit of work, you can use mysql's native client library, and execute all of these commands, and capture their results, directly. This should be more reliable.</p>
