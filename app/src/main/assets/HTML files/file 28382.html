<p>If the higher priority thread is waiting for a lock, regardless of which thread owns the lock, it won't be scheduled.</p>

<p>If the higher priority thread isn't waiting for anything, then it may preempt a lower priority thread. None of this is really .NET or C# specific though - it really ends up being down to the operating system to manage the threads and schedule them.</p>

<p>You might find <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms685100%28v=vs.85%29.aspx" rel="nofollow">this MSDN article on thread priorities</a> useful - it certainly surprised me on a few points. In particular:</p>

<blockquote>
  <p>The system assigns time slices in a round-robin fashion to all threads with the highest priority. If none of these threads are ready to run, the system assigns time slices in a round-robin fashion to all threads with the next highest priority. If a higher-priority thread becomes available to run, the system ceases to execute the lower-priority thread (without allowing it to finish using its time slice), and assigns a full time slice to the higher-priority thread. </p>
</blockquote>

<p>You <em>should</em> be able to verify that by creating a program which some high priority threads and some low priority threads; the above quote would suggest that if you can keep the processor busy with the high priority threads, the low priority threads will starve completely. That surprises me, but you should be able to experiment and see what happens. Just try to keep the high priority threads busy with work that <em>can't</em> cause any IO (etc) which would otherwise stall them.</p>
