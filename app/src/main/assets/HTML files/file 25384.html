<p>No, it's not, it's O(n^2), because you are iterating over the whole array in the outer loop, and for each value of <code>i</code>, you are also iterating over the whole array in the inner loop. The fact that you split the array in two doesn't change the order complexity.</p>

<p>If you want to find duplicates with a O(n*log(n)) algorithm, you can sort the array, and check for duplicates on the adjacent places, like that :</p>

<pre><code>public static boolean isDuplicate(String s){
    char[] sArray = s.toCharArray();
    Arrays.sort(sArray); // O(n*log(n))
    for (int i=0; i&lt;sArray.length-1; i++) // O(n)
        if (sArray[i]==sArray[i+1])
            return true;
    return false;
}
</code></pre>

<p>Even better, you can use a <code>HashSet</code>, and find duplicates in O(n) :</p>

<pre><code>public static boolean isDuplicate(String s){
    HashSet&lt;Character&gt; alreadySeenChars = new HashSet&lt;Character&gt;();
    char[] sArray = s.toCharArray();
    for (int i=0; i&lt;sArray.length; i++) { // O(n)
        if (alreadySeenChars.contains(sArray[i])) // O(1)
            return true;
        alreadySeenChars.add(sArray[i]); // O(1)
    }
    return false;
}
</code></pre>
