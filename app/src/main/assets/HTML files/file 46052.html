<p>In the first program used variable <code>i</code> is defined in namespace P because the using directive </p>

<pre><code>using namespace X;
</code></pre>

<p>places declarations of X in the global namespace (the common namepsace for X and P). Thus the declaration of <code>i</code> in P (more precisely in Q due to another using directive) hides the declaration of <code>X::i</code> in the global namespace.</p>

<p>From the C++ Standard (3.4.1 Unqualified name lookup)</p>

<blockquote>
  <p>2 The declarations from the namespace nominated by a using-directive
  become visible in a namespace enclosing the using-directive; see
  7.3.4.</p>
</blockquote>

<p>So we have for the first program</p>

<pre><code>namespace X { int i = 1; }

namespace Q {    
    namespace P {        
        int i = 2;
        using namespace X; // 1
    }

    using namespace P; // 2

    int l = i;
}
</code></pre>

<p>that the enclosing namespace for using directive #1 is the global namespace and the enclosing namespace for using directive #2 is the namepsace Q.</p>

<p>In the second program the both definitions of <code>i</code> are placed in the global namespace due to these two using directives</p>

<pre><code>//...
using namespace X;
//...
using namespace P;
</code></pre>
