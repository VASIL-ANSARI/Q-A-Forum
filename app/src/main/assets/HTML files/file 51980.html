<p>The simplest idea would be to initialize the root node with the initial state. Then populate the next layer; write a procedure which generates the child nodes according to the blank space movement rules. You should be careful here; when the blank space is at the borders of the board, some movements would be invalid. In such a case, a sketch of A* algorithm can be drawn like that: Define your distance from the initial state as g(n). This may be the number of differently placed letters compared to the initial state, given the current state. Define a heuristic h(n), which gives your current distance from the goal state, which may be the number of differently placed letters compared to the goal state. Then in your current location in the tree, try to pick the next state, which minimizes f(n)=g(n)+h(n). I am not in a position to deeply analyze that right now, but I believe this approach may be much more efficient than brute force DFS or BFS approaches.</p>
