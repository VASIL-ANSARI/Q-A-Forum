<p>What about specialization of whole class (instead of just one member function):</p>

<pre><code>template&lt;class T&gt;
struct TempClass
{
    virtual void f() = 0;
};

template &lt;&gt;
struct TempClass&lt;int&gt;
{        
    virtual void f()
    {
       //...
    }
};
</code></pre>

<p>Note that <code>TempClass&lt;int&gt;</code>  is no longer <em>abstract class</em>, but other <code>Base</code> classes are still abstract classes, (<code>TempClass&lt;float&gt;</code>, <code>TempClass&lt;double&gt;</code>, <code>TempClass&lt;SomeClassType&gt;</code>, <code>...</code>).</p>

<p>and </p>

<p>it won't contain fields that generic class <code>TempClass</code> contains. You will have to copy-paste them from generic Base <em>or</em>, which is more clever solution, </p>

<p>you'll create base class with fields that both specialization have and then make those template classes inherit from that base class:</p>

<pre><code>template &lt;typename T&gt;
struct Base
{
   // some members that all Base classes have
};


template &lt;typename T&gt;
struct TempClass: Base&lt;T&gt;
{
    virtual void f() = 0;
};


template &lt;&gt;
struct TempClass&lt;int&gt;: Base&lt;int&gt;
{
    virtual void f()
    {
       //...
    }
};
</code></pre>

<p>This way ugly copy-paste wasn't needed.</p>
