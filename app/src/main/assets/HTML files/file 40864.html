<p>Answers to your questions:</p>

<ol>
<li><p>IIFE stands for Immediately Invoked Function Expression. In JavaScript, function literals occur in one of two forms: (1) full function definition statements, or (2) expressions. A full function definition statement has <code>function</code> as the leading token of the statement, which means that the statement is not an expression, but just a function definition. It effectively causes a local (or global if in global scope) variable to be created in the current scope with a name equal to the function name as given in the function definition statement, and a value equal to a reference to the function:</p>

<pre><code>function myFunction() {}
myFunction();
</code></pre></li>
</ol>

<p>When <code>function</code> occurs anywhere (<em>not</em> as the first token) inside an expression, the function definition is said to be "expressionized" and does <em>not</em> automatically create any local variable, but can be stored in a variable by assigning it, or called immediately by following it with a pair of parentheses:</p>

<pre><code>var func = function() { return 7; };
alert(func()); // 7
var funcRes = function() { return 3; }();
alert(funcRes); // 3
</code></pre>

<p>Strictly speaking, the term IIFE can refer to <em>any</em> context where a function definition is expressionized and then immediately invoked by following it with a pair of parentheses. You can see in your code example that they do this with the function returning <code>uniqueID + j</code>, and they also do it with the function that encloses said function and simply relays its return value to its parent scope, so both qualify as an IIFE.</p>

<p>In my experience, the term IIFE is used most often to refer to an IIFE that comprises an entire statement, and thus the leading left parenthesis is necessary to exressionize the function definition, for example:</p>

<pre><code>(function() {
    var localVar = 3;
    alert(localVar);
})();
</code></pre>

<p>I think that's why you found the code example slightly unexpected. But both of those 2 function definitions in your code example certainly qualify as IIFEs according to the strict definition of what an IIFE is; as long as the <code>function</code> keyword does <em>not</em> occur as the first token in the statement, then it is expressionized, and can be invoked immediately to form an IIFE.</p>

<ol start="2">
<li><p>The two <code>return</code>s are simply necessary as part of the design of the code. Admittedly, the whole thing is quite contrived, and there is a much easier way to accomplish the task, namely, a simple loop that loops through the array and assigns the value of the <code>id</code> hash key to a number incrementing from <code>uniqueID</code>, but they're trying to demonstrate IIFEs, I suppose. The inner return expression computes the next id value from <code>uniqueID</code> and <code>j</code>, which are both closured by the inner function, and returns it from the inner IIFE, and then the outer return relays that return value from the outer IIFE back to the <code>celebrityIDCreator</code> function scope, where it can be assigned.</p></li>
<li><p>No, IIFEs do not require surrounding parentheses. To expressionize a function, all that is required is that the <code>function</code> keyword <em>not</em> occur as the first token of the statement.</p></li>
<li><p>The full process of closuring is as follows: When a function is defined and contains a variable whose identifier does not bind to any local variable (variable declared with <code>var</code> or function parameter), then it closures around the closest ancestral (thinking of the parse tree) local with that same identifier, or the global if it cannot be bound to any ancestral local. The important point is this: It's a <em>variable reference</em> that is captured by the closure, <em>not</em> a <em>variable value</em>.</p></li>
</ol>

<p>In the "Previous example" <code>i</code> closures around the local <code>i</code> that lives in the <code>celebrityIDCreator</code> function scope. Importantly, the function is <em>not</em> immediately invoked, but a reference to the function is stored as the actual value of the <code>id</code> hash key. It is invoked later, during printing. That means that when the function is finally invoked, the variable <code>i</code> has already finished looping through the array, and is now retaining its final value, 103. If the function had been invoked immediately, then <code>i</code> would actually be evaluated during the loop and it would resolve to its current value, which would be the correct incrementing value.</p>

<p>In your main code example, <code>j</code> in the inner IIFE is closuring around the function parameter of the outer IIFE, which is temporary and will never be incremented; that parameter <code>j</code> is a distinct variable from the <code>i</code> in <code>celebrityIDCreator</code> function scope, which is never closured. Also, the inner IIFE is being immediately invoked, so it resolves to the variable's current value anyway. So they've actually overdone it here; there are two reasons why the final assigned value is the proper incrementing value and not the max value (103).</p>

<p>Main point: <strong>Closures closure around variables, not values.</strong></p>

<ol start="5">
<li>The <code>id</code> property did not need to be set to 0 initially; that appears to be just a placeholder. It is overwritten (in both your main example and in the "Previous example") when it is assigned in <code>celebrityIDCreator</code>. And since in the "Previous example" it is overwritten not by another number but by a function, it is a little weird. Again, the whole thing is a little contrived (no offense to the authors...), but all the concepts are there.</li>
</ol>
