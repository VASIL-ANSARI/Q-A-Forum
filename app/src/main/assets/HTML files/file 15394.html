<p>I've run into similar issues before, and there isn't really a great pattern I've found for dealing with doing seemingly similar tasks in reverse.</p>

<p>While it makes sense to you as a human that they're similar, you really are just calling arbitrary methods as far as the compiler is concerned. The only obvious duplication is the order in which things are called:</p>

<ol>
<li>find an item that we'd like to insert before or after</li>
<li>check that the item exists</li>
<li>insert the current item before or after it</li>
</ol>

<p>You've solved the problem in one way already that basically does these checks. Your solution is however a little unreadable. Here's how I would solve that:</p>

<pre><code>$.fn.moveItem = function(dir){
  var index = dir == 'up' ? 0:1,
      item = this['getPreviousItem','getNextItem'][index]();
  if(item.length){
    this['insertBefore','insertAfter'][index].call(this,item);
  }
}
</code></pre>

<p>By using an array index, we can see what is being called when it's being called a little easier than in your example. Also, the use of apply is unnecessary, as you know how many arguments you're passing, so call is better suited to that use case.</p>

<p>Not sure if that's any better, but it's a little shorter (is return false necessary?) and a bit more readable IMO.</p>

<p>In my opinion, centralizing actions is slightly more important than readability - if you want to optimize, change, or append to the action of moving something, you only have to do it in once place. You can always add comments to solve the readability issue.</p>
