<p>If you really care about runtime efficiency, you're almost certainly looking in the wrong place. If initializing your members takes too long (which is very unlikelyâ¦ but if you profile and find this is the hotspotâ¦), the right answer is to use <a href="http://docs.python.org/2/reference/datamodel.html#slots" rel="nofollow"><code>__slots__</code></a>, not to change the way you do the initialization.</p>

<p>If you care about <em>programmer</em> efficiency (readability, and to a lesser extent writability), you can always do this:</p>

<pre><code>self.milk = self.yogurt = False
</code></pre>

<p>If you want to do things more dynamically, you could do something like this with <a href="http://docs.python.org/2/library/functions.html#setattr" rel="nofollow"><code>setattr</code></a>, but I wouldn't recommend it:</p>

<pre><code>class ThingsInTheFridge(object):
    false_things = ('bread', 'umbrella')
    true_things = ('milk', 'yogurt')
    def __init__(self):
        for thing in ThingsInTheFridge.false_things:
            setattr(self, thing, False)
        for thing in ThingsInTheFridge.true_things:
            setattr(self, thing, True)
</code></pre>

<p>The reason I wouldn't recommend it is that, if you need to do things dynamically at this level, you also probably need to be dynamic at the <em>access</em> level, which means you really should be using a <code>dict</code> or <code>set</code>, as explained by Lattyware.</p>

<p>You could also go overboard and build yourself a prototype-style OO system on top of the class-style system, or create a metaclass that initializes instances based on class information, etc., but, as the start of this sentence indicates, that would be going overboard.</p>
