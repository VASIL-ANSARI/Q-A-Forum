<p><code>collections.Counter()</code> is a subclass of <code>dict</code>. Just use <code>Counter().values()</code> to get a list of the counts:</p>

<pre><code>counts = Counter(some_iterable_to_be_counted)
mean = numpy.mean(counts.values())
</code></pre>

<p>Note that I did <em>not</em> call <code>Counter.most_common()</code> here, which would produce the list of <code>(key, count)</code> tuples you posted in your question.</p>

<p>If you must use the output of <code>Counter.most_common()</code> you can filter out just the counts with a list comprehension:</p>

<pre><code>mean = numpy.mean([count for key, count in most_common_list])
</code></pre>

<p>If you are using Python 3 (where <code>dict.values()</code> returns a dictionary view), you could either pass in <code>list(counts.values())</code>, or use the standard library <a href="https://docs.python.org/3/library/statistics.html#statistics.mean" rel="nofollow"><code>staticstics.mean()</code> function</a>, which takes an iterable (including <code>dict.values()</code> dictionary view).</p>

<p>If you meant to calculate the mean <em>key value</em> as weighted by their counts, you'd do your own calculations directly from the counter values. In Python 2 that'd be:</p>

<pre><code>from __future__ import division

mean = sum(key * count for key, count in counter.iteritems()) / sum(counter.itervalues())
</code></pre>

<p>The <code>from __future__</code> import should be at the top of your module and ensures that you won't run into overflow issues with large floating point numbers. In Python 3 that'd be simplified to:</p>

<pre><code>mean = sum(key * count for key, count in counter.items()) / sum(counter.values())
</code></pre>

<p>The median could be calculated with bisection; sort the <code>(key, count)</code> pairs by key, sum the counts, and bisect the half-way point into a accumulated sum of the counts. The index for the insertion point points to the median key in the sorted keys list.</p>
