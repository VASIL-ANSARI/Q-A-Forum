<p>Plain <a href="http://en.wikipedia.org/wiki/Strategy_pattern" rel="nofollow">strategy</a> pattern seems the best strategy to me. </p>

<p>What I understand from your statement is that:</p>

<ol>
<li>The <strong>model</strong> is mutable.</li>
<li>the mutation may happen through different <strong>source</strong>. (ie. different classes)</li>
<li>the model must validate each mutation effort.</li>
<li>Depending on the source of an effort the validation <strong>process</strong> differs.</li>
<li>the <strong>model is oblivious of the source and the process</strong>. its prime concern is the state of object it is modeling.</li>
</ol>

<h2>Proposal:</h2>

<ol>
<li>let the <strong>Source</strong> be the classes which somehow mutate the model. it may be the deserializers, the UI, the importers etc.</li>
<li>let a <strong>validator</strong> be an interface/super-class which holds a basic logic of validation. it can have methods like : <code>validateText(String), validateState(ItemState)</code>...</li>
<li>Every <strong>Source</strong> <em>has-a</em> <strong>validator</strong>. That validator may be an instance of the base-validator or may inherit and override some of its methods.</li>
<li>Every <strong>validator</strong> <em>has-a</em> reference to the <strong>model</strong>.</li>
<li>A source first sets its own validator then takes the mutation attempt.</li>
</ol>

<p>now,</p>

<pre><code>Source1                   Model                  Validator
   |     setText("aaa")     |                        |
   |-----------------------&gt;|    validateText("aaa") |
   |                        |-----------------------&gt;|
   |                        |                        |
   |                        |       setState(2)      |
   |          true          |&lt;-----------------------|
   |&lt;-----------------------|                        |
</code></pre>

<p>the behavior of different validators might be different.</p>
