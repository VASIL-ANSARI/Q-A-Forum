<p>Here are some suggestions that can help with database  management in a multi-developer, version-controlled environment.</p>

<ol>
<li><p><strong>Use a <a href="http://en.wikipedia.org/wiki/Schema_migration" rel="nofollow">migrations</a> library.</strong> There might be one for your stack (e.g. <a href="http://south.aeracode.org/" rel="nofollow">South</a> if you're working with Django 1.6 or earlier, <a href="http://www.doctrine-project.org/projects/migrations.html" rel="nofollow">Doctrine Migrations</a> for Doctrine, <a href="http://guides.rubyonrails.org/migrations.html" rel="nofollow">Active Record Migrations</a> for Rails) or you could use a general purpose tool like <a href="http://www.liquibase.org/" rel="nofollow">Liquibase</a>.</p>

<p>In general, when working with database migrations libraries you end up with a number of versioned files that modify your database in some way. For example you might have a migrations directory containing</p>

<ul>
<li><code>0001_create_initial_schema.sql</code></li>
<li><code>0002_add_user_model.sql</code></li>
<li><code>0003_replace_plaintext_passwords_with_hashed_passwords.sql</code></li>
</ul>

<p>Depending on your library, these scripts may logically be written at the database level or at the ORM level. In general, each script is reversible.</p>

<p>This lets developers easily upgrade their database schemas as development continues.</p></li>
<li><p><strong>Set each developer up with their own copy of the database.</strong> You could ask them to install MySQL locally and have initialization instructions along the lines of "create database, create user, add credentials to config file, run migrations".</p>

<p>Alternatively you could use something like <a href="http://www.vagrantup.com/" rel="nofollow">Vagrant</a> to easily create self-contained virtual machines for developers to use. Vagrant can easily install MySQL and create a database.</p>

<p>Finally, you could create databases for your developers on a centralized server, e.g. <code>app1_john</code>, <code>app1_cindy</code>, <code>app1_joel</code>.</p></li>
</ol>

<p>Using these guidelines, developers have the flexibility to modify their own databases as needed. They can share these modifications cleanly by adding migrations to the code repository. Any developer can reset their database at any time, either by running all the migrations in reverse or by simply dropping the database.</p>

<p>Using this model there should be no need for most developers to have administrative access to the production database. Only allow trusted users to modify the production database, and always upgrade your database schema using the well-tested migrations scripts that you have used everywhere else.</p>

<p>And, of course, keep regular backups.</p>
