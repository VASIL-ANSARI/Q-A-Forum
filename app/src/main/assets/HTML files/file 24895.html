<p>In general, use a <code>lock</code> to synchronize thread access to a section of code.</p>

<pre><code>private static object listLocker = new object();

void AddItemThreadSafe(string item)
{
    this.Invoke((MethodInvoker)delegate
    {
        lock (listLocker)
        {
            listBoxCollection.Items.Add(item);
        }
    });
}

void RemoveItemThreadSafe()
{
    this.Invoke((MethodInvoker)delegate
    {
        lock (listLocker)
        {
            listBoxCollection.Items.RemoveAt(0);
        }
    });
}
</code></pre>

<p>In this particular case (someone correct me if I'm wrong), I believe the fact that you are invoking the methods from the same object already synchronizes the access, making the lock redundant.</p>
