<p>There is no reliable way to do this, because it would automatically be a race condition. In fact, more than that: it could lead to phantom values. Specifically: if you do an insert requiring a new <code>IDENTITY</code> value, and then <em>roll back the transaction</em>, the table's identity  <em>does not revert</em>: there will be a gap. This again: is deliberate.</p>

<p>There is, in SQL Server, an <code>IDENT_CURRENT(object)</code> function that returns the <em>previous</em> identity value for the table - but there are very few scenarios (other than informational tools) where you should use it. You certainly shouldn't use it to prime secondary inserts.</p>

<p>The usual approach here is:</p>

<ul>
<li>do the insert</li>
<li>let the database tell you what the new <code>IDENTITY</code> value is (<code>SCOPE_IDENTITY()</code> in SQL Server)</li>
<li>use that value</li>
</ul>

<p>alternatively, you can do some interesteng multi-part inserts using an <a href="https://msdn.microsoft.com/en-us/library/ms177564.aspx" rel="nofollow"><code>OUTPUT</code> clause</a></p>
