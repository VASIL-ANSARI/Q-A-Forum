<pre><code>&lt;?php

$it = new RecursiveDirectoryIterator(".", RecursiveDirectoryIterator::SKIP_DOTS);
$it = new RecursiveIteratorIterator($it);

$files = new RecursiveArrayIterator(array());
foreach ($it as $fi) {
    $it = $files;
    $dirs = explode('/', $fi-&gt;getPath());
    foreach ($dirs as $path) {
        if (isset($it[$path])) {
            $it = $it[$path];
        } else {
            $it[$path] = new RecursiveArrayIterator();
        }
    }

    $it[$fi-&gt;getFileName()] = $fi-&gt;getFileName();
}



$a = array();
createArray($a, $files);
print_r($a);

function createArray(&amp;$a, $it) {
    foreach ($it as $k =&gt; $tmp) {
        if (is_string($tmp)) {
            $a[] = $tmp;
        } else {
            $a[$k] = array();
            createArray($a[$k], $tmp);
        }
    }
}
</code></pre>

<p>The code is fairly simple, and split in two parts even though it could easily be created in just one part. The first part will split the directories into separate <code>RecursiveArrayIterators</code>, so you keep the "iterator" capabilities to do all kind of other stuff with it. This is often useful when you are using the SPL iterators to begin with.</p>

<p>The second part, the <code>createArray</code> function basically uses an array reference to point to the "current" directory. Since it will be a multidimensional array, we do not have to worry about "where" in the array we actually are (it could be the 1st level, it might as well be the 100th level if your directory structure goes that deep). It just checks if the given element is a string, if so, it's a file, otherwise it's a directory so we recursively call the <code>createArray</code> again.</p>

<p>Might be easier solutions, but I reckon most of them uses a basic array-reference system nevertheless.</p>
