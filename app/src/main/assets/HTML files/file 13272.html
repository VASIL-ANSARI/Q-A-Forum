<p>The only way i found is to draw a layer over every segment.
the bad news is that then you have to colorize by yourself the selected segment every time it changes (and "decolonizee" the unselected)
the good news is that you can have many different sets of colors for every single segment and display a red near a green near a blue...</p>

<p>you can call your method when a segmentedControl change:</p>

<pre><code>- (IBAction)changeSection:(id)sender {
    UISegmentedControl *segmetedControl = sender;
    [self colorize2SegmentsWithSelected:segmetedControl.selectedSegmentIndex];
// (...)
}
</code></pre>

<p>and in your method:</p>

<pre><code>-(void)colorize2SegmentsWithSelected:(int)selected{
    switch (selected) {
        case 0:
            [self myShineGradient:[initialStateArraySegmentedControl objectAtIndex:1] withColor1:myUIColor1  withColor2:myUIColor2];

            [self myShineGradient:[initialStateArraySegmentedControl objectAtIndex:0] withColor1:myUIColor3  withColor2:myUIColor4];
            break;
        case 1:
            [self myShineGradient:[initialStateArraySegmentedControl objectAtIndex:0] withColor1:myUIColor1  withColor2:myUIColor2];

            [self myShineGradient:[initialStateArraySegmentedControl objectAtIndex:1] withColor1:myUIColor3  withColor2:myUIColor4];
            break;
// (...)
}
// (...)
}
</code></pre>

<p>where myColor1 and 2 are the neutral color (UIColor) for unselected segments and 3 + 4 for selected
in your case, if you want just one color make the 1 color = to the second (and 3=4).</p>

<p>initialStateArraySegmentedControl is the initial array of your segmentedControl (it may chance order when clicked, but yu need the initial one), so in your init try this:</p>

<pre><code>initialStateArraySegmentedControl = self.segmentedControl.subviews;
[self setColorForBackGround:self.segmentedControl withColor1:myUIColor1  withColor2:myUIColor2];
</code></pre>

<p>this last line is to keep the corner around the segmented control main view</p>

<p>and:</p>

<pre><code>- (void)myShineGradient:(UIView*)myView withColor1:(UIColor*)color1  withColor2:(UIColor*)color2
{
    //   remove old personal shine layer (if any exists):
    int layerNumberNow = [[myView.layer sublayers] count];
    if (layerNumberNow&gt;2) {
        [[[myView.layer sublayers] objectAtIndex:0] removeFromSuperlayer];
    }
    // add shine layer
    CAGradientLayer *gradientLayer = [CAGradientLayer layer];

    [gradientLayer setBounds:[myView bounds]];
    // Center the layer inside the parent layer
    [gradientLayer setPosition:
     CGPointMake([myView bounds].size.width/2,
                 [myView bounds].size.height/2)];

    // Set the colors for the gradient to the 
    // two colors specified for high and low
    [gradientLayer setColors:
     [NSArray arrayWithObjects:
      (id)[color1 CGColor],(id)[color2 CGColor], nil]];
    [myView.layer insertSublayer:gradientLayer atIndex:layerNumberNow-2];


}
- (void)setColorForBackGround:(UIView*)myView withColor1:(UIColor*)color1 withColor2:(UIColor*)color2
{
    // add shine layer
    CAGradientLayer *gradientLayer = [CAGradientLayer layer];

    [gradientLayer setBounds:[myView bounds]];
    // Center the layer inside the parent layer
    [gradientLayer setPosition:
     CGPointMake([myView bounds].size.width/2,
                 [myView bounds].size.height/2)];

    // Set the colors for the gradient to the 
    // two colors specified for high and low
    [gradientLayer setColors:
     [NSArray arrayWithObjects:
      (id)[color1 CGColor],(id)[color2 CGColor], nil]];

    [myView.layer setBackgroundColor:[ [UIColor colorWithRed:0 green:0 blue:0 alpha:0] CGColor]];

    [myView.layer setCornerRadius:4];
    [[myView layer] setMasksToBounds:YES];

    // Display a border around the button
    // with a 1.0 pixel width

    [[myView layer] setBorderWidth:1.0f];
    [[myView layer] setBorderColor:[ [UIColor colorWithRed:1 green:1 blue:1 alpha:.1] CGColor] ];
    ///
}
</code></pre>

<p>PS
you need to import the quartz framework</p>
