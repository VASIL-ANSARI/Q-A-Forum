<p>Looks to me the design of your code is wrong, or you applying it the wrong way. Since every "VÃ¤rdesak" is worth something, you can/need to define this method at the <code>VÃ¤rdesak</code> level:</p>

<pre><code>public abstract class VÃ¤rdesak {

    public abstract double worth ();

}
</code></pre>

<p>And then:</p>

<pre><code>public class Apparat extends VÃ¤rdesak {

    @Override
    public double worth () {
        return 500.0d;
    }

}
</code></pre>

<p>Or if the price is fixed, you can use a field:</p>

<pre><code>public abstract class VÃ¤rdesak {

    private double value;

    public double worth () {
        return worth;
    }

}
</code></pre>

<p>Now you can simply use the <em>dynamic binding</em> principle:</p>

<pre><code>public class WorthComparator implements Comparator&lt;VÃ¤rdesak&gt; {

    public int compare(VÃ¤rdesak v1, VÃ¤rdesak v2) {
        return Double.compare(v1.worth(),v2.worth());
    }

}
</code></pre>

<p><a href="http://stackoverflow.com/questions/20589590/why-not-use-instanceof-operator-in-oop-design"><code>instanceof</code> calls are in general considered to be a <em>bad smell</em></a>: if you have to use them, there is normally something wrong with the design of your code.</p>

<p>Another advice, please don't use unicode characters in identifiers: use <code>Vardesak</code> instead of <code>VÃ¤rdesak</code>.</p>
