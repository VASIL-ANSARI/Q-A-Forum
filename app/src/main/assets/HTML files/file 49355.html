<p>I would scan through the array with two pointers: one starting from the beginning, and the other from the end. As each pointer walks toward the middle of the array, check whether the values are out of order, and if they are, swap them. When/where the pointers meet, the values are in order.</p>

<p>Note that unlike swapping most other types of values, in this case there's no need to do a typical swap where you copy values around. Let's assume for the moment that you're sorting so all the <code>true</code> values come first, and all the <code>false</code> values second. In this case, if you have to values out of order, it can only be a <code>false</code> coming before a <code>true</code>, and when they're swapped, it can only be a <code>true</code> coming before a <code>false</code>. Rather than a typical swap, you're just looking for a <code>false</code> on the left and a <code>true</code> on the right, and when you find them, you assign <code>true</code> on the left and <code>false</code> on the right.</p>

<p>If you want the output in a separate array, you can take a slightly simpler approach: walk through the input array from beginning to end. For each <code>true</code> you find, set the next value in the output array to <code>true</code> and advance to the next position. When you reach the end of the input array, set the remainder of the values in the output to false:</p>

<pre><code>// ...
for (bool *b = input; b != input_end; ++b)
    if (*b)
       *out++ = true;
while (out != output_end)
    *out++ = false;
</code></pre>

<p>This assumes you want <code>true</code> sorted before <code>false</code>. If you want to reverse that, you change <code>if (*b)</code> to <code>if (! *b)</code> and <code>*out++ = false</code> to <code>*out++ = true;</code>.</p>
