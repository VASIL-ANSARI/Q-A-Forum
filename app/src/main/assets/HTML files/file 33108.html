<p>You might try something like:</p>

<pre><code>/BEGIN_OS 12\s(?:([\w\d]+)\s([\d]+\s))*END_OS/gm
</code></pre>

<p>You'll have to parse the match still for your results, You may also simplify it with something like:</p>

<pre><code>/BEGIN_OS 12([\s\S]*)END_OS/gm
</code></pre>

<p>And then just parse the first group (the text between them) and split on <code>'\n'</code> then <code>' '</code> to get the parts you desire.</p>

<p><strong>Edit</strong></p>

<p>Regexs with comments:</p>

<pre><code>/BEGIN_OS 12          // Match "BEGIN_OS 12" exactly
 \s                   // Match a whitespace character after
 (?:                  // Begin a non-capturing group
   ([\w\d]+)          // Match any word or digit character, at least 1 or more
   \s                 // Match a whitespace character
   ([\d]+\s)          // Match a digit character, at least one or more
 )*                   // End non-capturing group, repeate group 0 or more times           
 END_OS               // Match "END_OS" exactly
/gm                   // global search (g) and multiline (m)
</code></pre>

<p>And the simple version:</p>

<pre><code>/BEGIN_OS 12          // Match "BEGIN_OS 12" exactly
  (                   // Begin group
    [\s\S]*           // Match any whitespace/non-whitespace character (works like the '.' but captures newlines
  )                   // End group
  END_OS              // Match "END_OS" exactly
/gm                   // global search (g) and multiline (m)
</code></pre>

<p><strong>Secondary Edit</strong></p>

<p>Your attempt:</p>

<pre><code>^[BEGIN_OS\s12]+([a-zA-Z0-9]+)\s([0-9]+)
</code></pre>

<p>Won't give you the results you expect. If you break it apart:</p>

<pre><code>^                     // Match the start of a line, without 'm' this means the beginning of the string.
[BEGIN_OS\s12]+       // This means, match a character that is any [B, E, G, I, N, _, O, S, \s, 1, 2] 
                      // where there is at least 1 or more. While this matches "BEGIN_OS 12" 
                      // it also matches any other lines that contains a combination of those 
                      // characters or just a line of whitespace thanks to \s).
([a-zA-Z0-9]+)        // This should match the part you expect, but potentially not with the previous rules in place.
\s
([0-9]+)              // This is the same as [\d]+ or \d+ but should match what you expect (again, potentially not with the first rule)
</code></pre>
