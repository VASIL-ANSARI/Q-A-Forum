<p>I can suggest you to go for the following solution,</p>

<p>Step 1.Create two different layouts (<code>layout</code> &amp; <code>layout_land</code>) and define the design</p>

<p>Step 2.Use a custom view that extends <code>FrameLayout()</code></p>

<p>Step 3. Replace the regular FrameLayout with your custom view,</p>

<pre><code>&lt;MyNonChangingLayout
 android:id="@+id/unity_container"
 android:layout_width="wrap_content"
 android:layout_height="wrap_content"&gt;
&lt;/MyNonChangingLayout&gt;
</code></pre>

<p>Example of MyNonChangingLayout(),</p>

<pre><code>MyNonChangingLayout extends FrameLayout {
        MyNonchangingLayout(Context content) {
            super(context);
            myContext = context;
            makeFromXML();
        }

    private void makeFromXML() {
        LayoutInflater inflater = (LayoutInflater)myContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        topView =  inflater.inflate(MyR.layout.my_non_changing_layout, this, false);
        super.addView(topView);
    }

    /*
     * Then, you can override quite a lot of the layout's calls and
     * enforce behaviour on the children. Two examples:
     */

    // To specifically catch orientation changes
    @Overridge
    onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        // You could create the layout here by removing all views and rebuilding them
        // Perhaps by having a two xml layouts, one of which is "90 degrees out" ...
        // If you do make the layot here, make sure you don't clash with the constructor code!
        switch (newConfig.orientation) {
            case ORIENTATION_LANDSCAPE:
                // Make the layout for this orientation (as per above)
                break;
            case ORIENTATION_PORTRAIT:
                // Make the layout for this orientation (as per above)
                break;
            case ORIENTATION_SQUARE:
                // Make the layout for this orientation (as per above)
                break;
        }
    }

    //to handle size changes to enforce aspect ratios on children:
    @override
    protected void onSizeChanged (int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);

        int viewWidth = //something I've determine
        int viewHeight = //something I've determined
        setViewsize(viewToHaveSizedControlled, viewWidth, viewheight);
    }

    // The post thing means that it doesn't crash no matter which thread it is
    // executed on ...
    private void setViewsize(final View v, final int w, final int h) {
        post(new Runnable() {
            public void run() {
                ViewGroup.LayoutParams lp = v.getLayoutParams();
                lp.width = w;
                lp.height = h;
                v.setLayoutParams(lp);
        }});
    }
</code></pre>

<p>This answer was originally given here,</p>

<p><a href="http://stackoverflow.com/questions/14877701/how-to-prevent-orientation-change-for-just-a-layout-not-the-whole-screen-activi">How to prevent orientation change for just a layout, not the whole screen/activity</a></p>
