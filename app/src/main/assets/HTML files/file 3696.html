<p>The issue is described here:</p>

<p><a href="http://stackoverflow.com/questions/1573977/is-it-safe-to-call-an-rcw-from-a-finalizer">Is it safe to call an RCW from a finalizer?</a></p>

<p>and here:</p>

<p><a href="http://stackoverflow.com/questions/2085972/release-excel-object-in-my-destructor">Release Excel Object In My Destructor</a></p>

<blockquote>
  <p>The trouble is that not only is the timing as to when these objects
  are to be garbage collected uncertain, but the order in which the
  finalizers are called is also nondeterministic. In this case, a
  Runtime Callable Wrapper also has a finalizer, which calls
  Marshal.FinalReleaseComObject on itself, which has the result of
  decrementing the reference count on the COM side of the fence so that
  this COM object can be released. But since the order in which the
  finalizers are called is uncertain, it is very possible that the
  finalizers for the COM objects that your object references will fire
  before the finalizer for your object. So the code within your
  finalizer could work sometimes, but, most of the time, one or more of
  the Runtime Callable Wrappers that your object references will have
  already had their finalizers called and the underlying COM object will
  have been released before your finalizer gets to execute its code.</p>
</blockquote>
