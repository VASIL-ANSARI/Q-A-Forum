<p>At the end of the day there isn't much difference. I find that most people chain up, I can give three reasons I guess.</p>

<p><strong>One</strong> reason I would give is simply because the functionality or logic for a class is totally in one area. And that is the constructor with the full variables.</p>

<p>Imagine:</p>

<pre><code>this.x = 2*x;
</code></pre>

<p>or</p>

<pre><code>if(x&gt;20 &amp;&amp; y&gt;20)....
</code></pre>

<p>The biggest issue is that constructors further down won't have access to "z" since it is only initialized AFTER the chain.</p>

<p>Also many times we don't JUST save variables we set things up based on the variables. This way all the code logic for setup is in one place where variables are also setup.</p>

<p>It would be odd to have all of that code in a constructor where those are not arguments. Can it be done? YES! But a little odd...</p>

<p><strong>The second reason</strong> is that when the variable types are different you could chain up, but not necessarily chain down.</p>

<pre><code>public example(String aString){
  this(aString,0);
}
public example(int aNumber){
  this(null, aNumber);
}
public example(String aString, int aNumber){
  ...
}
</code></pre>

<p>If chaining down:</p>

<pre><code>public example(String aString, int aNumber){
  this(aString);
  this.aNumber = aNumber;
  /**
  You can only call one constructor lower, and you lose "aNumber"
  if you initialize here then your doubling that code and changing
  it means changing it twice. 

  Of course this is ONLY true, if you want to also have the constructor
  for just aNumber, if not there is no issue and it is like your example
  **/
}
public example(String aString){
  this(0);
  this.aString = aString;
}
public example(int aNumber){
  this();
  this.aNumber = aNumber;
  //only an issue if you want both this constructor and "aString" constructor
}
</code></pre>

<p><strong>The third reason</strong> I can think of is that its also what one might expect, both in terms of code and in terms of errors... People will be confused with readability since they aren't used to it.</p>

<p>Similarly, Imagine you get an error from the simple constructor class, it is a little odd, why was a simpler version called? Do you assume it has the same functionality do all constructors lead to the simple constructor or do some of them behave differently? For some reason I would expect all constructors lead to the more complex version, but I am not sure I would assume the opposite. </p>

<p><em>More importantly</em> I would be nervous that the simple constructor is being called because, some arguments are not even dealt with and maybe this constructor with arguments is just a stub to be developed later.</p>

<p>These are always concerns to be fair, but I think it might be a warning sign if a simpler constructor was called instead in a stack trace, at least to me.</p>
