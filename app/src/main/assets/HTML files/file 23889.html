<p>Quoting from the docs</p>

<p><a href="http://developer.android.com/training/displaying-bitmaps/manage-memory.html" rel="nofollow">http://developer.android.com/training/displaying-bitmaps/manage-memory.html</a></p>

<p><strong>On Android 2.3.3 (API level 10) and lower, using recycle() is recommended</strong>. If you're displaying large amounts of bitmap data in your app, you're likely to run into OutOfMemoryError errors. The recycle() method allows an app to reclaim memory as soon as possible.</p>

<p><strong>Android 3.0 (API Level 11) introduces the BitmapFactory.Options.inBitmap field</strong>. If this option is set, decode methods that take the Options object will attempt to reuse an existing bitmap when loading content. This means that the bitmap's memory is reused, resulting in improved performance, and removing both memory allocation and de-allocation.
In honeycomb and later versions bitmap pixel data is allocated on the heap. So you don't need to call recycle in this case. When gc kicks in it will free the memory allocated for bitmaps. </p>

<p>Its the job of the garbage collector to free memory. When it needs to reclaim memory garbage collector kicks in. GC deos mark and sweep. You can check the logcat. </p>

<p>You can see the pause times. Large the heap more frequently gc kicks in and more frequent pause times.</p>

<pre><code> GC_CONCURRENT freed &lt;1K, 14% free 21220K/24455K, paused 6ms+26ms
 GC_CONCURRENT : Jumps in because Heap is full
 14% free 21220K/24455K After this collection 14% of memory is free. Check the heap usage.
 paused 6ms+26ms Time taken to collect garbage.
</code></pre>

<p>There is a talk on this topic @ <a href="https://www.youtube.com/watch?v=_CruQY55HOk" rel="nofollow">https://www.youtube.com/watch?v=_CruQY55HOk</a> </p>
