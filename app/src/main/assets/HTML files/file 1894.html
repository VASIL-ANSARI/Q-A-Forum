<pre><code>result = numpy.where(x == y, x, 0)
</code></pre>

<p>Have a look at <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html" rel="nofollow"><code>numpy.where</code></a> documentation for explanation.  Basically, <code>numpy.where(a, b, c)</code>, for a condition <code>a</code> returns an array of shape <code>a</code>, and with values from <code>b</code> or <code>c</code>, depending upon whether the corresponding element of <code>a</code> is true or not.  <code>b</code> or <code>c</code> can be scalars.</p>

<p>By the way, <code>x &amp; y</code> is not necessarily "always true" for two positive numbers.  It does <a href="http://en.wikipedia.org/wiki/Bitwise_operation#AND" rel="nofollow">bitwise-and</a> for elements in <code>x</code> and <code>y</code>:</p>

<pre><code>x = numpy.array([2**p for p in xrange(10)])
# x is [  1   2   4   8  16  32  64 128 256 512]
y = x - 1
# y is [  0   1   3   7  15  31  63 127 255 511]
x &amp; y
# result: [0 0 0 0 0 0 0 0 0 0]
</code></pre>

<p>This is because the bitwise representation of each element in <code>x</code> is of the form <code>1</code> followed by <code>n</code> zeros, and the corresponding element in <code>y</code> is <code>n</code> 1s.  In general, for two non-zero numbers <code>a</code> and <code>b</code>, <code>a &amp; b</code> may equal zero, or non-zero but not necessarily equal to either <code>a</code> or <code>b</code>.</p>
