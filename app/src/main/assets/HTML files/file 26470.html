<p>As far as the basic idea of the two algorithms go, both are correct. They will do the same number of comparisons but the second one will do more swaps than the first. </p>

<p>You can see this by stepping through the algorithms as they partition the array <code>1 9 2 8 3 7 4 6 5</code> using 5 as the pivot. When the first algorithm swaps two numbers it never touches either of then again. The second algorithm first swaps 9 and 2, then 9 and 3, and so on, taking multiple swaps to move 9 to its final position.</p>

<p>There are other differences too. If I haven't made any mistakes, this is how the first algorithm partitions the array:</p>

<pre><code>1 9 2 8 3 7 4 6 5
f                 l
1 9 2 8 3 7 4 6 5  # swap 9,5
  f             l
1 5 2 8 3 7 4 6 9  # swap 8,4
      f     l
1 5 2 4 3 7 8 6 9  # return f = 5
        l f
</code></pre>

<p>This is how the second algorithm partitions the array:</p>

<pre><code>1 9 2 8 3 7 4 6 5  # 1&lt;5, swap 1,1
bi      
1 9 2 8 3 7 4 6 5  # 9&gt;5, no swap
  bi
1 9 2 8 3 7 4 6 5  # 2&lt;5, swap 9,2
  b i
1 2 9 8 3 7 4 6 5  # 8&gt;5, no swap
    b i
1 2 9 8 3 7 4 6 5  # 3&lt;5, swap 9,3
    b   i
1 2 3 8 9 7 4 6 5  # 7&gt;5, no swap
      b   i
1 2 3 8 9 7 4 6 5  # 4&lt;5, swap 8,4
      b     i
1 2 3 4 9 7 8 6 5  # 6&gt;5, no swap
        b     i
1 2 3 4 9 7 8 6 5  # 5=5, exit loop, swap 9,5
        b       i
1 2 3 4 5 7 8 6 9  # return b = 4
        b       i
</code></pre>

<p>Notice how it makes 5 swaps, compared to just 2 of the other algorithm. It also moves the last item in the array to the middle array. In this case the last item happens to be the pivot so it's the pivot that's moved to the middle, but that's not the general case. </p>
