<p>Take advantage of SFINAE:</p>

<pre><code>void insert(const size_type N, const value_type &amp;element);

template &lt;class iterator_type&gt;
void insert(iterator_type begin, iterator_type end, char (*)[sizeof(*begin)] = NULL);
</code></pre>

<p>The extra dummy argument in the range version of <code>insert</code> will be optimized out by the compiler. Its only role is to eliminate the template function from overloading resolution for types that cannot be used with a dereference operator.</p>

<p>Clarification of the trick:</p>

<p><code>char (*)[sizeof(*begin)]</code> stands for a pointer to an array of chars whose size is equal to <code>sizeof(*begin)</code>. If the variable <code>begin</code> is not dereferenceable then this would be an error. However, in the context of considering a function template during function overload resolution, such an error doesn't stop compilation, but simply discards the template (Substitution Failure Is Not An Error - SFINAE).</p>
