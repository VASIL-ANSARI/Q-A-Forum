<p>I can't see how this could possibly fail to write the value under any circumstances, if it's just a write and not a read.</p>

<p>The reason that multithreaded access to the same variable is dangerous is precisely that there's <em>no checking</em> being done as to whether the variable is being modified during an operation. It's not that it might check and then complain.</p>

<p>So in the case of a single write, and just a write (so no <code>i++</code>, which is a read as well), it must succeed.</p>

<p>Of course, you could design hardware that would fail if you wanted to, but I don't see how any standard architecture could fail.</p>

<p>As Anton points out in his answer, the spec says it's undefined behaviour, and so it would be possible to write a valid C++ compiler that deliberately watches out for such behaviour and randomises the result. But no compiler is going to do that in practice.</p>

<p>That said, it's never a good idea to rely on behaviour that's officially undefined, so as the comment from jeffamaphone says, the right answer to your question is that the write will succeed, but you still shouldn't do it.</p>
