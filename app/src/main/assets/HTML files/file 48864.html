<p>It seems like you've answered your own question by alluding to the Strategy pattern. You need concrete strategies that implement an interface like this:</p>

<pre><code>interface IAuthorise
{
   bool Authorised();
}
</code></pre>

<p>Then your concrete strategies fill-in the gaps:</p>

<pre><code>class CanEditExceptionQueueAuthorisationStrategy : IAuthorise
{
    bool Authorised()
    {
        return 
           isInRole(RoleLitigationManager) 
           || isInRole(RoleBankruptcyManager) 
           || isInRole(RoleCOO) 
           || isInRole(RoleEVP) 
           || isInRole(RoleRecoveryVicePresident) 
           || isInRole(RoleNegotiationManager);
    }
}
</code></pre>

<p>Now <code>AuthorizeGeneral()</code> can use a factory to create the appropriate strategy:</p>

<pre><code>public static bool AuthorizeGeneral(string rule)
{
    var authorisor = AuthorisorFactory.CreateAuthorisor(rule);

    return authorisor.Authorised();
}
</code></pre>

<p>Or it could have the single, appropriate strategy injected. Or it could have all the strategies injected and find the appropriate one itself based on <code>rule</code>. This decision depends on how many rules you have and what works best for you considering the code beyond this class.</p>
