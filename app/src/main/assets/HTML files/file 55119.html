<p>Compare async functions to ES6 generator functions and it is pretty obvious:</p>

<pre><code>function* x() {} // Generator function without 'yield'
Object.getPrototypeOf(x); // returns GeneratorFunction
</code></pre>

<p>Generator functions are inherently different from traditional functions, but they do not need to have a <code>yield</code> expression in their body. There was actually <a href="http://bugs.ecmascript.org/show_bug.cgi?id=1283" rel="nofollow">a bug in the ES6 proposal</a> which stated that it is a syntax error if the generator function does not contain a <code>yield</code>, but it was quickly fixed:</p>

<blockquote>
  <p>One important use case is prototyping with a dummy generator. Or the
  case where you comment out a yield for debugging. That shouldn't
  render the program illegal.</p>
</blockquote>

<p>The same holds for async functions: According to <a href="https://tc39.github.io/ecmascript-asyncawait/#async-decls-exprs-static-semantics-early-errors" rel="nofollow">the draft</a>, an async function is not required to have an <code>awaits</code> in its body while still behaving different from a traditional function.</p>

<p>Let's say you comment an <code>await</code> out. Should the interpreter then parse your async function as a traditional function and possibly break your whole code? Better not.</p>
