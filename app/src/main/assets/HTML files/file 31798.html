<p>If possible, I would use an array of uint16_t to store the number of milliseconds (or use an even larger type, depending on how large the time value you need to store will be). </p>

<p>Since your comment suggests you can't do that for some reason, I would suggest breaking it up so that the least significant bits are in the first element, and the most significant bits are in the second. For example, if you had a timestamp with a hex value <code>0x1234</code>, you could store it as</p>

<pre><code>myArray[0] = 0x34;
myArray[1] = 0x12;
</code></pre>

<p>Note that you could read and write these values as if they were 16 bit values, event though they are in an array of 8-bit values, using a type-casting and pointers, using something along the lines</p>

<pre><code> my16bitValue = ((uint16_t*)myArray)[0];
</code></pre>

<p>As long as you both read and write this way, the endianness of the processor doesn't matter. As chux points out below, though, if you are accessing memory on boundaries that are not aligned properly (i.e. memory addresses which are not a multiple of the number of bytes in the type), then you may get a segfault, or at least significantly decreased performance, depending on your architecture. There may be a better way, but it is hard to say without knowing more about what you are trying to accomplish.</p>
