<p>I guess because it reduces encapsulation. In your example, it's going to be a right pain when you write map_api to go to the api.h and import it into the api namespace. Having one big header api.h that imports every sub-namespace is not exactly include minimization.</p>

<ul>
<li><p>map.h:</p>

<pre><code>namespace map_api { /* fns */ }
</code></pre></li>
<li><p>api.h:</p>

<pre><code>#include &lt;map.h&gt;
namespace api { using map_api::map; }
</code></pre></li>
</ul>

<p>Or, considering other header layouts: if the imports into the api namespace happen in another file:</p>

<ul>
<li><p>map_internal.h:</p>

<pre><code>namespace map_api { /* fns */ }
</code></pre></li>
<li><p>map_api.h:</p>

<pre><code>#include &lt;map_internal.h&gt;
namespace api { using map_api::map; }
</code></pre></li>
</ul>

<p>That's pretty painful too, having to split out the api into two files like that.</p>

<p>The final possibility is doing it all in one file:</p>

<ul>
<li><p>map.h:</p>

<pre><code>namespace map_api { /* fns */ }
namespace api { using map_api::map; }
</code></pre></li>
</ul>

<p>In that case, what's the point I wonder of putting things in two namespaces that are on the same level of abstraction, if they're both equally exposed to all clients/includers..?</p>
