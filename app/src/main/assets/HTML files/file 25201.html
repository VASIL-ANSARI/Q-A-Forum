<p><code>$("#pagination-centered")</code> will look for that selector in the current window dom. This means that if the content of your template (where the <code>pagination-centered</code> element is defined) is not in the dom, it won't be find (yelding to a null <code>el</code> and nothing being rendered).</p>

<p>I think there are clearer way to achieve good templating in Backbone, but what would be quick and easy in your case is to create the views as</p>

<pre><code>var Home = Backbone.View.extend({
    tagName: "section",
    render: function() {
        this.$el.html( /* load the content of your home template here */);
        var list = this.$('#pagination-centered')
        for ( ... ) // here you loop over your models
            list.append(singlePost.render().el);
        return this;
}

var SinglePost = Backbone.View.extend({
    tagName: "li",
    render: function() {
        this.$el.html( /* load the content of your single post template here */);
        return this;
    }
}
</code></pre>

<p>One of the common pitfalls in Backbone Views is that each view has an <em>implicit</em> element that wraps everything that gets rendered. In this case for example your Home template will be rendered within a <code>section</code>. What you tried to do (assigning the <code>el</code> property to a certain dom selector) while tecnically possible, is not the common or suggested way to achieve that.</p>

<p>Another suggestion is to try to have meaningful and semantically correct markup. If <code>pagination-centered</code> is a list, it should be a <code>ul</code> or <code>ol</code>, not a <code>div</code>.</p>
