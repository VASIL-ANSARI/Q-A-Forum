<p>It increases maintainability. If you have a type T and you call a function with it, then you need to change T, if the function has been overloaded for the new T then you can recompile instantly. In C you would have to go back and dig through all the call sites and change the function called. Take sqrt(). If you want to sqrt() a float, then you have to change to sqrtf().</p>

<p>Not just that, but the volume and complexity of C++'s type system is far more than in C, and having to have separate function names for every possible overload would quickly exhaust the reasonable pool of names for functions that serve the same purpose but take different arguments, because now there's a lot more arguments to take. </p>

<p>For example, compare the C and C++ string libraries. The C string library offers one method to append to a string - strcat(). C++'s std::string::append has eight overloads. What do you want to call them? append_a, append_b, etc? That's ridiculous- they all serve the same function, just in different ways.</p>

<p>Edit: It <em>is</em> actually worth mentioning that <code>append</code> is a really bad example, many of the C++ string overloads are very redundant. However, this is more general case than that and not <em>all</em> of those overloads redundant.</p>
