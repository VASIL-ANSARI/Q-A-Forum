<p>Regular functions use execution context to set the value of <code>this</code>, meaning that in in most cases, the value of <code>this</code> is determined by how a function is called, i.e. the value of <code>this</code> is set according to the environment in which the function is executed.</p>

<p>Arrow functions do not have their own <code>this</code> value, instead they use lexical scoping, meaning the value of <code>this</code> inside an arrow function is always inherited from the enclosing scope, i.e. it is set to the <code>this</code> value of the enclosing execution context.</p>

<p>This is explained in the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="nofollow">documentation</a> as well</p>

<blockquote>
  <p>Until arrow functions, every new function defined its own <code>this</code> value
  (a new object in case of a constructor, undefined in strict mode
  function calls, the context object if the function is called as an
  "object method", etc.). This proved to be annoying with an
  object-oriented style of programming.<br>
  ....<br>
  Arrow functions capture the this value of the enclosing context</p>
</blockquote>

<p>The third example posted is just a regular <code>for</code> loop, and has very little in common with functions, and can't really be compared to the two first code examples.<br>
<code>for</code> loops work the same in ES2015 as they always have, there generally is no special scope in <code>for</code> loops for variables, as variables <em>(defined with <code>var</code>)</em> are function scoped.</p>

<p>However, ES2015 does introduce variables that can are block scoped as wel,  and as a  <code>for</code> loop is in fact a block <em>(<code>for (what) {block}</code>)</em>, those variables can be used, and they are defined with either the <code>let</code> keyword, or the <code>const</code> keyword for a constant <em>(that can not be changed)</em> .</p>

<p>For those that prefer code</p>

<pre><code>var o = {
    nums  : [1,2,3,4],
    fn    : function() {
        var self = this;
        this.nums.forEach(function(v) {
            // "this" in this context would be the window,
            // but "self" would be the object "o", hence the common use of this hack
        });

        this.nums.forEach((v) =&gt; {
            // "this" in this context, would be the object "o"
            // that happens because the "this-value" in the fn() function,
            // ... is the parent object
            // and the arrow function inherits that this-value
        });

        for (var i=0; i&lt;this.nums.length; i++) {
            // "this" in this context is what it has always been,
            // a for-loop has the same this-value as the surrounding scope
        }
    }
}

o.fn(); // called from global context "window"
</code></pre>
