<p>In this sample, your code appears to be stepping down the left side of each tree (but ignoring the right side).</p>

<pre><code>if(top-&gt;left!=NULL)
{
  top=top-&gt;left;
  display();
}
</code></pre>

<p>Generally, a BST has nodes, each node has data, a ptr to left child, and a ptr to right child.</p>

<p>And it appears that your nodes do not yet contain a "display()" method.</p>

<hr>

<p>In a tree, I suspect you want to be invoking</p>

<pre><code>&lt;a node&gt; -&gt; display();
</code></pre>

<p>To avoid passing pointers in your recursive 'display' calls.</p>

<p>Next, your names are misleading (to me).  So perhaps if you rename some things, the following might be appropriate and more understandable to you.</p>

<p>Each node needs at least 3 parts, and the display method.  For a depth-first-search, in-line display maybe the following will trigger some thoughts.</p>

<pre><code>Node::display(void)
{
   // first, display nodes of left side-of-tree
   if(nullptr != left)
   { 
       left-&gt;display();
   }
   // else no left node available


   // for in-order, cout the data at this node
   std::cout &lt;&lt; data &lt;&lt; std::endl;


   // continue the depth-first display by tracing the right side
   if (nullptr != right)
   {
       right-&gt;display();
   }
}
</code></pre>

<p>To begin the the display track, you need to have an anchor of the tree.  Perhaps something like:</p>

<pre><code>Tree::display()
{
   if(tree.Top) // is tree not empty?
      tree.Top-&gt;display();
   ...
</code></pre>

<p>So ... I am suggesting a class for tree, another class for node, a display method for tree, a display method for node, etc.</p>

<p>Hope this helps ... Good luck.</p>
