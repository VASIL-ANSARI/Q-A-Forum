<p>With or without a dummy node, a key part of building a new list is staying one node behind where you logically are.  I prefer to do so without a dummy node, so the pointer used for current position is <code>ListNode** temp</code> and you allocate new nodes with <code>(*temp)=new ListNode(x)</code> and advance to the next (predecessor) position with <code>temp=&amp;(*temp)-&gt;next</code>.  If you prefer to use a dummy node, you use <code>ListNode* temp=&amp;dummy;</code> and allocate new nodes with <code>temp-&gt;next=new ListNode(x)</code> and advance with <code>temp=temp-&gt;next</code> only after your logical position is one beyond that.</p>

<p>Edit based on your comment.  If you want to avoid the syntax (not reality) of the double pointer:</p>

<pre><code>ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {

        ListNode dummy = ListNode(0);
        ListNode * temp = &amp;dummy;
        int carry =0;

        while(l1!=NULL || l2!=NULL)
        {
            if (l1!=NULL)
            {
                 carry += l1-&gt;val;
                 l1 = l1-&gt;next;
            }
            if (l2!=NULL)
            {
                 carry += l2-&gt;val;
                 l2 = l2-&gt;next;
            }

            temp = temp-&gt;next = new ListNode(carry%10);
            carry /= 10;
        }

        if(carry==1) temp-&gt;next = new ListNode(1);

        return dummy.next;

    }
</code></pre>
