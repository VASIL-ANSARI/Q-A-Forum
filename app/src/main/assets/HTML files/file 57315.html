<blockquote>
  <p>My question is, why does the compiler choose my Contains() method with non-generic <code>IEnumerable</code> argument over <code>Enumerable.Contains&lt;T&gt;()</code> with <code>IEnumerable&lt;T&gt;</code> argument?</p>
</blockquote>

<p>Because it's found in the same namespace that contains the method calling it. Types declared within that namespace effectively have precedence over types declared in imported namespaces.</p>

<p>From the C# 5 specification, section 7.6.5.2:</p>

<blockquote>
  <p>The search for C proceeds as follows: </p>
  
  <ul>
  <li>Starting with the closest enclosing namespace declaration, continuing with each enclosing namespace declaration, and ending with the containing compilation unit, successive attempts are made to find a candidate set of extension methods:
  
  <ul>
  <li>If the given namespace or compilation unit directly contains non-generic type declarations Ci with eligible extension methods Mj, then the set of those extension methods is the candidate set.</li>
  <li>If namespaces imported by using namespace directives in the given namespace or compilation unit directly contain non-generic type declarations Ci with eligible extension methods Mj, then the set of those extension methods is the candidate set.</li>
  </ul></li>
  <li>If no candidate set is found in any enclosing namespace declaration or compilation unit, a compile-time error occurs. </li>
  </ul>
</blockquote>
