<p>Well, it's simple: you are violating the <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="nofollow">LISKOV Substitution Principle</a> by having <code>ConcreteFlux</code> inherit from <code>ConcreteModelProps</code>; so it's only right you pay the price.</p>

<p>Now, if you <em>externalized</em> the data, you could be working with a saner model.</p>

<pre><code>template &lt;typename FluxType, typename SourceType&gt;
class Model {
public: 
    typedef typename FluxType::DataType DataType;
}; // class Model

template &lt;typename M&gt;
class ConcreteModel: public M {
}; // class ConcreteModel
</code></pre>

<p>And then:</p>

<pre><code>class ConcreteFlux {
public:
    typedef ConcreteModelProps DataType;
};

class ConcreteSource {
public:
    typedef ConcreteModelProps DataType;
};

template &lt;typename Data&gt;
class DefaultSource {
    typedef Data DataType;
};
</code></pre>

<p>With finally:</p>

<pre><code>class ConcreteModel&lt;Model&lt;ConcreteFlux, ConcreteSource&gt;&gt; {};
</code></pre>

<p>Of course, this means that now all methods of <code>ConcreteFlux</code> and <code>ConcreteSource</code> need be passed the handle to <code>ConcreteModelProps</code> in each of their method. That's what <em>externalization</em> was about.</p>
