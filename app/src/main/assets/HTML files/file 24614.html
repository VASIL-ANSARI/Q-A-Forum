<p>Call it in the <code>.__init__()</code> initializer then:</p>

<pre><code>class Something(object):
    def __init__(self):
        self.our_random = Something.random_thing()
</code></pre>

<p>or call the static method <em>after</em> you defined it, but are still defining the class; because it is a static method, you'd have to access it through the <code>__func__</code> attribute:</p>

<pre><code>class Something(object):
    @staticmethod
    def random_thing():
        return 4

    our_random = random_thing.__func__()
</code></pre>

<p>If you didn't mean to call it, just create a copy of the method with a different name, just do so after you defined it:</p>

<pre><code>class Something(object):
    @staticmethod
    def random_thing():
        return 4

    our_random = random_thing   # our_random as an alias for random_thing
</code></pre>

<p>The class body is executed as a function, with the local namespace of the function then forming the class attributes. So, like a function, if you want to refer to other objects you need to make sure they are defined first.</p>
