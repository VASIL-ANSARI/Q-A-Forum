<p>Zope interfaces don't care about class methods; they only specify what API a specific interface must implement. Note that you specify methods <em>without</em> the <code>self</code> parameter, for example. This way, you can implement an interface any way you like, including using regular functions in a module!</p>

<p>If the implementation chooses to make that callable a <code>classmethod</code> is entirely outside of the scope of interfaces. Interfaces only care about what API you'd use when you access interface providers; if an instance has a callable then the end-user shouldn't need to care if that is a class method.</p>

<p>If the class method should be available on the class directly, then that's the interface the <em>class</em> must provide; lets call it the factory interface here:</p>

<pre><code>class IMessageFactory(Interface):
     def __call__():
         """Produce an IMessage provider"""

     def parse(msg):
         """Parses `msg` into a IMessage provider"""


class IMessage(Interface):
     """A message interface"""

     # Optional, show the class method here too
     def parse(msg):
         """Parses `msg` into a IFoo provider"""
</code></pre>

<p>Your <code>Foo</code> class directly provides <code>IMessageFactory</code>, and implements the <code>IMessage</code> interface (so that it's instances provide it).</p>
