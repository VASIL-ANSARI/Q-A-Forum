<p>as I understand, you have two monotonic functions, one that increases to the right, and one that decreases to the right.</p>

<p>Your arrays are sorted points, thus beginning at the most inferior <code>x</code> coordinate for each one. </p>

<p>What you could do is compare each point of the first array to each point of the second array, and store an object like so:</p>

<pre><code>//point
{
    pointIncreasing: [xj, yj],
    pointDecreasing: [zi, wi],
    distance : //distance between the points
}
</code></pre>

<p>And then to calculate the distance you check:</p>

<ul>
<li><p>Whether the two share the same x or y coordinate, in which case the distance is <code>Math.abs(xj-zi)</code> or <code>Math.abs(yj-wi)</code>.</p></li>
<li><p>If they don't share an x or y coordinate you can use the theorem of Pythagoras to find the distance as <code>d = Math.sqrt(Math.pow(Math.abs(xj-zi),2) + Math.pow(Math.abs(yj-wi),2))</code></p></li>
</ul>

<p>So at the end you would get a function like so:</p>

<pre><code>var results = [];
 function populateResults(fun1, fun2){
    for (var j = 0; j &lt; fun1.length; j++){
        for (var i = 0; i&lt; fun2.length; i++){
            var temp = {
                pointI : fun1[j],
                pointD : fun2[i],
                d : null
            }
            // do as said before, add some ifs, calculate distance
            // and do a temp.d = calculatedDistance

            // and add an if calculatedDistance == 0, to stop the
            // loop, because you got your intersection
            results.push(temp);
        }
    }

    results.sort(function(a, b){return (a.d - b.d);});
    // to sort your results array, not sure of order though...
}
</code></pre>

<p>And then you just need to take <code>results[0]</code> and you've got your two closest points, or intersection if <code>distance == 0</code>.</p>

<p>Hope this helps!</p>
