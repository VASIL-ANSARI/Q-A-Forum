<p>The idea is right, but I think you're missing a call to <code>.first</code>:</p>

<pre><code>@booking = @order.bookings.where(product_id: params[:product_id])
  =&gt; #&lt;ActiveRecord::Relation&gt;
</code></pre>

<p>should be:</p>

<pre><code>@booking = @order.bookings.where(product_id: params[:product_id]).first
  =&gt; #&lt;Booking&gt;
</code></pre>

<p>...otherwise you're updating the relation and not a <code>Booking</code> model.  You probably also want to call <code>@booking.save</code> after you modify it.</p>

<p>Separately, ActiveRecord also has <a href="http://apidock.com/rails/v4.2.7/ActiveRecord/Relation/first_or_initialize" rel="nofollow"><code>first_or_initialize</code></a> and <a href="http://apidock.com/rails/v4.2.7/ActiveRecord/Relation/first_or_create" rel="nofollow"><code>first_or_create</code></a> helpers which let you find a matching instance or build/create a new one:</p>

<pre><code>@booking = @order.bookings.where(product_id: params[:product_id]).first_or_initialize
if @booking.new_record?
  @product = @booking.product
  ...other stuff for new record...
else
  @booking.product_quantity = params[:product_quantity]
end
@booking.save
</code></pre>
