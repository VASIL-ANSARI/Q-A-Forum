<p>This is not hard to do. All you need is a counter variable to keep track of which path you are currently printing. In your case you can set a counter to 0 before you call the <code>DFS()</code> function. Then before each print you increment it and then print your line saying which path it is. After that you call <code>printPath()</code>. This could look something like that:</p>

<pre><code>private int pathCount = 0;

// more of you code ...

private void DFS(GraphPath1 graph, LinkedList&lt;String&gt; visited) {
    LinkedList&lt;String&gt; nodes = graph.adjacentNodes(visited.getLast());
    // examine adjacent nodes
    for (String node : nodes) {
        if (visited.contains(node)) {
            continue;
        }
        if (node.equals(END)) {
            visited.add(node);
            pathNumber++;
            System.out.println("This is path " + pathNumber + ":");
            printPath(visited);
            visited.removeLast();
            break;
        }
    }

    // the rest of the algorithm ...
}
</code></pre>

<p><strike>One more thing: If you make DFS a static function (<code>private static void DFS(...)</code>),  you can call it directly from the main function without having to create an instance of the Search class and <code>new Search().DFS(graph, visited);</code> can be turned into <code>DFS(graph, visited);</code>.</strike>
As we now use a instance variable to keep track of the path count, one instance of the Search class per search is what we want.</p>

<p>Edit: Reworked code snippet to use a instance variable instead of a local one in the function, which does not work as the function is recursive. Thanks to Andreas for pointing that out.</p>
