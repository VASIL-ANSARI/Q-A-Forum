<p>In JavaScript, certain types are passed by value, while others are passed by reference. In particular, integers and other basic types are passed by value, so you can't directly retrieve a pointer to them.</p>

<p>However, if you used an <code>Integer</code> constructor (I can't remember of JavaScript has a standard one), which wraps the primitive integer, you could pass around a pointer to the <code>Integer</code> object instead. This would allow updating the value via pointer.</p>

<p>It's been a while since I worked with JavaScript, so I'm not sure if this next idea is feasible. When you instantiate a new function, that function closes over the variables that are currently in scope. This means that you should be able to do something like this:</p>

<pre><code>myInstantiation = new myFunc(new function(newValue) { myVar = newValue } );
</code></pre>

<p>which you could then used from within <code>myFunc</code>. (the syntax might be a little off, but the idea should work I think. Like I said, I don't really do JavaScript anymore).</p>

<h2>EDIT</h2>

<p>So, yeah, the last part is pointless as far as your question goes - I got the situation backwards. However, you could use the dual function instead:</p>

<pre><code>myInstantiation = new myFunc(new function() { return myVar } );
</code></pre>

<p>By calling the given function instead of directly using <code>myVar</code>, the changed should be visible from within <code>myFunc</code>. And if you'd like easy two-way communication, you can use both the function from before and this new one to get/set <code>myVar</code> from within <code>myFunc</code>.</p>
