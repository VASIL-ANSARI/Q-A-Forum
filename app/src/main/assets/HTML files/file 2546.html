<p>Are you wanting to have a salt because you're trying to do password hashing? If so, please consider <a href="http://www.mindrot.org/projects/jBCrypt/" rel="nofollow">jBCrypt</a>, a secure, really easy-to-use, password hashing library. You can probably easily hook it in as a Groovy string metamethod. :-P</p>

<p>And if you're not doing password hashing, I'm not sure where a salt would come in; please feel free to elaborate in that case. :-)</p>

<hr>

<p>Example of how to use HMAC to do keyed hashing (I used <code>HmacMD5</code> in my example, but you can use <code>HmacSHA1</code>, <code>HmacSHA256</code>, <code>HmacSHA384</code>, or <code>HmacSHA512</code> also):</p>

<pre><code>import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

public byte[] hmacMD5(byte[] key, byte[] data) {
    Mac mac = Mac.getInstance("HmacMD5");
    mac.init(new SecretKeySpec(key, "HmacMD5"));
    mac.update(data);
    return mac.doFinal();
}
</code></pre>

<p>I'm sorry that this is in Java and not Groovy, but hopefully it'll be easy enough for you to adapt. :-) Anyway, in this example, your constant value would be the key, and the incoming data would be the data.</p>

<p>If your data is sizeable (unlikely from what you've described), you can call <code>update</code> multiple times, and the hash would work as though the data from those calls were all concatenated together.</p>
