<p>Using Serialization in your scenario may not be the best pick. To avoid the crash you can use serialVersionUID to distinguish betweeen different versions of the same class.</p>

<p>From the Java API:</p>

<blockquote>
  <p>The serialization runtime associates with each serializable class a
  version number, called a serialVersionUID, which is used during
  deserialization to verify that the sender  and receiver of a
  serialized object have loaded classes for that object that are 
  compatible with respect to serialization.</p>
  
  <p>If the receiver has loaded a class for the object that has a
  different serialVersionUID than that of the corresponding sender's
  class, then deserialization will result in an InvalidClassException.</p>
  
  <p>A serializable class can declare its own serialVersionUID explicitly by declaring a
    field named serialVersionUID that must be
  static, final, and of type long.</p>
</blockquote>

<p>Is your data model so complex that it can't be written in SQLite DB? This will allow you to handle the load of the model selectively, skipping null attributes that may result loading a new model with an older structure.</p>
