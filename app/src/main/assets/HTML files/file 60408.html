<p>As per your link, <code>awgn</code> is part of the MATLAB Communications toolbox, <a href="https://www.mathworks.com/help/comm/ref/awgn.html" rel="nofollow">https://www.mathworks.com/help/comm/ref/awgn.html</a>.  It isn't part of the basic MATLAB package.</p>

<p>Similarly, in Python you'll have to go looking at some third party package, something involving signals, communications.  <code>numpy</code> is the package that implements MATLAB like arrays, and many specialized tasks are implemented in <code>scipy</code>, or even in an addon <code>scikit</code>.</p>

<p>So the proper question isn't <code>why does not Python have it?</code>, but rather, <code>is there some Python package that implements it?</code></p>

<p>And as Mahdi commented, there is a function of that name in <a href="https://github.com/veeresht/CommPy/blob/master/commpy/channels.py" rel="nofollow">https://github.com/veeresht/CommPy/blob/master/commpy/channels.py</a></p>

<p>It doesn't look very complicated, so others might have implemented it as well.</p>

<p>As this link shows, <a href="http://stackoverflow.com/questions/14058340/adding-noise-to-a-signal-in-python">adding noise to a signal in python</a>, <code>numpy</code> has a <code>np.random.normal</code>, which will do most of the work.</p>

<p>Python / Numpy / Scipy is not supported by an international company.  Functionality like this gets added by individuals working on their own projects.  I wouldn't be surprised if the MATLAB Communications package has its origin in some third-party project many years ago. </p>

<p>The <code>scipy.signal</code> docs has an example of adding normal noise to test case</p>

<p><a href="http://docs.scipy.org/doc/scipy/reference/tutorial/signal.html#periodogram-measurements" rel="nofollow">http://docs.scipy.org/doc/scipy/reference/tutorial/signal.html#periodogram-measurements</a></p>

<pre><code>fs = 10e3 
N = 1e5 
amp = 2*np.sqrt(2)  
freq = 1270.0 
noise_power = 0.001 * fs / 2 time = np.arange(N) / fs 
x = amp*np.sin(2*np.pi*freq*time) 
x += np.random.normal(scale=np.sqrt(noise_power), size=time.shape)
</code></pre>
