<p>Your problem comes from the way you have structured your control statements (if, elif, else). When you enter your tie while loop, you are constantly running it until someone wins and that looks like it works no problem. The issue is that once you do that, the python interpreter skips all elif and else statements in that control block (if I say if x == 3: do this else: do that) I don't want python to follow through with the else condition if x does indeed == 3). Sorry if that is confusing, long story short you need to make sure that even when your tie block gets executed you still move on to scoring the round and starting a new one. The easy way to do that is just change the elif (player == "r") to an if statement. That way the interpreter treats the scoring control sequence as its own block and it will always be executed once you assign the throws each player makes.</p>

<h1>Example:</h1>

<pre><code>def f(x):
    if (x == 0):
        print("1")
        x += 1
    elif (x == 1):
        print("2")
    print("Done!")

def g(x):
   if (x == 0):
       print("1")
       x += 1
   if (x == 1):
       print("2")
   print("Done!")
</code></pre>

<p>if you call f(0):
Python will print out 1 and then Done!</p>

<p>if you call g(0):
Python will print out 1 then 2 then Done! </p>
