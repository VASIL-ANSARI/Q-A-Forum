<p>Well, spies are useful for a bit different scenario. Much depends on how you yourself define the scope of your unit test as well. If you do the minimal possible unit (i.e. method) then lets imagine the following:</p>

<pre><code>var x = function() { }
x.prototype.f1 = function() { 
        //do something 
        },
x.prototype.f2 = function(){
          // do something else
          this.f1();
        }
</code></pre>

<p>Now, in your unit test for f2 you are not interested in how f1 works inside. so, you make a spy on it:</p>

<pre><code>var a = new x();
a.f1 = jasmine.createSpy("spy-on-f1");
expect(a.f1).not.toHaveBeenCalled();
a.f2();
expect(a.f1).toHaveBeenCalled();
</code></pre>

<p>For example, for angularjs applications, I often mock whole services with spies, just to isolate the algorithm in testing.</p>

<p>As a bonus, you can actually replace the real call with some fake function like this:</p>

<pre><code>a.f1 = jasmine.createSpy("fake-spy").and.callFake(function(){
    // do something predictible or return global variable that can be set externaly
});
</code></pre>
