<p>You could use <a href="http://en.cppreference.com/w/cpp/string/byte/memcpy"><code>memcpy</code></a>.</p>

<p>If the multidimensional array size is given at compile time, i.e <code>mytype myarray[1][2]</code>, then only a single memcpy call is needed</p>

<pre><code>memcpy(dest, src, sizeof (mytype) * rows * coloumns);
</code></pre>

<p>If, like you indicated the array is dynamically allocated, you will need to know the size of both of the dimensions as when dynamically allocated, the memory used in the array won't be in a contiguous location, which means that memcpy will have to be used multiple times.</p>

<p>Given a 2d array, the method to copy it would be as follows:</p>

<pre><code>char** src;
char** dest;

int length = someFunctionThatFillsTmp(src);
dest = malloc(length*sizeof(char*));

for ( int i = 0; i &lt; length; ++i ){
    //width must be known (see below)
    dest[i] = malloc(width);

    memcpy(dest[i], src[i], width);
}
</code></pre>

<p>Given that from your question it looks like you are dealing with an array of strings, you could use <a href="http://en.cppreference.com/w/cpp/string/byte/strlen">strlen</a> to find the length of the string (It must be null terminated).</p>

<p>In which case the loop would become</p>

<pre><code>for ( int i = 0; i &lt; length; ++i ){
    int width = strlen(src[i]) + 1;
    dest[i] = malloc(width);    
    memcpy(dest[i], src[i], width);
}
</code></pre>
