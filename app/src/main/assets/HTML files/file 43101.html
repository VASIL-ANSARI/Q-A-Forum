<p>You can create a <code>ScheduledThreadPoolExecutor</code> with one single thread using <code>Executors.newSingleThreadScheduledExecutor()</code>.</p>

<p>Optionally, you can pass a <code>ThreadFactory</code> as parameter if you want to have more control about this single thread. The thread factory's <code>newThread(Runnable)</code> method is called every time the executor wants to have a new <code>Thread</code> instance that should run the given <code>Runnable</code> (which is not identical to the <code>Runnable</code> you pass to the executor's <code>execute(...)</code>, <code>submit(...)</code> or <code>schedule(...)</code> methods).</p>

<p>Note that you are not able to reuse an existing thread, as there is no way to 'inject' code into an already running thread in general, as it is possible in <a href="http://www.qt.io/developers/" rel="nofollow">Qt</a>. There, every thread has its own event queue and timing facility, so you can freely decide which (already existing) thread should process your timed task (see <a href="http://doc.qt.io/qt-5/timers.html" rel="nofollow">Timers in Qt</a>).</p>

<p>There is no such feature in Java out of the box.</p>
