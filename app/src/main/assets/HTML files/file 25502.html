<p>Please note: Everything after and including <code>ToList()</code> won't work on <code>IQueryable&lt;T&gt;</code> but on <code>IEnumerable&lt;T&gt;</code>. Because of this, there is no need to create expression trees. It certainly is nothing that is interpreted by EF or similar.</p>

<p>If you would look at the code that is generated by the compiler for your original query, you would see that it generates expression trees only until just before the first call to <code>ToList</code>.</p>

<p>Example:</p>

<p>The following code:</p>

<pre><code>var query = new List&lt;int&gt;().AsQueryable();
query.Where(x =&gt; x &gt; 0).ToList().FirstOrDefault(x =&gt; x &gt; 10);
</code></pre>

<p>Is translated by the compiler to this:</p>

<pre><code>IQueryable&lt;int&gt; query = new List&lt;int&gt;().AsQueryable&lt;int&gt;();
IQueryable&lt;int&gt; arg_4D_0 = query;
ParameterExpression parameterExpression = Expression.Parameter(typeof(int), "x");
arg_4D_0.Where(Expression.Lambda&lt;Func&lt;int, bool&gt;&gt;(Expression.GreaterThan(parameterExpression, Expression.Constant(0, typeof(int))), new ParameterExpression[]
{
    parameterExpression
})).ToList&lt;int&gt;().FirstOrDefault((int x) =&gt; x &gt; 10);
</code></pre>

<p>Please note how it generates expressions for everything up to <code>ToList</code>. Everything after and including it are simply normal calls to extension methods.</p>

<p>If you don't mimick this in your code, you will actually send a call to <code>Enumerable.ToList</code> to the LINQ provider - which it then tries to convert to SQL and fail.</p>
