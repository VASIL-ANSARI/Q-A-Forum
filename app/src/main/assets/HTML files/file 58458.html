<p>This is pseudoCode - you will have to move somethings to class scope to allow future send/receives (which you'd do using a different method). This is only designed to show you how to connect when the connection blocks:</p>

<pre><code>bool isClientConnected = false;
var connector = new System.ComponentModel.BackgroundWorker();

public void connectToUDP(){
    connector.DoWork+= connect;
    connector.RunWorkerAsync();
} 

 private void connect(object sender, DoWorkEventArgs e)
{          
    IPAddress server_address = IPAddress.Parse("127.0.0.1");
    IPEndPoint server_ip = new IPEndPoint(server_address, 5685);
    Console.WriteLine("2");

                try
        {
            Console.WriteLine("Waiting for server...");
            udp_client.Connect(server_ip);
            byte[] send_data = Encoding.ASCII.GetBytes("INIT");
            udp_client.Send(send_data, send_data.Length);
            byte[] received_bytes = udp_client.Receive(ref server_ip);
            string received_data = Encoding.ASCII.GetString(received_bytes);
            if (received_data == "INIT")
            {
                isClietConnected = true;
                Console.WriteLine("now connected");
                listen(server_ip);
            }


        catch (Exception e)
        {
            Console.WriteLine(e);
        }

}
public bool sendReceiveUDP(string send){
     if(!isClientConnected){
          return false;
     }
     //perform send
     return true;
 }
</code></pre>

<p>You would then maintain the connected session using class scope and send/receive using a different method. This is for connect only since you only need to do it once.</p>

<p>How you set something like this up:</p>

<pre><code>  private bool isConnected = false();
  private bool send(){
      if(!isConnected){
           connect();
      }
      //send
  }
  private bool connect(){
      if(!isConnected){
          //launch connection thread
      }
   }
  private delegate void onNewReceive(string message);
  public event onNewReceive onNewReceiveEvent;
  public void fireEvent(string message){
         onNewReceiveEvent.Invoke(message);
  }
       private void waitForData(object sender, DoWorkEventArgs e){
     //this is the backgroundworker
     while(true){
     receive();
     fireEvent(message);
     }
  }
</code></pre>

<p>Then, subscribe to the onNewREceivedEvent in another class and process the inbound message. onNewReceivedEvent += processInboundMEsasage();</p>

<p>This is all psuedocode and "brain compiled" (creit to others) so it's only meant for demonstrations. Without intellisense, I'm lost.</p>
