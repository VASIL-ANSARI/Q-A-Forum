<p>According to รยง5.3.1.10 of the C++ standard (<a href="http://eel.is/c++draft/expr.unary.op#10" rel="nofollow">[expr.unary.op]</a>), the <code>~</code> operator takes an integral (or unscoped enumeration type) operand and performs integral promotions where the type of the result of an <code>~</code> operation is the type of its promoted operand. This means that the boolean is first converted to an integral (<code>0</code> for <code>false</code> and <code>1</code> for <code>true</code>). Because of your context, the result of the <code>~</code> operation is then converted back to a boolean: <code>false</code> for <code>0</code> and <code>true</code> for all non-zero values.</p>

<p>If you have a boolean <code>x</code>, you can think of <code>~x</code> as <code>~static_cast&lt;int&gt;(x)</code> and of <code>x = ~x</code> as <code>x = ((~static_cast&lt;int&gt;(x)) != 0)</code>.</p>

<p>Hence:</p>

<pre><code>bool a = false;
bool b = ~a; // b = (~static_cast&lt;int&gt;(a) != 0)
             // b = (~static_cast&lt;int&gt;(false) != 0)
             // b = (~0 != 0)
             // b = (0xffffffff != 0)
             // b = true
bool c = ~b; // c = (~static_cast&lt;int&gt;(b) != 0)
             // c = (~static_cast&lt;int&gt;(true) != 0)
             // c = (~1 != 0)
             // c = (0xfffffffe != 0)
             // c = true
</code></pre>
