<p>When you call <code>patch</code> you are replacing your view with a brand new <code>MagicMock</code>. Since you are manually constructing a mock for you view you should do something more like (untested):</p>

<pre><code>new_view = Mock(__name__='features', return_value={})
features = get_object(new_view)

with patch('myapp.views.features', features):
    client = Client()
    response = client.get('/features')
    print new_view.call_args
</code></pre>

<p>This will replace <code>myapp.views.features</code> with your hand rolled mock.</p>

<p>In general though I would recommend that you test your decorator in isolation without using the Django test client. Your really mixing two tests into one here. The first is making sure the decorator does it's duty and the other is making sure the request is properly routed.</p>
