<p>I'm pretty sure you did't implement <code>GetHashCode()</code> correctly. Whenever you override <code>Equals</code> you must override <code>GetHashCode()</code> so they are consistent.</p>

<p>The condition is that if for two objects <code>o1.Equals(o2)</code> returns true then the results of <code>GetHashCode</code> must be the same.</p>

<p>Since <code>Except</code> uses a hashset internally the implementation of  <code>GetHashCode()</code> is relevant here. Without a hashset it's complexity would grow from O(n) to O(n^2) which is clearly undesirable.</p>

<p>In addition to that <code>Equals</code> should be symmetrical and yours isn't.</p>

<hr>

<p>Looking into your <code>GetHashCode()</code> function it is clearly wrong. It takes fields into account that <code>Equals</code> doesn't.</p>

<p>Whenever your code goes into the <code>then</code> part of the <code>if</code> it may take <code>FirstName</code>, <code>LastName</code> and <code>MiddleName</code> into account. When your code goes into the <code>else</code> part it may only take <code>FirstName</code> into account for <code>GetHashCode()</code>.</p>

<pre><code>public override int GetHashCode()
{
    unchecked
    {
    if (this.Zipcode == "11111" || this.Zipcode == "22222" || this.Zipcode== "33333")
    {
        return FirstName.GetHashCode()*529+
               LastName.GetHashCode()*23+
               MiddleName.GetHashCode();
    }
    else
    {
        return FirstName.GetHashCode();
    }
}
</code></pre>

<p>But even with this implementation of <code>GetHashCode()</code> you'll still should fix the symmetry of your <code>Equals</code></p>
