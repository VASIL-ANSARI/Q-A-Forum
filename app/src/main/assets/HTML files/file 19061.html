<p>The value of <code>this</code> is determined at the time the function is invoked, not the time when it is defined. So in your code, you have to different values of <code>this</code>: When <code>ninja.changeName()</code> is called, you don't specify a value for <code>this</code>, so it's either undefined or whatever it might be right now.</p>

<p>The <code>new</code> operator, on the other hand, does set <code>this</code> before it called the function <code>Ninja</code>.</p>

<p>What you need to do is "save" the value of <code>this</code> inside of <code>Ninja</code> so the inner functions continue to use that (instead of whatever random value might be in <code>this</code> at the time they are called). Doing this is more simple than it sounds:</p>

<pre><code>function Ninja(name){
  this.name = name;

  var self = this; // Create a hidden reference to "this" that is only visible in
                   // any functions defined before we return

  self.changeName = function(newname) {
    self.name = newname;
    self.anotherFunction = function(newname2) {
      self.name2 = newname2;
    }
  }
}
</code></pre>

<p>This works because JavaScript keeps a copy of the context (= all reachable variables) around when you define a function.</p>
