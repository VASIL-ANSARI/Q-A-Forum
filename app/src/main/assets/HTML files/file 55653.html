<p>You can read about <a href="https://ericlippert.com/2010/06/28/computing-a-cartesian-product-with-linq/" rel="nofollow">this</a> post of Eric Lippert about computing a Cartesian product with LINQ.</p>

<p>The idea is visit each list making a cartesian product of that list with the current cartesian product set.</p>

<p>This is the code:</p>

<pre><code>static IEnumerable&lt;IEnumerable&lt;T&gt;&gt; CartesianProduct&lt;T&gt;(IEnumerable&lt;IEnumerable&lt;T&gt;&gt; sequences)
{
    IEnumerable&lt;IEnumerable&lt;T&gt;&gt; emptyProduct = new[] { Enumerable.Empty&lt;T&gt;() };

    return sequences.Aggregate(emptyProduct, (accumulator, sequence) =&gt;
        from accseq in accumulator
        from item in sequence
        select accseq.Concat(new[] { item }));
}
</code></pre>

<p>Usage:</p>

<pre><code>var newList = CartesianProduct(oldList);
</code></pre>
