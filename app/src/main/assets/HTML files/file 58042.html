<blockquote>
  <p>Unless I am mistaken, this is the vanilla JS equivalent of</p>

<pre><code>function(f){
  return f;
}
</code></pre>
</blockquote>

<p>Pretty much, since the function body doesn't use <code>this</code> or <code>arguments</code>; a couple of notes:</p>

<ol>
<li><p>The arrow function (<code>f =&gt; f</code>) closes over <code>this</code> and <code>arguments</code> (instead of having its own meanings for them), which a <code>function</code> expression won't, but given the contents of the function it doesn't matter, as it doesn't use them.</p></li>
<li><p>Arrow functions <em>are</em> vanilla JavaScript (as of ES2015).</p></li>
</ol>

<blockquote>
  <p>In which case, where is the f argument coming from??</p>
</blockquote>

<p>The same place it comes from with any callback you pass into a function: Whatever calls it. This callback is being passed into <code>compose</code>, so to know how it's going to be called and with what argument(s), you look at the <a href="http://redux.js.org/docs/api/compose.html" rel="nofollow"><code>compose</code></a> definition in Redux:</p>

<blockquote>
  <p>Each function is expected to accept a single parameter. Its return value will be provided as an argument to the function standing to the left, and so on. The exception is the right-most argument which can accept multiple parameters, as it will provide the signature for the resulting composed function.</p>
</blockquote>

<p>So that function will receive whatever the function returned by <code>applyMiddleware(thunk)</code> returns.</p>

<p>The only reason for the <code>f =&gt; f</code> function is so that the author can use a single line; e.g., they needed something for the false operand to the conditional operator. They could have done this instead:</p>

<pre><code>let temp = applyMiddleware(thunk)(createStore);
if (__CLIENT__ &amp;&amp; window.devToolsExtension) {
   temp = window.devToolsExtension()(temp);
}
const composedStore = temp;
</code></pre>

<p>...but presumably wanted to avoid the temp variable.</p>
