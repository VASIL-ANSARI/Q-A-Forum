<p>When the mouse is moved very quickly, Windows will aggregate mouse moves into a single message so as to not overload any programs with tons of WM_MOUSEMOVEs.  You can get a list of these intermediate points in WPF via <a href="https://msdn.microsoft.com/en-us/library/system.windows.input.mouse.getintermediatepoints(v=vs.110).aspx" rel="nofollow">Mouse.GetIntermediatePoints</a>.</p>

<p>I suspect your problem is that the mouse is moving fast across the screen between the last move and the left button up and you are missing a whole bunch of intermediate points.  </p>

<p>Try this as an experiment, also draw your rectangle in the left button up handler.  I believe that will make the rectangle match the screen shot area.  If you then check the intermediate points, you will likely see a bunch of move data queued up.</p>

<p>To get around this, why not just use the last mouse move as mEndPoint instead of the call to GetPosition in the left button up handler?  That should give you the correct behavior since it will exactly mirror your current method of drawing the rectangle.  Then, regardless of intermediate moves, you will be capturing the rectangle coordinates itself, not the new rectangle formed by the left button up position.</p>
