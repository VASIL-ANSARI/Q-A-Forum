<p>If your list is not very large, the thing to do would be to pass it to a bundle in <code>onSaveInstanceState</code> and retrieve it in <code>onRestoreInstanceState</code>. These methods should still be called on destruction/recreation even though the fragment is not in the foreground. However, if the data is very large or is not serializable or parcelable, this is not an option.</p>

<p>From the <a href="http://developer.android.com/guide/topics/resources/runtime-changes.html" rel="nofollow">docs:</a></p>

<blockquote>
  <p>If restarting your activity requires that you recover large sets of data, re-establish a network connection, or perform other intensive operations, then a full restart due to a configuration change might be a slow user experience. [...] In such a situation, you can alleviate the burden of reinitializing your activity by retaining a Fragment when your activity is restarted due to a configuration change. This fragment can contain references to stateful objects that you want to retain.</p>
</blockquote>

<p>It sounds like in this case you would want to retain the fragment that holds your <code>List&lt;Obj&gt;</code>. The problem is that this requires your activity to check all of the retained fragments it could create in <code>onCreate</code> to see if any of them already exist, and you've expressed concerns about maintainability in this instance.</p>

<p>In the last resort, you could declare your intention to handle orientation changes yourself by using the <code>android:configChanges</code> parameter in your android manifest. This will prevent your activity (and its associated fragments and their members) from being destroyed and recreated in the orientation change, and instead the system will call <code>onConfigurationChanged</code> in your activity. If you do not override <code>onConfigurationChanged</code>, nothing will happen on orientation change except that the screen will rotate. Google discourages this, among other reasons, because it's a code smell. Resorting to this means that you are not handling state changes well, and if your activity was destroyed while a user was looking at something else, your state would not be preserved properly.</p>

<h2>Edit:</h2>

<p>If your fragment receives its data through its arguments bundle, as from a call to <code>setArguments()</code>, that bundle "<a href="http://developer.android.com/reference/android/app/Fragment.html#setArguments(android.os.Bundle)" rel="nofollow">will be retained across fragment destroy and creation.</a>"</p>
