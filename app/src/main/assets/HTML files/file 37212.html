<p>You could do it with:</p>

<p>In C\C++: <code>EAX = (EAX &amp; 0xFFFF00FF) | (((EAX &amp; 0x0000FF00) &gt;&gt; 7) &amp; 0x0000FF00)</code></p>

<p>In more expanded C\C++ code would be:</p>

<pre><code>unsigned long shift_count = 7;
unsigned long mask = 0x0000FF00;
EAX = (EAX &amp; (~mask)) | (((EAX &amp; mask) &gt;&gt; shift_count) &amp; mask)
</code></pre>

<p>Change <code>mask</code> and <code>shift_count</code> to match your needs.</p>

<p>Where <code>EAX</code> is the variable holding the value, <code>0x0000FF00</code> is the mask of the interesting byte and <code>0xFFFF00FF</code> is the inverse of the previous mask.</p>
