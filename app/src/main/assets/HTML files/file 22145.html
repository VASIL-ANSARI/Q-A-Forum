<p>Use an <code>AtomicInteger</code>.</p>

<p>Atomic means that any operation on it will fully complete before any other thread can see the result. Meaning that you won't have two simultaneous operations 'clobber' it. For example, imagine if you had a non atomic integer and two threads attempted to increment it simultaneously - say it had value 1, they both read it as 1 and attempt to set it to 2. They both incremented it once - but instead of it becoming 3, it became 2! <code>AtomicInteger</code> solves this problem by giving you <code>IncrementAndGet</code>, which guarantees no other thread can access the <code>AtomicInteger</code>'s value before the increment completes.</p>

<p>In particular, use these methods:</p>

<p><a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/atomic/AtomicInteger.html#get()" rel="nofollow">http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/atomic/AtomicInteger.html#get()</a></p>

<p><a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/atomic/AtomicInteger.html#incrementAndGet()" rel="nofollow">http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/atomic/AtomicInteger.html#incrementAndGet()</a></p>

<p>You might notice that this increments it, but it doesn't take it modulo n. Well, you can take it modulo n whenever you read its value, you don't need it to be stored that way.</p>

<p>EDIT: By the way, doing something like this:</p>

<pre><code>while (turn != i);
</code></pre>

<p>is called busy-waiting, and it's a bad idea because it means that CPU usage will be 100%, checking the variable hundreds of thousands of times per second. In this kind of scenario, instead of making each thread check as often as possible, you want to have threads <code>wait</code>  and be <code>notify</code>ed by another thread when it is that thread's turn to continue execution.</p>

<p>I believe in Java that using <code>lock</code> and <code>synchronized</code> to implement mutual exclusion will also give you this property, e.g. if you try to lock on something or enter a synchronized block but it is already in use then the thread goes to sleep and is woken up when it is its turn. So, you can look into this as well.</p>
