<p>Ruby includes a few type coercion methods that you might find useful.</p>

<p>The first is <code>Array()</code>, which will convert its argument into an array, unless the argument is already one, it which case it simply returns the argument:</p>

<pre><code>Array(1) #=&gt; [1]
Array([1,2,3]) #=&gt; [1,2,3]
</code></pre>

<p>Somewhat annoyingly, when fed a single hash, it converts the hash into an array of arrays (the key-value pairs in the hash):</p>

<pre><code>Array({ a: 1, b: 2}) #=&gt; [[:a, 1], [:b, 2]]
</code></pre>

<p>However, there is also a <code>Hash[]</code> method that will convert that result back into a hash, but leave existing hashes alone:</p>

<pre><code>Hash[ [[:a, 1], [:b, 2]] ] #=&gt; { a: 1, b: 2 }
</code></pre>

<p>Since your 'day' key is sometimes an array of hashes and sometimes a single hash, you can use these in your method to ensure your iterations and lookups work as expected:</p>

<pre><code>Array(datapoint["day"]).each do |datapoint2|
  dp2_hash = Hash[datapoint2]
  # ... etc, substituting future mentions of datapoint2 with dp2_hash
</code></pre>
