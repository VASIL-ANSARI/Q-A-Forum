<p>I am not familiar with Knuth's Dancing Links algorithm, but found <a href="https://www.ocf.berkeley.edu/~jchu/publicportal/sudoku/sudoku.paper.html" rel="nofollow">this article</a> which made it quiet clear. In particular I found this very helpful: </p>

<blockquote>
  <p>Knuth takes advantage of a basic principle of doubly-linked lists.
  When removing an object from a list, only two operations are needed:</p>
  
  <p>x.getRight().setLeft( x.getLeft() )<br>
  x.getLeft().setRight(> x.getRight() ) </p>
  
  <p>However, when putting the object back in the list, all
  is needed is to do the reverse of the operation.</p>
  
  <p>x.getRight().setLeft( x )<br>
  x.getLeft().setRight( x ) </p>
  
  <p>All that is
  needed to put the object back is the object itself, because the object
  still points to elements within the list. Unless xâs pointers are
  changed, this operation is very simple.</p>
</blockquote>

<p><br>
To implement it I added setters for linking / unlinking. See comments: 
<br></p>

<pre><code>import java.util.HashSet;

public class DoublyLinkedList&lt;T&gt; {

      public Node&lt;T&gt; first = null;
      public Node&lt;T&gt; last = null;

      static class Node&lt;T&gt; {
        private T data;
        private Node&lt;T&gt; next;
        private Node&lt;T&gt; prev;

        public Node(T data) {
          this.data = data;
        }

        public Node&lt;T&gt; get() {
          return this;
        }

        public Node&lt;T&gt; set(Node&lt;T&gt; node) {
          return node;
        }

        public Node&lt;T&gt; next() {
          return next;
        }

        //add a setter
        public  void setNext(Node&lt;T&gt; node) {
              next = node;
        }
        public Node&lt;T&gt; previous() {
          return prev;
        }

        //add a setter
        public  void setPrevious(Node&lt;T&gt; node) {
              prev = node;
        }

        public void displayNode() {
          System.out.print(data + " ");
        }

        @Override
        public String toString() {
          return data.toString();
        }
      }

      public void addFirst(T data) {
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(data);

        if (isEmpty()) {
          newNode.next = null;
          newNode.prev = null;
          first = newNode;
          last = newNode;

        } else {
          first.prev = newNode;
          newNode.next = first;
          newNode.prev = null;
          first = newNode;
        }
      }

      public Node&lt;T&gt; getAt(int index) {
        Node&lt;T&gt; current = first;
        int i = 1;
        while (i &lt; index) {
          current = current.next;
          i++;
        }
        return current;
      }

      public boolean isEmpty() {
        return (first == null);
      }

      public void displayList() {
        Node&lt;T&gt; current = first;
        while (current != null) {
          current.displayNode();
          current = current.next;
        }
        System.out.println();
      }

      public void removeFirst() {
        if (!isEmpty()) {
          Node&lt;T&gt; temp = first;

          if (first.next == null) {
            first = null;
            last = null;
          } else {
            first = first.next;
            first.prev = null;
          }
          System.out.println(temp.toString() + " is popped from the list");
        }
      }

      public void removeLast() {
        Node&lt;T&gt; temp = last;

        if (!isEmpty()) {

          if (first.next == null) {
            first = null;
            last = null;
          } else {
            last = last.prev;
            last.next = null;
          }
        }
        System.out.println(temp.toString() + " is popped from the list");
      }

      public static void main(String[] args) {

          ///////////////

          DoublyLinkedList newList = new DoublyLinkedList();

          for (int i = 0; i &lt; 81; i++) {

              HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();
              set.add(i);
              newList.addFirst(set);
          }

          newList.displayList();

          // start at 69
          Node node = newList.getAt(12);
          node.displayNode(); System.out.println();

          //HOW TO IMPLEMENT UNLINK?
          node.previous().setNext(node.next);
          node.next().setPrevious(node.previous());

          //The 2 statements above are equivalent to
          //Node p = node.previous();
          //Node n = node.next();
          //p.setNext(n);
          //n.setPrevious(p);

          newList.displayList();

          //HOW TO IMPLEMENT REVERT UNLINK?
          node.previous().setNext(node);
          node.next().setPrevious(node);

          newList.displayList(); System.out.println();

          ///////////////
      }
    }
</code></pre>
