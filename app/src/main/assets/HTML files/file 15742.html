<p><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply" rel="nofollow"><code>apply</code></a> is a <em>member function</em> of a function object.  Suppose we have:</p>

<pre><code>function saySomething(thing, anotherThing) {
    alert(this + " says " + thing + " and " + anotherThing);
}
</code></pre>

<p>Then we can use:</p>

<pre><code>saySomething.apply(document, ["hello", "goodbye"]);
</code></pre>

<p>This calls the function and supplies the values of the array as arguments to the function.  The first argument species the <em>context</em> of the function (or, what <code>this</code> equals when the function runs).</p>

<p>You should also be aware that <code>arguments</code> is a special variable that holds an array of all arguments passed to the function.  So, here, <code>this.init.apply(this, arguments)</code> means that the <code>init</code> function is called and passed all the of arguments that were passed to the <code>klass</code> constructor.</p>

<p>In a real implementation, I think <code>init</code> would expect arguments.  Consider how this would be done without <code>apply</code>:</p>

<pre><code>var klass = function(arg1, arg2, arg3) {
    init(arg1, arg2, arg3);
}

klass.prototype.init = function(arg1, arg2, arg3) {}
</code></pre>

<p>If you wanted to add <code>arg4</code> to init, you'd have add it in three places!  By having <code>klass</code> transparently pass all its arguments to <code>init</code>, you make you code much less brittle.</p>
