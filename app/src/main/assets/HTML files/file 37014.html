<p>It's a very common mistake, promises are a bit difficult to get a grasp at the beginning.</p>

<p>I'm gonna try to explain line by line, the order below is the same order that will happen running your code.</p>

<p>1) $scope.newPost.content = "Part 2 of phrase"</p>

<p>With this, you've assigned a string to your newPost.content variable, so far, so good</p>

<p>2) $scope.newPost.content = Phrase.get({bla bla bla ...});</p>

<p>Now this is replacing the previous string by an promise object, it's no longer a string.
Such thing is possible due to javascript crazy-flexible non-strongly typed way, lol. This will not wait for the get on the server to finish, and that's what's messing with you, the next line will run immediately after this, and will have the wrong value.</p>

<p>3) console.log($scope.newPost.content)</p>

<p>This is where things get messy, right now, your newPost.content is not a string, it is the promise from 2, and the output on the console proves that. (that output is a promise object).</p>

<p>Your newPost.content will only have your concatenated string when the promise at 2 resolves, it can take a long or short time to do it, the important thing to notice is that it is not blocking the rest of the code, so the 3 will execute immediately after the 2...
Think at the promise as something that is running in another thread.</p>

<p>So, my original answer remains, your variable will only have the desired value after the promise resolves, so you must take action after that, normally inside the then function, I made a few changes to illustrate that and avoid useless assingments:</p>

<pre><code>var part2 = "Part 2 of phrase"
Phrase.get({id: $scope.newPost.phrase_id}).$promise.then(
  function(result){
      $scope.newPost.content = result.content + ' ' + part2;
      console.log($scope.newPost.content);
  }
);
</code></pre>

<p>Hope that helps.</p>
