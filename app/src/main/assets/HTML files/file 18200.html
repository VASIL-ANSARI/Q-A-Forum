<p>I would probably say: not this way.</p>

<p>Macros are not represented in the AST per se. Types, Attributes, etc... all those elements that have <em>semantic</em> values are represented (and comments), and optionally you can query whether some of them were expanded from a macro and get back that original macro spelling; however macros in themselves do not appear in the AST, at all.</p>

<p>If you could, it might be more interesting to <em>extend</em> Clang with a new <strong>attribute</strong>, especially in C++11: <code>[[gearoid::persist]]</code>. C++11 requires that compilers ignore attributes they know not about, so by "namespacing" your own attributes you pretty much guarantee that only you will care about their meaning.</p>

<p>I know not, unfortunately, whether you will need to teach Clang about your attributes so they are represented in the AST (<a href="http://lists.cs.uiuc.edu/pipermail/cfe-dev/2012-October/024637.html" rel="nofollow">Michael Han</a> is working on always memorizing them). In any case, you may get more useful answers on the <a href="http://lists.cs.uiuc.edu/mailman/listinfo/cfe-dev" rel="nofollow">Clang DEV</a> mailing list (unfortunately, there is no Clang Users mailing list).</p>

<p><strong>EDIT</strong>: Just <a href="http://llvm.org/viewvc/llvm-project?view=rev&amp;revision=165082" rel="nofollow">landed today</a>! Clang will now retain all attributes (even those it does not understand) in its AST.</p>
