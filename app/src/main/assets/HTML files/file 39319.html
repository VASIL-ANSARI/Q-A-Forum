<p>This</p>

<pre><code>18
</code></pre>

<p>is known as an <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.1" rel="nofollow">integer literal</a>. There are all sorts of <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10" rel="nofollow">literals</a>, floating point, <code>String</code>, character, etc.</p>

<p>In the following,</p>

<pre><code>byte b = 3;
</code></pre>

<p>the literal <code>3</code> is an integer literal. It's also a constant expression. And since Java can tell that <code>3</code> fits in a <code>byte</code>, it can safely apply a <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3" rel="nofollow">narrowing primitive conversion</a> and store the result in a <code>byte</code> variable. </p>

<p>In this</p>

<pre><code>int i = 3;
byte bb = i; //error!
</code></pre>

<p>the literal <code>3</code> is a constant expression, but the variable <code>i</code> is not. The compiler simply decides that since <code>i</code> is not a constant expression, and therefore doesn't go out of its way to figure out its value, a conversion to <code>byte</code> may lose information (how to convert <code>12345</code> to a <code>byte</code>?) and should therefore not be allowed. You can override this behavior by making <code>i</code> a constant variable</p>

<pre><code>final int i = 3;
byte bb = i; // no error!
</code></pre>

<p>or by specifying an explicit cast</p>

<pre><code>int i = 3;
byte bb = (byte) i; // no error!
</code></pre>
