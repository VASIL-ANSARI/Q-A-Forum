<blockquote>
  <p><code>subClass.superclass = superClass.prototype;</code>
  Why not point to the constructor function, but point to the prototype?</p>
</blockquote>

<p>Both could be done, and it's just a design issue. I guess that <code>superClass</code> property is mostly needed in overwritten methods that want to call their super method, and they can do so by calling <code>this.constructor.superClass[methodName]</code>. But yes, it is a bit weird that you need the <code>constructor</code> property for this, a direct property on the prototype would have been easier again.</p>

<blockquote>
  <p>The more important questions is, why do the last lines try to set the Object's prototype's constructor back to self?</p>
</blockquote>

<p>It seems that is done for compatibility with poor prototype declarations. If someone uses</p>

<pre><code>MyClass.prototype = {â¦};
</code></pre>

<p>and does not reset the <code>constructor</code>, then in <code>extend(MySubClass, MyClass)</code> the <code>superClass.prototype.constructor</code> will be <code>Object</code>, and the common applying of the superclass constructor</p>

<pre><code>this.constructor.superClass.constructor.apply(this, args);
// for those who don't want to use MyClass.apply
</code></pre>

<p>in the <code>MySubClass</code> constructor would fail. So the <code>extend</code> function corrects this.</p>

<blockquote>
  <p>Also a little strange is that, why does it use <code>if(superClass.prototype.constructor == Object.prototype.constructor)</code>? Why not just use <code>if (superClass === Object)</code> instead?</p>
</blockquote>

<p>It should be clear now why we want <code>superClass.prototype.constructor</code>. But yes, we could have used <code>Object</code> instead of <code>Object.prototype.constructor</code>.</p>
