<p>The code at the top level of the <code>Inventory</code> definition (i.e. class attributes and method definitions) runs <em>before</em> the name <code>Inventory</code> exists, so you can't call its own methods within the definition. As you have a <code>@staticmethod</code>, which doesn't require any class or instance argument, why not move it outside?</p>

<pre><code>def calculate_total_stock(product_names, product_stock):
    total_stock = dict((item, 0) for item in product_names)
    for nation in product_stock:
        for item in nation:
           total_stock[item] += nation[item]
    return total_stock


class Inventory(object):

    SHIPPING_COST = 400.0   
    TOTAL_STOCK = calculate_total_stock(product_names, product_stock)

    def __init__(self, attributes=None):
        self.inventory = {}
        if attributes is not None:
            for key in attributes:
                self.inventory[key] = attributes[key]  

    def get_value(self, attribute):
        return self.inventory[attribute]  

    def set_value(self, attribute, value):
        self.inventory[attribute] = value 
</code></pre>

<p>Note that I have done some tidying up, particularly in terms of <a href="http://legacy.python.org/dev/peps/pep-0008/" rel="nofollow">style</a> and making the explicit arguments to <code>calculate_total_stock</code>.</p>
