<p>Given that you know the <code>probe</code> part ends with <code>}</code> and the IP part end with a <code>&amp;</code>, it's probably easiest to just scan for those:</p>

<pre><code>sscanf(input, "Ip=%[^&amp;]&amp;probe=%[^}]", ipt, probe);
</code></pre>

<p>One minor detail: <code>scanf</code> with either a scanset or a %s conversion <em>needs</em> to have the buffer size specified to have any safety at all. without a length, both are pretty much equivalent to <code>gets</code> for lack of safety, so you really want something like:</p>

<pre><code>char ipt[256], probe[256];
sscanf(input, "Ip=%255[^&amp;]&amp;probe=%255[^}]", ipt, probe);
</code></pre>

<p>Also note that this will give you the <code>probe</code> part <em>without</em> the trailing <code>}</code>. If you really need it, you can use something like <code>strncat</code> to add it back on afterwards though.</p>

<p>For those looking on: no, scanf (and company) don't support full regular expressions, but they do support scansets, which is what he's using here.</p>
