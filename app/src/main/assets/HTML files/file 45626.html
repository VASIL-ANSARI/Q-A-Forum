<p>You have not declared the variable <code>evectors</code> other than within the scope of your function <code>evecs</code>.</p>

<pre><code>evectors = evecs(matrixTranspose)

if any(x&lt;0 for x in evectors) == False:
    print(evectors)
</code></pre>

<p><strong>EDIT</strong></p>

<p>There are several issues: </p>

<ol>
<li><p>Indentation is VERY important in Python. <code>MarkovChain</code> and  <code>evecs</code> are two seperate functions. You had your <code>evacs</code> function indented an extra level in, embeddeding it within <code>MarkovChain</code>. </p></li>
<li><p><code>MarkovChain</code> should return <code>matrixTransponse</code> if you plan to use it in another function call. </p></li>
<li><p>As a result of the above issue, your function call to <code>MarkovChain</code> needs to be assigned to a variable, <code>matrixTranponse</code>, otherwise you will get an error stating that <code>matrixTranspose</code> is not defined when you make your function call to <code>evecs</code> with it.</p></li>
<li><p>Since the initialization of the variable <code>matrixTranspose</code> isn't set until the function call to <code>MarkovChain</code> is completed, the remainder of your logic will need to be re-ordered.</p></li>
</ol>

<p>I have applied all the above changes below and added comments to the changed areas:</p>

<pre><code>def MarkovChain(n,s) :
    """

    """
    matrix = []
    for l in range(n) :
        lineLst = []
        sum = 0
        crtPrec = precision
        for i in range(n-1) :
            val = random.randrange(crtPrec)
            sum += val
            lineLst.append(float(val)/precision)
            crtPrec -= val
        lineLst.append(float(precision - sum)/precision)
        matrix2 = matrix.append(lineLst)
    print("The intial probability matrix.")    
    print(tabulate(matrix))
    matrix_n = numpy.linalg.matrix_power(matrix, s)  
    print("The final probability matrix.")
    print(tabulate(matrix_n))
    matrixTranspose = zip(*matrix_n)

    return matrixTransponse    # issue 2

# issue 1
def evecs(matrixTranspose):
    evectors = numpy.linalg.eig(matrixTranspose)[1][:,0]
    return evectors

matrixTranponse = MarkovChain(4, 10000000000)     # issue 3

# issue 4
evectors = evecs(matrixTranspose)

if any(x&lt;0 for x in evectors) == False:
    print(evectors)
</code></pre>
