<p>Please see the example:</p>

<pre><code>WITH t1 AS (
SELECT 1 AS ID UNION SELECT 2
), t2 AS (
SELECT 1 AS ID, CONVERT(XML, '
    &lt;Configuration&gt;
        &lt;Email AddressList="blah@blah.com" Subject="blah blah blah"&gt;       
        &lt;/Email&gt;
    &lt;/Configuration&gt;
    ') As Configuration
)
SELECT (
    SELECT t1.ID,
        t2.Configuration,
        CASE WHEN 1 = 1 THEN t2.Configuration END,
        (SELECT nc.Configuration)
    FROM t1
    INNER JOIN t2 On t1.ID = t2.ID
    FOR XML RAW ('NotificationItem'),TYPE
) FOR XML RAW ('NotificationItems'),TYPE
</code></pre>

<p>Your <code>Configuration</code> field is already XML with <code>&lt;Configuration /&gt;</code> root tag. When selected it is being wrapped in an extra <code>&lt;Configuration /&gt;</code> tag following the field name.</p>

<p>You already have the solution through <code>(SELECT nc.Configuration)</code> which results in "anonymous" field that is included into result XML "as is", without field name wrapping tag. And this "nested query" does not actually cost anything.</p>

<p><strong>Update</strong>: Of cause <code>Configuration</code> XML can be explicitly "unwrapped" before <code>JOIN</code>, but that would be much less efficient:</p>

<pre><code>WITH t1 AS (
SELECT 1 AS ID UNION SELECT 2
), t2 AS (
SELECT 1 AS ID, CONVERT(XML, '
    &lt;Configuration&gt;
        &lt;Email AddressList="blah@blah.com" Subject="blah blah blah"&gt;       
        &lt;/Email&gt;
    &lt;/Configuration&gt;
    ') As Configuration
)
SELECT (
    SELECT t1.ID,
        t2sub.Configuration
    FROM t1
    INNER JOIN (
        SELECT ID, sub.ConfigurationContents.query('.') AS Configuration
        FROM t2
        CROSS APPLY Configuration.nodes('/Configuration/child::node()') AS sub(ConfigurationContents) 
    ) t2sub ON t2sub.id = t1.id
    FOR XML RAW ('NotificationItem'),TYPE
) FOR XML RAW ('NotificationItems'),TYPE
</code></pre>
