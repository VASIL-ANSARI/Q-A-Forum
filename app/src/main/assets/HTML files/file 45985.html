<p>The error comes from attempting to covert the entire 24-digit hex value to a number first because it won't fit in the range of integers JavaScript can represent distinctly<sup>2</sup>. In doing such a conversion to a JavaScript number some accuracy is lost.</p>

<p>However, it can be processed as multiple (eg. two) parts: do the math on the right part and then the left part, if needed due to overflow<sup>1</sup>. (It could also be processed one digit at a time with the entire addition done manually.)</p>

<p>Each chunk can be 12 hex digits in size, which makes it an easy split-in-half.</p>

<hr>

<p><sup>1</sup> That is, if the final num for the right part is larger than 0xffffffffffff, simply carry over (adding) one to the left part. If there is no overflow then the left part remains untouched.</p>

<p><sup>2</sup> See <a href="http://stackoverflow.com/questions/307179/what-is-javascripts-highest-integer-value-that-a-number-can-go-to-without-losin">What is JavaScript&#39;s highest integer value that a Number can go to without losing precision?</a> </p>

<p>The range is 2^53, but the incoming value is 16^24 ~ (2^4)^24 ~ 2^(4*24) ~ 2^96; still a valid number, but outside the range of integers that can be distinctly represented.</p>

<hr>

<p>Also,  use <code>parseInt(str, 16)</code> instead of using <code>"0x" + str</code> in a numeric context to force the conversion, as it makes the intent arguably more clear.</p>
