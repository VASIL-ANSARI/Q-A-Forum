<p><code>sub</code> is a String. <code>rev</code> is a StringBuffer. They can't be equal, since they don't even have the same type.</p>

<p>Additional notes:</p>

<ul>
<li>don't use StringBuffer. Use StringBuilder. StringBuffer is needlessly synchronized, and should not be used anymore (just like Vector shouldn't be used and ArrayList should be instead).</li>
<li><code>for (i in 0..input.length - 1)</code> can be written <code>for (i in 0 until input.length)</code> which is more elegant</li>
<li><code>input.substring(i, i + j)</code> can't be right: at the end of the two loops, i would be length - 1, and j would be length - 1, and you would thus take a substring between length - 1 and 2 * length - 2.</li>
<li>to store unique results, use a HashSet, not an ArrayList. Calling contains() on a HashSet is O(1), whereas it's O(n) on an ArrayList.</li>
<li>in Kotlin, unlike in Java, you can use <code>a == b</code> to test if a is equal to b, even if a and b are references. </li>
</ul>
