<p>For example when you want to add the edge <code>(3,5)</code> you push 3 into an empty vector ( <code>temp</code> ) and then you <code>push_back</code> temp into <code>v</code>. So now size of <code>v</code> is 1. Then you try to <code>push_back</code> 5 to <code>v[3]</code>:</p>

<pre><code>v[a].push_back(b);
</code></pre>

<p><code>v[3]</code> doesn't exist because your <code>v</code> only has 1 item. Hence the <em>segmentation fault</em>.</p>

<p><em>What should I do?</em><br>
Because you know the number of the nodes beforehand (<code>n</code>) you can initialize your <code>v</code> with the number of nodes ( <code>n+1</code> if you want to use 1-indexing). So <code>v</code> will have <code>n</code> empty <code>vector</code>s. Then you can safely <code>push_back</code> items into <code>v[a]</code>. Also because your graph is undirected for every edge <em>(a,b)</em> you should do both <code>v[a].push_back(b)</code> and <code>v[b].push_back(a)</code>.</p>

<p>Here is a working example:</p>

<pre><code>int n,m;
cin&gt;&gt;n&gt;&gt;m;
vector&lt; vector&lt;int&gt; &gt; v(n+1); // initialize v with (n+1) empty vectors 
                              // because we want to use 1-indexing
int a,b;
while(m--)
{
    cin&gt;&gt;a&gt;&gt;b;
    v[a].push_back(b);
    v[b].push_back(a);
}
</code></pre>
