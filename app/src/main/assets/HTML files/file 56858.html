<p>You're releasing the semaphore too early. Release it in the <code>ContinueWith</code> handler at the end.</p>

<p>Are you aware that <code>Foo()</code> will return immediately regardless of then the synchronized code actually runs?</p>

<p>The <code>if (Dispatcher.FromThread(Thread.CurrentThread) != null)</code> also is highly suspicious. You should <em>know</em> whether you need to marshal or not.</p>

<p>Since continuations can be inlined it is hard to predict on what thread it actually runs. This is quite nasty non-determinism in the TPL. You probably should specify the UI task scheduler for that continuation. That way you never need to marshal.</p>

<p>Also note, that you can use await on .NET 4.0 so maybe this question is moot.</p>
