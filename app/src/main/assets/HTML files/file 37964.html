<p>You can uses Clases/Enums for the different types of insects.</p>

<pre><code>Enum Spiders {BLACKWIDOW, WOLFSPIDER};

Spider firstSpider = Spiders.BLACKWIDOW;
if (firstSpider == Spiders.BLACKWIDOW) ...
</code></pre>

<p>vs.</p>

<pre><code>class BlackWidow extends Spider {... }
class WolfSpider extends Spider { ... }
Spider firstSpider = new BlackWidow();
if (firstSpider instanceof BlackWidow) ....
</code></pre>

<p>In that case you would test with instanceof or .class (for the Class case) or == for the Enum case. In your case when you have one class Spider you should give it a property with its name:</p>

<pre><code>Spider blackWidow = new Spider("BlackWidow");
if (blackWidow.isType("BlackWidow)) ...
</code></pre>

<p>There would be a possibility to check for known instances with the == operator. But this is bad practice for actual domain classifications and hard to debug (and does not work with persisted identities): </p>

<pre><code>public class Spiders {
  final Spider BLACKWIDOW = new Spider();
  final Spider WOLFSPIDER = new Spider();

  void doSpiderThing(Spider userSelection) {
    if (userSelection == BLACKWIDOW) {
    ...

  void selectSpiderByName(String spiderName) {
    if ("Tekla".equals(spiderName))
        doSpiderThing(BLACKWIDOW);
    ...
</code></pre>

<p>Or similiar. You asked in comments how you can return spider or work, you would do that by returning a super-type of both (by default Object, but better something specific):</p>

<pre><code>interface Animal {String getSpecies(); }
Enum AnimalEnum implements Animal {
  BLACKWIDOW { getSpecies() {return "Spider"; }},
  WOLFSPIDER { getSpecies() {return "Spider"; }},
  WORM { getSpecies() {return "Worm"; }}
} 

Animal getAnimalBySelection(String input) {
 if ("worm".equalsIgnoreCase(input))
   return AnimalEnum.WORM;
  else ...
}
</code></pre>
