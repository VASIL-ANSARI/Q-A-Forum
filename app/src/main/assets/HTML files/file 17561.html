<p>Here's the easiest "solution":</p>

<pre><code> uint32_t data = 0x00999900;

 unsigned char const * a = (unsigned char const *)&amp;data;
</code></pre>

<p>Now you have <code>a[0]</code>, ..., <code>a[3]</code>. The order depends on the endianness of your system.</p>

<hr>

<p>The endianness-independent solution works algebraically:</p>

<pre><code>uint32_t data = 0x3A97;

unsigned char b[sizeof data] = {  data &gt;&gt; 24  &amp; 0xFF,       // b[0]
                                 (data &gt;&gt; 16) &amp; 0xFF,       // b[1]
                                 (data &gt;&gt;  8) &amp; 0xFF,       // b[2]
                                  data        &amp; 0xFF        // b[3]
                               };
</code></pre>

<hr>

<p>You can also reconstitute a value from your array. Here's the endianness-dependent way:</p>

<pre><code>uint32_t data;
unsigned char * p = (unsigned char *)&amp;data;
p[0] = 0x00;
p[0] = 0x99;
p[0] = 0x99;
p[0] = 0x00;

// now "data" is 0x00999900
</code></pre>

<p>And here's the algebraic way:</p>

<pre><code>uint32_t data = a[0] * 256 * 256 * 256 + a[1] * 256 * 256 + a[2] * 256 + a[3];
</code></pre>
