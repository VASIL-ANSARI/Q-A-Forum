<p>The compiler can normally use whatever load instructions it wants so long as it works, from perspective of the program itself, as if the 32-bit load implied by <code>array[offset]</code> was performed. Since the value loaded ends up being truncated to 8 bits when stored in <code>arr_type</code>, it doesn't change the value stored in <code>arr_type</code> if the compiler uses an 8-bit load instead.</p>

<p>To tell the compiler that size of the memory access is important and has visible effects outside of the program itself, you should use the <code>volatile</code> qualifier.</p>

<pre><code>type_t    arr_type;
uint32_t volatile *array = BUF_ADDR;
uint32_t  offset = 0;

arr_type = (type_t) array[offset]; 
</code></pre>

<p>More generally you should use the <code>volatile</code> qualifier when performing any sort of memory mapped I/O. It not only ensures that accesses are always performed using the intended size (where possible), it also guarantees that that accesses aren't removed or reordered.</p>
