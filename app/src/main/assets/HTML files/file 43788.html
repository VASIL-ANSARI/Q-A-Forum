<p>The common work-around for solving this without <code>eval()</code> is to put the functions as properties on an object and then use object/property nomenclature to execute the desired function.</p>

<pre><code>var pieceOperations = {
    queen: function() {...},
    rook: function() {...}
};

var piece = "rook";
pieceOperations[piece]();    // executes pieceOperations.rook()
</code></pre>

<p>Javascript does not offer a way to solve your original issue of executing local functions via a string in a variable without using <code>eval()</code> because it does not expose the local scope object that you can reference a property of (though that object exists internally, it is kept internal).  So, if you want to access by name, just put the resource as a property on an object rather than as a local variable and you can then access it via the <code>obj[prop]</code> syntax.</p>

<hr>

<p>As for using <code>eval()</code>, if you are 100% sure you know the source of the <code>piece</code> variable and thus you know that you can never get some unanticipated code there, then it is safe to use <code>eval()</code>.  The safety of using <code>eval()</code> depends entirely upon the source of the string that you're passing to <code>eval()</code>.  That said, I prefer to just avoid <code>eval()</code> entirely and thus I don't have to wonder about the safety issue or a performance issue (<code>eval()</code> can be much slower).  I've always found another way to write the code that does not require <code>eval()</code> such as the above work-around.</p>
