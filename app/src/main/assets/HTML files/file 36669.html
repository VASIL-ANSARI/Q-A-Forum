<p>This is a classic case of so-called "<a href="http://en.wikipedia.org/wiki/Object-relational_impedance_mismatch" rel="nofollow">Object-relational impedance mismatch</a>". Specifically, you are taking about mapping OO's inheritance into a relational database structure. There are several common ways of doing that -</p>

<ul>
<li>A table per subclass,</li>
<li>A table per leaf subclass, and</li>
<li>A table per class hierarchy (with a discriminator)</li>
</ul>

<p>Each of these strategies is perfectly valid. Moreover, the structures could be mixed as needed.</p>

<p>It looks like Stack Exchange used a table per class hierarchy approach, with <code>PostTypeId</code> serving as a <em>discriminator</em>. This approach is as valid as any other approach that they could have taken. It is also one of the simplest ones to take from the maintenance standpoint, because it lets you construct manual queries with less work.</p>

<p>There is another thing in the structure of the table that you did not mention: it is not normalized. Specifically, there are <code>AnswerCount</code> and <code>CommentCount</code> fields that store information that could be obtained by aggregating the table (i.e. running a <code>SELECT COUNT(*) FROM ... WHERE ... AND other.ParentId = p.Id ...</code>) This is a common tradeoff between normalization and speed of execution: most likely, the profiling has indicated that the aggregation takes significant amount of time, so the counts have been moved into the "parent" record.</p>
