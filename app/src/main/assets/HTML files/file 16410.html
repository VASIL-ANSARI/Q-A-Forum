<p><strong>TL;DR</strong> You should explore for different tools and don't shy away from the "hard cases" that may not seem like traditional "unit tests". The hard cases often <em>are</em> testable.</p>

<p>Testing is definitely a rabbit hole. From the surface, it seems so nice and clean, but as you get in to it, the rabbit hole goes quite far down, and this is one example: how do you test these things? You want to be confident that your code is doing the right thing, but you also don't want to create too complicated and unmanageable tests, and you don't want to test too fine-grained either.</p>

<p>However, to your specific questions, I do have some ideas you may wish to look in to.</p>

<p>For testing that a file got generated, you can check to see that initially the file did not exist (ruby has <code>File.exists?</code>) and then you can, after some method, check to see if it does exist. Of course you have questions like, "Does it have the right content?", "Did it finish to completion?", and you <em>can</em> test that stuff too by opening the file and checking it.</p>

<p>For the images, you probably can find facilities that allow you to check the properties of an image (perhaps Paperclip? Never used it but it's a well known gem). So you can do something like this (in sort-of psuedo code, because I don't know of a tool to do this):</p>

<pre><code>it "resizes the image" do
    img = Image.open_image("pic.png")
    img[:size].should eq [100, 100]
    img.close

    resize_image

    image = Image.open_image("pic.png")
    imge[:size].should eq [25, 25]
    img.close
end
</code></pre>

<p>Testing often relies on finding more and more helpful gems/tools to massage situations. "Unit" tests will, yes, only check the unit level code and they <em>may</em> be very simple, but not always. But then you start looking in to library specs, request specs, routing specs, acceptance tests, controller specs, etc. There are lot of tools out there and research is key.</p>

<p>But again, the examples you listed may not be <em>unit</em> tests in the way you think of. If your resizing or file generation is being done off of a Model, then yes it is a unit test, but you're no longer writing that simple code (like accessors and mutators). A lot of the time people new to thorough testing won't think that everything is testable, and it may not be, but if you play around and explore, you can often find a way to do so.</p>
