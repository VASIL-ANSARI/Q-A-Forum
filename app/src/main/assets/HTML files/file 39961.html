<p>You can deal with splitting the two labels by using non-greedy matching.</p>

<p>But there is no way to avoid hardcoding the second label. Even <em>without</em> the spelling variants, you would have to <em>at least</em> specifiy <code>(min|max)</code>, otherwise there would be no reason to separate the second label from the first label (which can have any number of words). So the best you can do is extend that list with whatever other variants you can find in the data (there probably aren't all that many).</p>

<p>Anyway, here's one possible solution that works with the example data you've provided:</p>

<pre><code>&gt;&gt;&gt; regex = re.compile(ur"""
...     ((?:\w+\s+)+?)((?:min|max|mon)\.?)?
...     ([0-9., ]+)(%|[^\W\d_]+/[^\W\d_]+)
...     """, re.X | re.I | re.U)
&gt;&gt;&gt; pprint(regex.findall(s))
[(u'vitamin a ', u'min.', u' 14,053 ', u'iu/kg'),
 (u'vitamin c ', u'', u'13,000', u'iu/kg'),
 (u'vitamin d ', u'max.', u' 10,000', u'\u03bc/kg'),
 (u'copper ', u'', u'1', u'mg/kg'),
 (u'vitamin e ', u'mon', u' 10.00', u'iu/kg')]
</code></pre>
