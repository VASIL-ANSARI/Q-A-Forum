<pre><code>UserPresenter provideUserPresenter(GetUserUseCase getUserUseCase)
</code></pre>

<p>Will tell dagger that you want a <code>GetUserUseCase</code>. </p>

<pre><code>@Inject
public GetEmployeeUseCase()

@Inject
public GetEmployeeUseCase()
</code></pre>

<p><strong>Both</strong> your <code>GetUserUseCase</code> and its child can be provided through constructor injection, but since you requested a <code>GetUserUseCase</code> this is what you get.</p>

<p>If you don't want to use <code>GetUserUseCase</code> don't request it. The easy way would be to fix your provides method to this:</p>

<pre><code>UserPresenter provideUserPresenter(GetEmployeeUseCase getUserUseCase)
</code></pre>

<p>Which is kind of okay, since the logic of <em>what</em> you provide still is in a module and not in your business logic. If you want / have to provide your superclass, remove the <code>@Provides</code> from it and make a provides method like the following to tell dagger about the subclass that you want to use:</p>

<pre><code>@Provides GetUserUseCase provideUserUseCase(GetEmployeeUseCase getUserUseCase) {
    return getUserUseCase;
}
</code></pre>

<p>This will just map your sub class implementation to the parent class. If you don't remove the <code>@Inject</code> annotation on your parent, this will lead to some <em>multiple provides methods...</em> error.</p>
