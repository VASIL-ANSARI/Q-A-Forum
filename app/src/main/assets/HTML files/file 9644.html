<p>Please, don't do that. Never.</p>

<p>Basically, what you do is using a <strong>old-style cast</strong> to cast a <code>a*</code> to a <code>char*</code>. This results <strong>silently</strong> in a <code>reinterpret_cast</code> between two unrelated types, and is <strong>highly implementation dependant</strong>. You cannot rely on the underlying memory layout: it might change for any reason (even when using the same compiler).</p>

<p>If your class contains pointers, you have no guarantee that the data they point to will still be there (or simply the same) when you reload your class.</p>

<p>If you want to provide a <strong>serialization</strong> mechanism, create your own <code>serialize()</code> and <code>deserialize()</code> functions (they can even be templated functions that you can then specialize, or just regular member functions, it doesn't really matter).</p>

<p>Of course, this requires a bit more work, but for the sake of reliability. Moreover, doing so, you can optimize the data representation to fit any storage type (saved to disk, sent to network, ...) and you can even change your class interface and still keep a compatibility with the already serialized instances.</p>
