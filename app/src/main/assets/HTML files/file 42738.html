<p><code>__uuidof()</code> is a proprietary Microsoft extension, that the compiler knows how to deal with. It's evaluated at compile time, not at run time.</p>

<p>The compiler attempts to look up and substitute the UUID for the given interface.  The interface declares its UUID using the <code>__declspec(uuid("..."))</code> extension. If the compiler can't find the UUID, the build will fail. No pointers are actually dereferenced at run time.</p>

<p><code>ppType</code> is set to a <code>IFileOpenDialog**</code>, thus <code>*(ppType)</code> is a <code>IFileOpenDialog*</code> and <code>**(ppType)</code> is a <code>IFileOpenDialog</code>.  As such, <code>__uuidof(**(ppType))</code> is evaluated as <code>__uuidof(IFileOpenDialog)</code> at compile time. </p>

<p>It's the same as doing this:</p>

<pre><code>char* ptr = nullptr;
size_t charSize = sizeof(*ptr);
</code></pre>

<p><code>sizeof(*ptr)</code> will be evaluated as <code>sizeof(char)</code> at compile time, even though <code>ptr</code> is null.</p>
