<p>There is no hard rule that the module names match the package name. Modules usually just use the package name as it's likely a unique namespace. For example you could create a module called <code>example</code> with the package <code>com.example</code>. The <code>module.xml</code> just needs to the in <code>$JBOSS_HOME/modules/example/main</code>. Note that <code>main</code> is the default slot for modules.</p>

<p>In the <code>module.xml</code> you just need to reference the your jar file and any dependencies required. If you want the dependencies to be modules on their own then you need to explicitly declare them in your <code>module.xml</code> file. If you don't care about each dependency having it's own module you can just include them all as resources in your <code>module.xml</code>.</p>

<p>Example module using resource dependencies:</p>

<pre class="lang-xml prettyprint-override"><code>&lt;?xml version="1.0" ?&gt;
&lt;module xmlns="urn:jboss:module:1.1" name="example"&gt;
    &lt;resources&gt;
        &lt;resource-root path="example.jar"/&gt;
        &lt;resource-root path="guava-19.jar"/&gt;
    &lt;/resources&gt;
&lt;/module&gt;
</code></pre>

<p>In the above case the <code>example.jar</code> and <code>guava-19.jar</code> libraries need to be in the <code>$JBOSS_HOME/modules/example/main</code> directory.</p>

<p>Example using module dependencies:</p>

<pre class="lang-xml prettyprint-override"><code>&lt;?xml version="1.0" ?&gt;
&lt;module xmlns="urn:jboss:module:1.1" name="example"&gt;
    &lt;resources&gt;
        &lt;resource-root path="example.jar"/&gt;
    &lt;/resources&gt;

    &lt;dependencies&gt;
        &lt;module name="com.google.guava"/&gt;
    &lt;/dependencies&gt;
&lt;/module&gt;
</code></pre>

<p>In the above case here only the <code>example.jar</code> needs to be in the <code>$JBOSS_HOME/modules/example/main</code> directory.</p>

<p>You can also use the <code>module add</code> CLI command to add modules to WildFly. Again the module name doesn't matter as long as it's unique. For example here's how you'd add a PostgreSQL module with CLI.</p>

<pre><code>module add --name=org.postgresql --resources=~/Downloads/postgresql-9.4-1203.jdbc42.jar --dependencies=javax.api,javax.transaction.api
</code></pre>

<p>Using CLI to add modules avoids having to create the module structure and <code>module.xml</code> file manually. The only catch is that CLI and WildFly have to be on the same file system and the user running CLI needs to have write permissions to <code>$JBOSS_HOME/modules</code>. The command will automatically create the directory structure, copy the resources over and generate the <code>module.xml</code> file.</p>

<p>As far as the <code>MANIFEST.MF</code> entries. JBoss Modules does have an entry key used to define module dependencies named <code>Dependencies:</code>. However I find using the <code>module.xml</code> to be a little nicer so you don't have to rebuild or modified binaries if you need to add a module dependency or remove a module dependency. For deployments however it might make sense to use the <code>MANIFEST.MF</code> entry.</p>

<p>If you haven't seen it yet have a look at the <a href="https://docs.jboss.org/author/display/WFLY10/Class+Loading+in+WildFly" rel="nofollow">class loading in WildFly documentation</a>. This will mostly explain how the class loading for deployments works.</p>
