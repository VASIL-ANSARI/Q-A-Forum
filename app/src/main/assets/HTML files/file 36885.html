<p>Yes, it is. If you call scrollby twice, it will scroll twice. You have a self-calling timeout, which means that it would repeatedly call the function. The timeout is async, and won't be cancelled just because something changed.</p>

<p>Luckily, <code>setTimeout</code> returns an ID that you can pass to <code>clearTimeout()</code>.</p>

<p>So you can do something like this:</p>

<pre><code><b>var currentTimeout;</b>

function buildTable(event) {...

    if ((+tableHeight) > window.innerHeight) {
        <b>window.clearTimeout(currentTimeout);</b>
        pageScroll();
    }

}

function pageScroll() {
    window.scrollBy(0, scrollDirection); // horizontal and vertical scroll increments
    <b>currentTimeout = </b>setTimeout('pageScroll()', 50); // scrolls every 50 milliseconds

    if ((window.scrollY === 0) || (window.innerHeight + window.scrollY) >= document.body.offsetHeight) {
        scrollDirection = -1 * scrollDirection;
    }
}</code></pre>

<p>Here's a simpler example to demonstrate the behavior. <strong><a href="http://jsfiddle.net/jpjyzdb7/" rel="nofollow">jsFiddle example</a></strong>.</p>
