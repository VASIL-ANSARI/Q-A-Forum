<p>I don't know how to <em>easily dynamically</em> add/remove in pure MVVM. I'd want to access InputBindings from code-behind, as you duly noted the lack of a setter.  However, you may be inclined to break the design for this case only by looking into these two: <a href="http://msdn.microsoft.com/en-us/library/system.windows.uielement.inputbindings.aspx" rel="nofollow">InputBindings</a> and <a href="http://msdn.microsoft.com/en-us/library/system.windows.input.keygesture.aspx" rel="nofollow">KeyGesture</a>. So consider creating a custom control for your shell.</p>

<pre><code>    public ObservableCollection&lt;HotkeyModel&gt; Hotkeys { get; private set; }
    public class HotkeyWindow : Window
    {
        HotKeys = new ObservableCollection&lt;HotkeyModel&gt;();
        HotKeys.CollectionChanged += new NotifyCollectionChangedEventHandler(HotkeysChanged);
    }
    void HotkeysChanged(object sender, NotifyCollectionChangedEventArgs e)
    {
        if(e.Action == NotifyCollectionChangedAction.Add)
        {
            foreach(HotkeyModel hk in e.NewItems)
                this.InputBindings.Add(new InputBinding(hk.Command), new KeyGesture(hk.Key, hk.Modifier));
        }
        else if(e. Action == NotifyCollectionChangedAction.Remove)
            ...
    }
</code></pre>

<p>Don't set the InputBindings, instead you'd add and remove.  Keep that ObservableCollection of Hotkeys and listen for the <a href="http://msdn.microsoft.com/en-us/library/ms653375.aspx" rel="nofollow">CollectionChanged</a> Event.  As they are added and removed, you add and remove from the InputBindings.  As you create a KeyGesture, you can set <a href="http://msdn.microsoft.com/en-us/library/system.windows.input.keyboard.modifiers.aspx" rel="nofollow">Keyboard.Modifiers</a>.</p>

<p>So you could take this concept and extrapolate into a true and thorough MVVM design with attached/dependency properties and attached behaviors etc, to stick to the View and ViewModel separation that my above example ignores for now.</p>
