<p>Your method is generic, so the compiler does not know (at compile time) which <em>specific</em> type <code>T</code> will be. Imagine I would call that method like </p>

<pre><code>int noGetDetails = 12;
displayAnimal(ref noGetDetails);
</code></pre>

<p><code>int</code> does not have an <code>GetDetails()</code> implementation.</p>

<p>So there is no way for the compiler to determine what <code>mammal.GetDetails()</code> could be, since there is no type defined for <code>mammal</code>.</p>

<p>You can add <em>generic constraints</em> to enforce <code>T</code> being a type that implements a <code>GetDetails()</code> method:</p>

<pre><code>public class MammalBase
{
    public void GetDetails() { return... }
}

public class YourClass
{
    public static void displayAnimal&lt;T&gt;(ref T mammal) where T : MammalBase // this is the constraint
    {
        mammal.GetDetails();
    }
}
</code></pre>

<p>The constraint <code>where T : MammalBase</code> tells the compiler that only types inherited from <code>MammalBase</code> can be used as generic arguments. So the compiler knows that <code>mammal</code> implements a <code>GetDetails()</code> method.</p>

<hr>

<p><em>Note</em> that there is no use for the <code>ref</code> keyword in your code, and that you actually don't need generics for the code shown since you can simply make your parameter type <code>MammalBase</code> (but maybe you just showed a shortened example and need <code>ref</code> and generics for your real application).</p>
