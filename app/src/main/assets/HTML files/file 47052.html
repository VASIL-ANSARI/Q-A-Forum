<p>Regex cannot take care of context. In your case you're seeking to find context. Regex is not meant for that. You need to write a function that checks this.</p>

<p>Citing from <a href="https://nikic.github.io/2012/06/15/The-true-power-of-regular-expressions.html" rel="nofollow">this link</a>:</p>

<blockquote>
  <p>In the context of formal language theory, something is called
  âregularâ when it has a grammar where all production rules have one of
  the following forms:</p>
  
  <ol>
  <li>B -> a</li>
  <li>B -> aC</li>
  <li>B -> Îµ</li>
  </ol>
  
  <p>You can read those -> rules as âThe left hand side can be replaced
  with the right hand sideâ. So the first rule would be âB can be
  replaced with aâ, the second one âB can be replaced with aCâ and the
  third one âB can be replaced with the empty stringâ (Îµ is the symbol
  for the empty string).</p>
  
  <p>So what are B, C and a? By convention, uppercase characters denote so
  called ânon-terminalsâ - symbols which can be broken down further -
  and lowercase characters denote âterminalsâ - symbols which cannot be
  broken down any further.</p>
</blockquote>

<p>In your case you are looking for something like:</p>

<pre><code>(\([x].*\)[x])*
</code></pre>

<p>I added the <code>[x]</code> to stand for an <code>x</code> number of times (it's not part of the regex convention of course). As you can see by the definition of regex, there's no way to represent such expression in a way that complies with regex definition.</p>

<p>This is not just a "grey" definition issue. Creating a regex-like language to solve problems like the one you noted here is much more complicated (algorithmic and complexity wise). It's a totally different problem domain to try and patternize the type of problems as the one you mentioned here.</p>
