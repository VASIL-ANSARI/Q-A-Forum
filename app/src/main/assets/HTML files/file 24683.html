<p>You can split the winnersList and losersList, each into 2 halves. Thus you would have 4 sublists.</p>

<p>Now you can use <code>FirstOrDefault</code> on each sublist to get an instance of<code>MergeRow</code>. In case one of the sublists become empty before the others, use <code>DefaultIfEmpty</code>, with a placeholder item.</p>

<p>The code would look like:</p>

<pre><code>        var winnersList = new List&lt;Gameresults&gt;();
        var losersList = new List&lt;Gameresults&gt;();

        //Populate the winnersList and losersList


        var winnersList1 = winnersList.Take(winnersList.Count/2).ToList();
        var winnersList2 = winnersList;
        var losersList1 = losersList.Take(losersList.Count/2).ToList();
        var losersList2 = losersList;

         var allLists = new List&lt;List&lt;Gameresults&gt;&gt; {winnersList1, winnersList2, losersList1, losersList2};
        var mergeRows = new List&lt;MergeRow&gt;();


        while (allLists.Any(l =&gt; l.Count &gt; 0))
        {
            var resultsInOneRow = allLists.Select(l =&gt; l.DefaultIfEmpty(new Gameresults()).FirstOrDefault()).ToList();
            mergeRows.Add(GetMergeRow(resultsInOneRow));
        }
</code></pre>

<p>Your <code>GetMergeRow()</code> method would look like:</p>

<pre><code>        private MergeRow GetMergeRow(List&lt;Gameresults&gt; recordsToMerge)
        {
            var mergeRow = new MergeRow();
            mergeRow.uidWinCol1 = recordsToMerge[0].userid;
            mergeRow.amtWinCol1 = recordsToMerge[0].amount;
            //... and so on
            return mergeRow;
        }
</code></pre>
