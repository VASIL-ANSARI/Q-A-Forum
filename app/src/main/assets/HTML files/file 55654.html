<p>Citing docs of <a href="https://docs.python.org/3/library/asyncio-eventloops.html#asyncio.AbstractEventLoopPolicy.get_event_loop" rel="nofollow"><code>get_event_loop</code></a> </p>

<blockquote>
  <p>Get the event loop for the current context.</p>
</blockquote>

<p>Implementation of <a href="https://docs.python.org/3/library/asyncio-eventloops.html#event-loop-policies-and-the-default-policy" rel="nofollow">default loop</a> (<em>Event loop default policy</em> to be precise):</p>

<blockquote>
  <p>The default policy defines context as the current thread, and manages an event loop per thread that interacts with asyncio.</p>
</blockquote>

<ul>
<li><p>An event loop runs in a thread and executes all callbacks and tasks in the same thread (<a href="https://docs.python.org/3/library/asyncio-dev.html#concurrency-and-multithreading" rel="nofollow">docs</a>), </p></li>
<li><p><code>asyncio.get_event_loop</code> returns the same loop for the same thread,</p></li>
<li><p>if you do not explicitly schedule on/interact with different thread's loop, it will use default (<strong>*</strong>) loop</p></li>
</ul>

<p>In your example:</p>

<ol>
<li><p><code>get_event_loop</code> returns current thread's event loop,</p></li>
<li><p><code>foo</code> is scheduled on that loop with <code>run_until_completed</code></p></li>
<li><p>any further async calls (awaits/yield from) are scheduled on the same loop</p></li>
</ol>

<p>More info at <a href="https://docs.python.org/3/library/asyncio-dev.html#concurrency-and-multithreading" rel="nofollow">Concurrency and multithreading</a>.</p>

<p>(<strong>*</strong>) The event loop you called <em>default</em> is actually a loop of current thread.</p>
