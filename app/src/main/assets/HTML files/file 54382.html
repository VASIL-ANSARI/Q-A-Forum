<p>The <code>.delay</code> call doesn't stop the loop from carrying on immediately, so all of the delays and animations will start (pretty much) at once.</p>

<p>The most trivial solution is to stagger the delay by the current index number:</p>

<pre><code>$('li').each(function(index) {
    $(this).delay(1000 * index).fadeIn(1000);
});
</code></pre>

<p>A better solution would use a pseudo-recursive loop and the "completion callback" of the animation to trigger the next iteration:</p>

<pre><code>var els = $('li').get();
(function loop() {
    if (els.length) {
        var el = els.shift();
        $(el).fadeIn(1000, loop);
    }
})();
</code></pre>

<p>This method is generally preferable because it ensures that the next fade-in cannot possibly start until the previous has finished, and also avoids creating multiple parallel delay / fade queues (one per element) since the 2nd animation isn't queued until the first has finished.</p>
