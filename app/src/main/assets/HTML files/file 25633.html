<p>Well it isn't ASP.net specific but in c#:</p>

<pre><code>using System.Diagnostics;

Process.Start([string]);
</code></pre>

<p>Or With more access to the specific parts of running a program (like arguments, and output streams)</p>

<pre><code>Process p = new Process();
p.StartInfo.FileName = "cmd.exe";
p.StartInfo.Arguments = "/c dir *.cs";
p.StartInfo.UseShellExecute = false;
p.StartInfo.RedirectStandardOutput = true;
p.Start();
</code></pre>

<p>here is how you could combine this with an ASPx Page:</p>

<p>First Process.aspx:</p>

<pre><code>&lt;%@ Page Language="C#" AutoEventWireup="true" CodeBehind="Process.aspx.cs" Inherits="com.gnld.web.promote.Process" %&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Test Process&lt;/title&gt;
    &lt;style&gt;
        textarea { width: 100%; height: 600px }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;form id="form1" runat="server"&gt;
      &lt;asp:Button ID="RunCommand" runat="server" Text="Run Dir" onclick="RunCommand_Click" /&gt;
      &lt;h1&gt;Output&lt;/h1&gt;
      &lt;asp:TextBox ID="CommandOutput" runat="server" ReadOnly="true" TextMode="MultiLine" /&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Then the code behind:</p>

<pre><code>using System;

namespace com.gnld.web.promote
{
    public partial class Process : System.Web.UI.Page
    {
        protected void RunCommand_Click(object sender, EventArgs e)
        {
            using (var cmd = new System.Diagnostics.Process()
            {
                StartInfo = new System.Diagnostics.ProcessStartInfo()
                {
                    FileName = "cmd.exe",
                    Arguments = "/c dir *.*",
                    UseShellExecute = false,
                    CreateNoWindow = true,
                    RedirectStandardOutput = true
                }
            })
            {
                cmd.Start();
                CommandOutput.Text = cmd.StandardOutput.ReadToEnd();
            };
        }
    }
}
</code></pre>
