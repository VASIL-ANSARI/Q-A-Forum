<p>This works as follows: </p>

<ol>
<li><code>node</code> is on the stack and references the heap-object (A), which you want to insert</li>
<li><code>_head</code> is presumably a member of a heap-object (the list) and references the heap-object (B) that is currently at the head of the list.</li>
<li>You create the reference <code>temp</code> on the stack, which then also references that object (B)</li>
<li>You change the reference <code>_head</code> to the heap-object referenced by <code>node</code>, so <code>_head</code> now references (A)</li>
<li>You now modify (A), which is referenced by both <code>_head</code> and <code>node</code>, to have its <code>next</code>-member reference (B)</li>
<li>Both (A) and (B) are have a reference count of at least one all the time, so GC does not run on either one.</li>
<li>After exiting the function the stack-memory for the references is reclaimed, and the heap object persist as long as they are referenced. </li>
<li>After retuning from the function, as long as your list still exists, (A) is referenced by the list-head, (B) is referenced by (A)'s <code>next</code>-member, and so on and so on, so nothing gets claimed by the garbage collection.</li>
</ol>
