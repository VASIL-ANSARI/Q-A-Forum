<p>This can be solved in any of a number of ways, and enums are one of them:</p>

<ol>
<li>define <code>enum TrollMood</code>;</li>
<li>let it define an abstract <code>doSomething</code> method;</li>
<li>let it have <code>GOOD</code> and <code>ANGRY</code> as members;</li>
<li>let each member implement <code>doSomething</code> appropriately;</li>
<li>let the <code>Troll</code> class have a property <code>TrollMood mood</code>;</li>
<li>let <code>Troll</code> also have a method <code>doSomething</code>, delegating to <code>mood.doSomething</code>.</li>
</ol>

<p>You can throw in an interface in this design, for example you can define <code>interface TrollBehavior { void doSomething(); }</code> and have <code>TrollMood implements TrollBehavior</code>. The design doesn't ask for it, but if that is the requirement, there is your interface.</p>
