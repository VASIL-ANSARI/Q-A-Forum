<p><code>x</code> is not an temporary, it is a l-value, an automatic variable which resides on stack.<br>
While, <code>&amp;boolVect[0]</code> is not an l-value.<br>
l-value is an entity whose address can be taken, in short a variable whose lifetime is long enough to reside in the memory so that it can be addressed by an name.        </p>

<p><strong>What is problem with <code>vector&lt;bool&gt;</code>?? It works fine for <code>vector&lt;int&gt;</code></strong>     </p>

<p>The C++ standard library provides a specialization of vector for boolean types.
The goal is optimization, to use less size than a usual implementation of
vector for type <code>bool</code>. A usual implementation for <code>bool</code> would reserve at least <code>1</code> byte for each element. The <code>vector&lt;bool&gt;</code> specialization usually uses internally only <code>1</code> bit for an element, so it is typically eight times smaller. But this optimization comes with a price:<br>
In C++, the smallest addressable value must have a size of at least <code>1</code> byte. Thus, such a specialization of a vector needs special handling for references and iterators.
As a result, a <code>vector&lt;bool&gt;</code> does not meet all requirements of other vectors. The behavior you see is one such example, elements of the <code>vector&lt;bool&gt;</code> are not a true l-values.</p>
