<p>You can transpose a matrix using the built-in function <a href="https://docs.python.org/2/library/functions.html?highlight=zip%20function#zip" rel="nofollow"><code>zip</code></a>:</p>

<pre><code>def transpose(m):
    return zip(*m)
</code></pre>

<p>From the docs:</p>

<blockquote>
  <p>This function returns a list of tuples, where the i-th tuple contains
  the i-th element from each of the argument sequences or iterables. The
  returned list is truncated in length to the length of the shortest
  argument sequence. When there are multiple arguments which are all of
  the same length, <code>zip()</code> is similar to <code>map()</code> with an initial argument of
  <code>None</code>. With a single sequence argument, it returns a list of 1-tuples.
  With no arguments, it returns an empty list.</p>
  
  <p>The left-to-right evaluation order of the iterables is guaranteed.
  This makes possible an idiom for clustering a data series into
  n-length groups using <code>zip(*[iter(s)]*n)</code>.</p>
</blockquote>

<p>To make this return a list of lists instead of a list of tuples, return the following list comprehension:</p>

<pre><code>[list(r) for r in zip(*m)]
</code></pre>

<p>Here's how to do it using append:</p>

<pre><code>def transpose(m):
    transposed = [[] for _ in range(len(m[0]))]
    for i in range(len(m)):
        for j in range(len(m[0])):
            transposed[j].append(m[i][j])
    return transposed
</code></pre>

<p>As you can see, using <code>zip</code> is much easier. :)</p>
