<p>Here's a method I use. As you'll see it's not much different from yours. It doesn't handle generics with multiple type parameters though.</p>

<pre><code>    /// &lt;summary&gt;
    /// When given certain types such as those based on &lt;see cref="T:Nullable`1"/&gt;, &lt;see cref="T:IEnumerable`1"/&gt;,
    /// or &lt;see cref="T:Array"/&gt;, returns the element type associated with the input type.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// For example, calling this method with Nullable(Of Boolean) would return Boolean. Passing Int32[] would
    /// return Int32, etc. All other types will return the input.
    /// &lt;/remarks&gt;
    /// &lt;param name="type"&gt;The a nullable type, array type, etc. whose element type you want to retrieve.&lt;/param&gt;
    /// &lt;returns&gt;The type that the input type is based on.&lt;/returns&gt;
    public static Type GetElementType( Type type )
    {

        ParameterValidation.ThrowIfNull( type, "type" );

        if ( type.IsGenericType ) {
            var typeArgs = type.GetGenericArguments( );
            if ( typeArgs.Length == 1 ) {
                return typeArgs[0];
            }   // if
        }   // if

        if ( type.HasElementType ) {
            return type.GetElementType( );
        }   // if

        if ( type.IsEnum ) {
            return Enum.GetUnderlyingType( type );
        }   // if

        return type;

    }
</code></pre>
