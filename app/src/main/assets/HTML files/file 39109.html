<p>So I guess I ended up solving it by mostly following the code code only option at this link <a href="http://msdn.microsoft.com/en-us/data/jj691402.aspx" rel="nofollow">http://msdn.microsoft.com/en-us/data/jj691402.aspx</a></p>

<p>I added a new method to my Repository that returned called a stored procedure and returned multiple results sets. Something along these lines</p>

<pre><code>Public Object[] StoredProcCall(string storedProc, SqlDbParams sqlParams, type[] types)
{
    var cmd = dbContext.Database.Connection.CreateCommand();
    cmd.CommandText = storedProc;
    cmd.CommandType = CommandType.StoredProcedure;
    if(parameters != null)
        cmd.Parameters.AddRange(sqlParams);
    var reader = cmd.ExecuteReader();

    try
    {
        dbContext.Database.Connection.Open();
        object[] mObj = new object[types.Count];
        for(int i = 0; i &lt; types.Count; i++)
        {
            System.Reflection.MethodInfo method = typeof(AutoMapper.Mapper).GetMethod("DynamicMap", new Type[] { typeof(object)});
            var generic = method.MakeGenericMethod(types[i]);
            objected mappedData = generic.Invoke(this, new object[] { reader});
            mObj[i] = mappedData;
            if(!reader.NextResult())
                break;

        }
        return mObj;
    }
    finally
    {
        dbContext.Database.Connection.Close();
    }

}
</code></pre>

<p>The only think is that for that to work I had to make a class that that consist of only one property which is my simple type. and every type in the array needs to be IEnumerable which is ok in my case. But That is the basics of what I did and can be changed as needed.</p>
