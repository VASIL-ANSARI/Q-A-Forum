<p>If a class has no logic, then that would be considered a data-structure.  For the question about whether to use a generic collection vs a type, I would choose creating types because of their expressiveness.</p>

<p>Take the following example.</p>

<pre><code>var employee = new Dictionary&lt;string, object&gt;();
employee["FirstName"] = "Steve";
employee["LastName"] = "McQueen";
employee["DOB"] = new DateTime(1942, 1, 5);
employee["Salary"] = 215000m;
</code></pre>

<p>Here you have the problem of</p>

<ul>
<li>being <a href="http://c2.com/cgi/wiki?StringlyTyped">Stringly Typed</a></li>
<li>unable to implement logic within the "employee"</li>
<li>no possibility of being <a href="http://en.wikipedia.org/wiki/Immutable_object">immutable</a></li>
<li>not being able to refactor</li>
</ul>

<p>Contrast this with.</p>

<pre><code>var employee = new Employee {
    FirstName = "Steve",
    LastName = "McQueen",
    DOB = new DateTime(1942, 1, 5),
    Salary = 215000m
};
</code></pre>

<p>You get the benefit of</p>

<ul>
<li>being able to find references of employee</li>
<li>subclass employee</li>
<li>refactor employee (rename <code>DOB</code> to <code>DateOfBirth</code> without having to do a search and replace)</li>
<li>make properties immutable</li>
<li>compile time checking</li>
<li>add domain logic if ever needed</li>
<li>can impose invariants</li>
</ul>

<p>Though the one downside to this is that you have to define a class, which means more typing, though I feel the benefits <em>greatly</em> outweigh the costs.</p>

<p>To elaborate on my examples above, suppose you wrote a method from a repository that returned an employee.</p>

<pre><code>var employee = employeeRepository.GetById(25);
</code></pre>

<p>If <code>employee</code> were a dictionary in this example, I would have no Intellisense to know which attributes an employee has, let alone their types, this is also illustrated by @HighCore's comment.  The only ways to determine this is to either</p>

<ul>
<li>read the documentation (probably out-of-date or inaccurate)</li>
<li>execute the method and inspect with debugger (a waste of time and might not be possible in all every scenario)</li>
</ul>

<p>In the scenario of persisting a new <code>employee</code>, the dictionary runs into the same pitfalls and now you're at the peril of hoping the method you just executed returns meaningful error messages.</p>
