<p>Yes, it's possible. One option is to try and find a class that is a superclass of all the classes you want to use, or an interface all your classes implement. In your case, the only candidate might be Object:</p>

<pre><code>public static Object[] multipleOfSameSet(Object var, int setLength) {
    Object[] out = new Object[setLength];
    for(int i = 0; i &lt; setLength; i++) {
        out[i] = var;
    }
    return out;
}
</code></pre>

<p>This will work, because all Java classes extend Object, either directly or indirectly. Primitive values get converted into objects automaticaly (ints become <code>Integer</code>s, doubles become <code>Double</code>s and so on).</p>

<p>The downside of this approach is that, well, you get an array of Objects back, and there's not much you can do with those. What you might want to consider instead is making your method accept some generic type T, and returning an ArrayList of T's:</p>

<pre><code>public static &lt;T&gt; ArrayList&lt;T&gt; multipleOfSameSet(T object, int setLength) {
    ArrayList&lt;T&gt; out = new ArrayList&lt;T&gt;();
    for(int i = 0; i &lt; setLength; i++) {
        out.add(object);
    }
    return out;
}
</code></pre>

<p>However, if you don't need to modify the list afterwards, I'd go with this:</p>

<pre><code>public static &lt;T&gt; List&lt;T&gt; multipleOfSameSet(T object, int setLength) {
    return Collections.nCopies(setLength, object);
}
</code></pre>
