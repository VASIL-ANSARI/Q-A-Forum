<p>Can you post more code?</p>

<p>If you are inside view controller when marray is being called, you shouldn't have to call <code>viewController.marray</code>, just <code>marray</code></p>

<p>One suggestion, from my experience in parsing, is to use an NSMutableDictionary instead of an array..so, for instance:</p>

<pre><code>    - (void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary *)attributeDict
{

    currentElement = [elementName copy];

if([elementName isEqualToString:@"item"])
{
    //Clear out story item caches
    item = [[NSMutableDictionary alloc] init];
    currentTitle = [[NSMutableString alloc] init];
    currentAddress = [[NSMutableString alloc] init];
    currentCity = [[NSMutableString alloc] init];
    currentState = [[NSMutableString alloc] init];
    currentZip = [[NSMutableString alloc] init];
    currentId = [[NSMutableString alloc] init];
}
</code></pre>

<p>}</p>

<p>and then to add everything:</p>

<pre><code>- (void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName
{

    if([elementName isEqualToString:@"item"])
{
    //Save values to an item, then store that item into the array
    [item setObject:currentTitle forKey:@"title"];
    [item setObject:currentAddress forKey:@"address"];
    [item setObject:currentCity forKey:@"city"];
    [item setObject:currentState forKey:@"state"];
    [item setObject:currentZip forKey:@"zip"];
    [item setObject:currentId forKey:@"id"];

           // venues is the mutable array
    [venues addObject:[item copy]];
    } else {
        return;
    }
}
</code></pre>

<p>Now my mutable array has all the elements I need, and I can do various things with it (like reload a table cell). The above code has been tested and verified as working.</p>
