<p>A pointer is really just the address of a memory location.</p>

<p>The value of a pointer variable is the address the pointer is pointing to.</p>

<p><a href="http://en.cppreference.com/w/c/memory/malloc" rel="nofollow">The <code>malloc</code> function</a> allocates a chunk of bytes somewhere in memory (where that memory is located is irrelevant). It returns a pointer to the first byte of that memory.</p>

<hr>

<p>A little more visually a pointer and what it points to could be seen as this:</p>

<pre>
+---------+      +------------+
| pointer | ---> | Memory ... |
+---------+      +------------+
</pre>

<p>You could also see the memory returned by <code>malloc</code> as an array. Taking parts of the code from your example, if <code>mid</code> is <code>5</code> then you have something like this:</p>

<pre>
+---+      +------+------+------+------+------+------+
| L | ---> [ L[0] | L[1] | L[2] | L[3] | L[4] | .... |
+---+      +------+------+------+------+------+------+
</pre>

<p>That is, the variable <code>L</code> points to the first element (<code>L[0]</code>) in the allocated "array".</p>

<p>Do note that there is really no end to the "array" allocated by <code>malloc</code>. C doesn't have any bounds checking, and the compiler will not give you any error or warning for using an index that is out of bounds (for example <code>L[5]</code> using out example above). It will lead to <em>undefined behavior</em> and possibly crashes or weird behavior, but you can still access or even write to that element.</p>

<p>Also note that taking the size of a pointer with the <code>sizeof</code> operator will not return the size of the memory it points to, but the size of the pointer itself. For example doing <code>sizeof L</code> will not return <code>mid</code> or <code>mid * sizeof(int)</code>. It will return the size of the pointer variable <code>L</code>, which is typically <code>4</code> or <code>8</code> depending on if you're on a 32 or 64 bit system.</p>
