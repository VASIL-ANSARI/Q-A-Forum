<p>As it has been established in the comments that this is about linux, here is a snippet that does what you want:</p>

<pre><code>int b = FALSE;
while (1) { // loop forever
    b = !b;
    sleep(1);  // wait for 1 second
}
</code></pre>

<p>The problem is that this code is sequential: you can't do anything with b while the loop is running, and there is no point in having this.</p>

<p>The first solution is to make your code parallel. It's not easy to do that (at least not reliable), so let's find a better solution: UNIX timestamp.</p>

<p>The UNIX timestamp represents the number of seconds passed form 1 January 1970 (don't worry about that date, it has some historical meaning). There is a function in <code>time.h</code> called <code>time</code> that can be used to get the UNIX timestamp. Instead of having a variable that is true or false every second, you can check the parity of this value.</p>

<p>So, the code above is equivalent to:</p>

<pre><code>while (1)
    b = time(NULL) % 2;
</code></pre>

<p>The difference is that in this case you don't need to keep the loop running. You just get the value of b at any point in your program.</p>
