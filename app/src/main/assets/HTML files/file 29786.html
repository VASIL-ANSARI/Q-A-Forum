<p>How about Yoni Roit's second proposal from the Stackoverflow link you provide? In other words, serialize and then deserialize the object - so this will result in deep copying your object byte-wise. You need to have your class implement Serializable. As long as all class fields can be serialized, this approach should work. However, serializing and deserializing objects can be quite slow apparently - probably not an issue if you want to do this out of convenience, rather than out of efficiency. Here's a simple example of re-creating a new ArrayList: </p>

<pre><code>    ArrayList&lt;Integer&gt; foo = new ArrayList&lt;Integer&gt;();
    foo.add(5);
    foo.add(3);
    foo.add(1);
    ArrayList&lt;Integer&gt; obj = null;
    // Write the object out to a byte array
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    ObjectOutputStream out = new ObjectOutputStream(bos);
    out.writeObject(foo);
    out.flush();
    out.close();

    // Make an input stream from the byte array and read
    // a copy of the object back in.
    ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(
            bos.toByteArray()));
    obj = (ArrayList&lt;Integer&gt;)in.readObject();
</code></pre>

<p>In your case, you'd want to type-cast to your specific class of course. This way you don't have to explicitly copy each field in the class.</p>
