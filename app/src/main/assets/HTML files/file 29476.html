<p><code>.callCount</code> is a property of the <code>spy</code>.</p>

<pre><code>function MyCtorFn() {
this.myMethod = function() {
      console.log("hello world")
  }
}

//arrange
var myCtrFn = new MyCtorFn();
var spy = spyOn(myCtrFn, 'myMethod');

//act
myCtrFn.myMethod();

spy.callCount; // 1
</code></pre>

<hr>

<p>Actually, it's very strange that it doesn't work, since the <code>spyOn</code> method should replace the original method with the spy.</p>

<p>See <code>https://github.com/pivotal/jasmine/blob/master/lib/jasmine-core/jasmine.js</code> line <code>582</code>.</p>

<p>Personally I think that is very strange behavior. This would cause all kinds of incompatibilities with other frameworks. What if you had two instances of jasmine and they both try to spy on the same function? Very strange.</p>

<p>This is why I assumed the properties were only on the spy.</p>

<p>The whole point of a spy is that you're undetectable right?</p>

<pre><code>var trustedFunction = function () {};
var obj = {
    foo: trustedFunction
}
spyOn(obj, "foo");
obj.foo === trustedFunction; // false? BUSTED
</code></pre>

<p>Perhaps a <strong>spy</strong> is not the right analogy. A <code>CallTrackerWrapper</code> would be a much less nefarious and more humble name.</p>
