<h2>First of all,</h2>

<p>I do not pretend to be extra C++ expert.</p>

<h2>Multiple inheritance is not 'no go'</h2>

<p>(otherwise it would be excluded from the language). Multiplle inheritance is the thing, that should be used <em>carefully</em>. And you should understand, what are you doing, when using it.</p>

<p>In your case it looks improbable that you meet <a href="http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" rel="nofollow">diamond problem</a>, that is evil of multiple inheritance.</p>

<p>Recursive template pattern allows you to check enabled features in <em>compile time</em>, like this</p>

<pre><code>#define FEATURED(FEATURE, VALUE) \
template &lt;template&lt;class&gt;class Feature = FEATURE&gt; \
typename std::enable_if&lt;std::is_base_of&lt;Feature&lt;RectType&gt;, RectType&gt;::value == VALUE&gt;::type

template &lt;class RectType&gt;
class Styleable;

template &lt;class RectType&gt;
class Drawable{
    public:

        FEATURED(Styleable, true)
        drawImpl()
        {
            std::cout &lt;&lt; "styleable impl\n";
        }

        FEATURED(Styleable, false)
        drawImpl()
        {
            std::cout &lt;&lt; "not styleable impl\n";
        }


        virtual void draw(){
            drawImpl();
        }
};
</code></pre>

<p>You can implement something likewise in functionality with normal inheritance, but It seems impossible to make compile time feature checks.</p>

<p>On the other hand, you'll get your code more complicated with crtp, and you'll have to implement in all in header files.</p>

<h2>Summing up,</h2>

<p>I think it is complicated, and you should be sure you actually need it. It will work for some time, until it will be redesigned, as any other code. Its lifetime depends mostly on your task understanding.</p>
