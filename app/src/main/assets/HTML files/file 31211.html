<p>If values in input CSV file are sorted, and the data never changes, we can abandon the bucket approach from the comments and just cram all the data pairs in one big array in file. The goal is to have data better organized, to enable fast reading, and so avoid having whole dataset in memory. You would have to convert the CSV file to a new binary format, and in the process create the index array in memory. This index array should also be saved to some index file, so that it can be used when the program is restarted. In memory you would only hold the array of positions of the first data pair whose value begins with item's index. In file you would have just a huge array of 32-bit (4 byte) numbers, where first 3 bytes of each number is leftover of the indexed item in memory and last byte is our output.</p>

<p>To create index array you would read CSV file line by line. For each datapair (<code>input_int</code>, <code>output_int</code>) create new datapair (<code>index</code>, <code>32-bit value</code>). <code>Index</code> takes first 2 bytes of <code>input_int</code>, and <code>32-bit value</code> is created concatenating last 3 bytes of <code>input_int</code> and a sole byte of <code>output_int</code>. If <code>index</code> is changed from the previous datapair then store file's position to array at new index. In any case append <code>32-bit value</code> to file. Repeat until the end of CSV file.</p>

<p>So let's say we have an input value 0x1234567890 and need corresponding output value. Algorithm would find the items in the array in memory with indexes 0x1234 and 0x1235. This would give you the start and end position in the file where our item might be. In this range we do a <a href="http://en.wikipedia.org/wiki/Binary_search_algorithm" rel="nofollow">binary search</a> for the value 0x567890 and take the byte that follows it. That's our output value.</p>
