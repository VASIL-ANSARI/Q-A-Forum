<p>The example "Using a DML AFTER trigger to enforce a business rule between the PurchaseOrderHeader and Vendor tables" in the <a href="http://msdn.microsoft.com/en-us/library/ms189799.aspx">CREATE TRIGGER</a> MSDN documentation does exaclty what you're looking for:</p>

<pre><code>USE AdventureWorks2008R2;
GO
IF OBJECT_ID ('Purchasing.LowCredit','TR') IS NOT NULL
   DROP TRIGGER Purchasing.LowCredit;
GO
-- This trigger prevents a row from being inserted in the Purchasing.PurchaseOrderHeader table
-- when the credit rating of the specified vendor is set to 5 (below average).

CREATE TRIGGER Purchasing.LowCredit ON Purchasing.PurchaseOrderHeader
AFTER INSERT
AS
DECLARE @creditrating tinyint, @vendorid int;
IF EXISTS (SELECT *
           FROM Purchasing.PurchaseOrderHeader p 
           JOIN inserted AS i 
           ON p.PurchaseOrderID = i.PurchaseOrderID 
           JOIN Purchasing.Vendor AS v 
           ON v.BusinessEntityID = p.VendorID
           WHERE v.CreditRating = 5
          )
BEGIN
RAISERROR ('This vendor''s credit rating is too low to accept new purchase orders.', 16, 1);
ROLLBACK TRANSACTION;
RETURN 
END;
</code></pre>

<p>The key here is <code>ROLLBACK TRANSACTION</code>, just adapt the example to suit your need and you're done.</p>

<p>Edit: This should accomplish what you're looking for, but I have not tested it so your mileage may vary.</p>

<pre><code>create trigger dbo.something after insert as
begin
    if exists ( select * from inserted where sum(credits) &gt; 30 )
    begin
        rollback transaction
        raiserror ('some message', 16, 1)
    end
end
</code></pre>

<p>Another edit, based on some assumptions (please note I wrote this script on the fly since I can't test it right now):</p>

<pre><code>create table dbo.students
(
    student_id int not null,
    name varchar (50) not null
)

create table dbo.courses
(
    course_id int not null,
    name varchar (50) not null,
    required_credits int not null
)

create table dbo.results
(
    student_id int not null,
    course_id int not null,
    course_result int not null
)

create trigger dbo.check_student_results on dbo.results after insert as
(
    declare @check int

    select @check = count(*)
    from inserted as a
    join dbo.courses as b on b.course_id = a.course_id
    where b.required_credits &gt; a.course.result

    if @check &lt;&gt; 0
    begin

        rollback transaction

        raiserror('The student did not pass the course.', 16, 1)

    end
)
</code></pre>

<p>This way when you insert records in the <code>dbo.results</code> table the constraint checks if the student has passed the course, and cancels the insertion if appropriate. However, it's better to check this things in the application layer.</p>
