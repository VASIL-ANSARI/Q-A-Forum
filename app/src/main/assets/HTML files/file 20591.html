<p>I think the following code does what you describe. It start checking with the first node (0,0). For every node that is checked, a vector of neighbors is created. The neighbors are the nodes that are eligible to be a continuation to the path (i.e. neighboring nodes with higher value in the table). Then for each neighbor, the path is cloned, and the new neighbor is checked. This continues until the checked node has no eligible neighbors, at which point the path is printed and the algorithm terminates.</p>

<p>Try this:</p>

<pre><code>import java.util.Arrays;
import java.util.Vector;

class Main {
  class Coords {
    int x;
    int y;
    Coords(int x, int y) {
      this.x = x;
      this.y = y;
    }
  }
  int [][] array = { {3,5,1},{6,7,4},{8,2,9}};
  Vector&lt;Coords&gt; getNeighbors(Coords coords) {
     int x = coords.x;
     int y = coords.y;
     Vector&lt;Coords&gt; result = new Vector&lt;Coords&gt;();
     if (x &lt; array.length - 1) {
        if (array[x + 1][y] &gt;= array[x][y])
          result.add(new Coords(x + 1, y));
     }
     if (x &gt; 0) {
        if (array[x - 1][y] &gt;= array[x][y])
          result.add(new Coords(x - 1, y));
     }
     if (y &lt; array[x].length - 1) {
        if (array[x][y + 1] &gt;= array[x][y])
          result.add(new Coords(x, y + 1));
     }
     if (y &gt; 0) {
        if (array[x][y - 1] &gt;= array[x][y])
          result.add(new Coords(x, y - 1));
     }
     if (x &lt; (array.length - 1 ) &amp;&amp;  (y &lt; array[x].length - 1)) {
        if (array[x + 1][y + 1] &gt;= array[x][y])
          result.add(new Coords(x + 1, y + 1));
     }
     if (x &lt; (array.length - 1 ) &amp;&amp;  (y &gt; 0)) {
        if (array[x + 1][y - 1] &gt;= array[x][y])
          result.add(new Coords(x + 1, y - 1));
     }
     if (x &gt; 0 &amp;&amp;  (y &lt; array[x].length - 1)) {
        if (array[x - 1][y + 1] &gt;= array[x][y])
          result.add(new Coords(x - 1, y + 1));
     }
     if (x &gt; 0 &amp;&amp;  y &gt; 0) {
        if (array[x -1][y - 1] &gt;= array[x][y])
          result.add(new Coords(x - 1, y - 1));
     }
     return result;
  }
  void checkNode(Vector&lt;Integer&gt; path, Coords coords) {
    path.add(array[coords.x][coords.y]);
    Vector&lt;Coords&gt; neighbors = getNeighbors(coords);
    if (neighbors.size() == 0) {
       for (Integer i : path) {
         System.out.print(i+"\t");
       }
       System.out.println();
    }
    for (Coords c : neighbors) {
      Vector&lt;Integer&gt; newpath = (Vector&lt;Integer&gt;) path.clone();
      checkNode(newpath, c);
    }
  }
  Main() {
    System.out.println ("Array: " + Arrays.deepToString(array));
    checkNode(new Vector&lt;Integer&gt;(),new Coords(0,0));
  }

  public static void main(String args[]) {
    new Main();
  }
}
</code></pre>

<p>Output: </p>

<pre><code>Array: [[3, 5, 1], [6, 7, 4], [8, 2, 9]]
3   6   8   
3   6   7   9   
3   6   7   8   
3   5   7   9   
3   5   7   8   
3   5   6   8   
3   5   6   7   9   
3   5   6   7   8   
3   7   9   
3   7   8   
</code></pre>

<p>It also gives me the path 3,6,8, which is not in your sample output</p>
