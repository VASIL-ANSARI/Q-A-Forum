<p>All depends on the definition of words: is it a string speparated from others with a whitespace ?  Or are other word separators (e.g. coma, dot, semicolon, colon, parenntheses...)  relevant as well ?  </p>

<h1>How to parse for words without regex:</h1>

<p>Here an accetable approach using <a href="http://www.cplusplus.com/reference/string/string/find/" rel="nofollow"><code>find()</code></a> and its variant <a href="http://www.cplusplus.com/reference/string/string/find_first_of/" rel="nofollow"><code>find_first_of()</code></a>:  </p>

<pre><code>string myline;     // line to be parsed
string what="3";   // string to be found
string separator=" \t\n,;.:()[]";  // string separators
while (getline(cin, myline)) {
    size_t nxt=0;
    while ( (nxt=myline.find(what, nxt)) != string::npos) {  // search occurences of what
        if (nxt==0||separator.find(myline[nxt-1])!=string::npos) { // if at befgin of a word
            size_t nsep=myline.find_first_of(separator,nxt+1);   // check if goes to end of wordd
            if ((nsep==string::npos &amp;&amp; myline.length()-nxt==what.length()) || nsep-nxt==what.length()) {
                cout &lt;&lt; "Line: "&lt;&lt;myline&lt;&lt;endl;    // bingo !!  
                cout &lt;&lt; "from pos "&lt;&lt;nxt&lt;&lt;" to " &lt;&lt; nsep &lt;&lt; endl; 
            }
        }
        nxt++;  // ready for next occurence
    }
}
</code></pre>

<p>And here the <a href="http://ideone.com/ma0zoF" rel="nofollow">online demo</a>.  </p>

<p>The principle is to check if the occurences found correspond to a word, i.e. are at the begin of a string or begin of a word (i.e. the previous char is a separator) and that it goes until the next separator (or end of line).   </p>

<h1>How to solve your real problem:</h1>

<p>You can have the fastest word search function:  if ou use it for solving your problem of counting words,  as you've explained in your comment, you'll waste a lot of efforts !  </p>

<p>The best way to achieve this would certainly be to use a <a href="http://www.cplusplus.com/reference/map/map/" rel="nofollow"><code>map&lt;string, int&gt;</code></a> to store/updated a counter for each string encountered in the file.  </p>

<p>You then just have to parse each line into words (you could use <code>find_fisrst_of()</code> as suggested above) and use the map: </p>

<pre><code> mymap[word]++; 
</code></pre>
