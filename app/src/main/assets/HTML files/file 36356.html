<p><strong>(REWRITTEN)</strong> So, assuming you want to somehow filter horizontal and vertical lines which are 'similar' and want both the code and good condition for what 'similar' should be, then here are my thoughts:</p>

<p><strong>First split horizontal and vertical lines:</strong></p>

<pre><code>List&lt;Line&gt; vert = new List&lt;Line&gt;();
List&lt;Line&gt; horiz = new List&lt;Line&gt;();
foreach(Line ln in RecoverLine_list)
    if(ln.orientation == 0) horiz.Add(ln);
    else vert.Add(ln);
horiz.Sort(x, y =&gt; x.P1.Y.CompareTo(y.P1.Y));
vert.Sort(x, y =&gt; x.P1.X.CompareTo(y.P1.X));
</code></pre>

<p>or something like that (not exactly sure what your orientation is, I am just guessing including the coding of sorting using lambdas).</p>

<p>Then you can search the lines in one pass extracting good-ones:</p>

<pre><code>List&lt;Line&gt; filtered = new List&lt;Line&gt;();
for(int i = 0; i &lt; horiz.Count; i++) {
    filtered.Add(ln); // always add, we can skip next:
    if(i+1 &gt;= horiz.Count) break;
    if(Math.Abs(horiz[i].P1.Y - horiz[i+1].P1.Y) &lt;= 3)
    &amp;&amp; Math.Abs(horiz[i].P1.X - horiz[i+1].P1.X) &lt;= 3)
    &amp;&amp; Math.Abs(horiz[i].P2.X - horiz[i+1].P2.X) &lt;= 3))
        i++; // skip this line for being similar
}
</code></pre>

<p>but that is not final solution, because we can have lines close to each other in one coordinate but not in the other. So we need to add inner loop:</p>

<pre><code>for(int i = 0; i &lt; horiz.Count-1; i++) {
    for(int j = i+1; j &lt; horiz.Count; j++) {
        if((horiz[j].P1.Y - horiz[i].P1.Y) &gt; 3)
           break; // this one is too far, all next will be
        if(Math.Abs(horiz[i].P1.Y - horiz[j].P1.Y) &lt;= 3)
        &amp;&amp; Math.Abs(horiz[i].P1.X - horiz[j].P1.X) &lt;= 3)
        &amp;&amp; Math.Abs(horiz[i].P2.X - horiz[j].P2.X) &lt;= 3))
            horiz.RemoveAt(j--); // skip this line for being similar
}}
</code></pre>

<p>Got the idea? Same for vertical lines.</p>
