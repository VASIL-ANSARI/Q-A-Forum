<p><a href="http://www.cplusplus.com/reference/cstring/strncpy/"><code>strncpy()</code></a> in <code>strclip()</code> is the cause of your problem;</p>

<blockquote>
  <p><em>No null-character is implicitly appended at the end of destination if source is longer than num</em>. Thus, in this case, destination shall not be considered a null terminated C string (reading it as such would overflow).</p>
</blockquote>

<p>Since you're using <code>calloc()</code> anyway to get memory filled with zeroes, all you need to do is allocate an extra char that won't be overwritten;</p>

<pre class="lang-c prettyprint-override"><code>char *q = (char *) calloc(n + 1, sizeof(char));
strncpy(q, right_start, n);
</code></pre>

<p>This will leave the last char of the buffer as zero, so you have a guaranteed termination of the string.</p>
