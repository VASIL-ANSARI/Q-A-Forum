<p>Those methods are the equivalent of python's <a href="http://docs.python.org/2/reference/datamodel.html#specialnames" rel="nofollow">special methods</a>, and are called in the same circumstances. For example <code>tp_as_number-&gt;nb_add</code> is called when executing <code>a + b</code> and <code>a</code> is the extension type.
It is the equivalent of <code>__add__</code>. The <code>inplace_*</code> functions are the equivalents of <code>__i*__</code> methods.</p>

<p>Note that the <code>__r*__</code> methods are implemented simply swapping arguments to the normal functions, thus <code>5 + a</code> where <code>a</code> is an extension type will first try to call the numeric version of <code>nb_add</code>, after this failed it tries <code>nb_add</code> of <code>a</code> putting <code>5</code> as first argument and <code>a</code> as the second one.</p>

<p>The same is true for the <code>tp_as_mapping</code> and <code>tp_as_sequence</code> structs. The <code>mp_length</code> and <code>sq_length</code> functions are called by the built-in function <code>len</code>, and are the equivalent of <code>__len__</code>. Theoretically you could implement different functions for <code>mp_length</code> and <code>sq_length</code>, in which case the <code>sq_length</code> has precedence(this can be seen from the source code, even though I don't know whether this behaviour is documented).</p>

<p>Also note that, for example, the <code>+</code> operator can be implemented in different functions. The <code>sq_concat</code> is called after trying <code>nb_add</code>, and thus an extension type can support <code>+</code> operator without having an <code>nb_add</code> function set.</p>
