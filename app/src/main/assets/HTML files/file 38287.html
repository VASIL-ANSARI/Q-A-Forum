<pre><code>for (pattern, slice) in zip([patternA, patternB, patternC],
                            [slice(45,67), slice(5,7), slice(4,5)]):
    m = re.search(pattern, string)
    if m:
        value = m.group(0)[slice]
        break
else:
    # Handle no match found for any pattern here
</code></pre>

<p>This iterates over pairs of regular expressions and the relevant portion of their match until a match is found. If there is no match found, the <code>else</code> clause of the <code>for</code> loop will execute. The result of the match is found in <code>value</code> after the loop, regardless of which pattern matches.</p>

<p>Having different variables set based on which "branch" succeeds is not a great idea, since you won't necessarily know which variables are set at any given time. A dictionary would be a better idea if you really want separate labels for each match, since you can query which key or keys are set in a dictionary.</p>

<pre><code>value = {}
for (pattern, slice, key) in zip([patternA, patternB, patternC],
                                 [slice(45,67), slice(5,7), slice(4,5)],
                                 ['abc', 'xyx', 'txt']):
    m = re.search(pattern, string)
    if m:
        value[key] = m.group(0)[slice]
        break
</code></pre>

<p>The general idea, though, is to note that your chain of <code>if</code> statements is like a hard-coded iteration, so you just need to identify which parts of each <code>if/elif</code> clause varies from the preceding ones, and create a list that you can iterate over instead.</p>
