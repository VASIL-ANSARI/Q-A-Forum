<p><code>max_year</code> is assigned when the first <code>if</code> conditional is satisfied.  But if that never happens, <code>max_year</code> will never be assigned.  That situation will occur when <code>increase_pop[0]</code> (and hence the initial value of <code>max_value</code>) is the largest value in <code>increase_pop</code>: then <code>increase_pop[count] &gt; max_value</code> will never be true.</p>

<p>In your code, you could simply initialize <code>max_year = count = 0</code></p>

<p>However, IMO the neatest, most Pythonic solution is the one from Patrick Haugh's comment:</p>

<pre><code>max_year, max_value = max( enumerate(increase_pop), key=lambda x: x[1] )
</code></pre>

<p>To unpack that:  <code>enumerate(increase_pop)</code> generates a sequence of pairs:</p>

<pre><code>(0, increase_pop[0]),   (1, increase_pop[1]), ...
</code></pre>

<p>and the <code>max</code> operator takes the "maximum" such pair according to the criterion specified by the <code>key</code> (and that particular key function just says "only consider the second value in each pair").</p>
