<p>Why would you expect it to work?  You declare <code>p</code> as <code>char**</code>,
and you try to assign a <code>char[2][5]</code> to it.  The <code>char[2][5]</code>
will convert implicitly to a <code>char (*)[5]</code>, but afterwards, you
have a pointer, and no further implicit conversions.  (EDIT: except to <code>void*</code>.)</p>

<p>If you think about it, it should be obvious.  If you dereference
a <code>char**</code>, you get a <code>char*</code>.  And this <code>char*</code> must reside
somewhere in memory, since you have a pointer to it.  So where
is it? </p>

<p>If you want to iterate over the outer array in your example:</p>

<pre><code>char (*p)[5] = a;
std::cout &lt;&lt; *p[0] &lt;&lt; sdt::endl;
std::cout &lt;&lt; *p[1] &lt;&lt; sdt::endl;
</code></pre>

<p>Note that your expression <code>*(*(a+1)+1)</code> also supposes that you
have an array of pointers somewhere.</p>

<p>Or you can use the usual solution when working with C style
strings:</p>

<pre><code>char const* const a[] = { "hell", "worl" };
</code></pre>

<p>and</p>

<pre><code>char const* const* p = a;
</code></pre>

<p>In this case, you do have an array of pointers, which does
implicitly convert to a pointer to a pointer (the first element
of the array).</p>

<p>(Of course, the only time you'll really want to use C style
strings is with const variables with static lifetimes.  In
most other cases, <code>std::string</code> is preferable.)</p>
