<p>The problem is that you are not defining <code>i</code> in the loop.  <code>i</code> is being left over from the last time it was used.  Specifically, it is using the last value of <code>i</code> from the previous loop.  This value is <code>len(t)-1</code>, which is much larger than the length of the 3rd dimension of <code>exp_Pes</code> which has a length of 2.  You need to define a valid value for <code>i</code> somewhere.</p>

<p>If you don't want to loop over <code>i</code>, generally you could just define it once before the loop starts.  In your case, however, you would need to set it every time you loop since it is also being defined inside this loop a few lines below the one causing the error.</p>

<p>However, it would probably be clearer to just do something like <code>exp_Pes[indx,jndx,j,0] = ...</code>, since people reading your code won't need to look back and find what value <code>i</code> was set to.</p>

<p>A couple more minor points of advice:</p>

<p><code>np.arange</code> does not include the last value.  So the case where you use <code>7-dt</code> at the beginning, you are ending up with the start being <code>0</code> and the end being <code>7-dt-dt</code>, which is probably not what you want.  But anyway, you should never use <code>np.arange</code> (or the equivalent in MATLAB) with floats, since it can have floating-point errors.  Use <code>np.linspace</code> instead.</p>

<p>Second, for your <code>_min</code> function, you don't need <code>[]</code>, you can just do <code>return np.amin(x), np.argmin(x)</code>.  </p>

<p>However, it is usually easier for arrays to use the method version, which is the version attached to the array.  This would be <code>return x.min(), x.argmin()</code>.  Same with <code>np.copy(rho)</code>, use <code>rho.copy()</code> instead.</p>

<p>However, this function could be further simplified to a <code>lambda</code> expression, the equivalent of a Matlab anonymous function, like so: <code>_min = lambda x: [x.min(), x.argmin()]</code> (you do need the <code>[]</code> there).</p>

<p>You should use the <code>numpy</code> version of functions with <code>numpy</code> arrays.  They will be faster.  So <code>np.abs(t-t[0])</code> is faster than <code>abs(t-t[0])</code>.  Same with using <code>np.sqrt(sig1)</code> instead of <code>math.sqrt(sig1)</code>.</p>

<p>You also don't need the <code>[] in returned values, so</code>[min_dif, array_pos_start] = _min(abs(t -t[0] ))<code>can be</code>min_dif, array_pos_start = _min(np.abs(t-t[0])).  However, since you are never actually using <code>min_dif</code>, this could just be <code>array_pos_start = np.abs(t-t[0]).argmax()</code>.</p>

<p>You don't need to end lines with <code>;</code>.</p>

<p>You don't need to assign to a variable before returning.  So you can just have, for example, <code>return A*B-B*A</code>.</p>

<p>You seem to unnecessarily use the <code>nargout</code> argument.  Python doesn't use this, in large part because you can just index the results  So say you have a function <code>foo(x)</code> that returns the min and max of <code>x</code>.  You can just want the max, you can do <code>foo(x)[1]</code>.  Matlab doesn't let you do that, so it relies on <code>nargout</code> to work around it.</p>
