<p>You can use <a href="http://en.cppreference.com/w/cpp/error/uncaught_exception" rel="nofollow"><code>std::uncaught_expeption</code></a> to check if an exception is currently being thrown. If so, you can try to extract information from the current exception:</p>

<pre><code>if( std::uncaught_exception() ) {
    if( const std::exception_ptr eptr = std::current_exception() ) {
        try {
            std::rethrow_exception( eptr );
        }
        catch( const std::exception&amp; e ) {
            std::cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; std::endl;
            throw;
        }
        catch( ... ) {
            std::cerr &lt;&lt; "Unknown exception" &lt;&lt; std::endl;
            throw;
        }
    }
    else {
        std::cerr &lt;&lt; "Weird, this should not happen!" &lt;&lt; std::endl;
    }
}
</code></pre>

<p>or just do some cleanup processing and continue as it looks like you don't really care about the exception itself, you just add the logging depending of whether or not the destructor is called while unwinding the stack due to an exception.</p>

<hr>

<p>Another option might be <a href="http://en.cppreference.com/w/cpp/error/set_terminate" rel="nofollow"><code>std::set_terminate</code></a>. This is useful if you want to have a method called when an exception is not caught and about to terminate the program. In the terminate handler, I usually print some information about the exception and a (demangled) backtrace of where it originates from to my log file before finally terminating the program. This is compiler and system specific, but a real helper as it saves a lot of time if you write server processes and often the log file is all you get from ops.</p>
