<p>I originally thought I could use <code>.groupby("ID").last()</code> but couldn't quite get it to work.  (We could do it with <code>transform</code>, of course, but that feels like too much firepower.)</p>

<p>If your data is ordered by <code>date</code> and has contiguous IDs, however, you can simply compare whether <code>ID</code> is equal to the next <code>ID</code>.  For example:</p>

<pre><code>&gt;&gt;&gt; df = df.sort(["ID", "Date"])
&gt;&gt;&gt; df
  ID                Date
0  A 2010-01-01 00:00:00
1  A 2010-02-01 00:00:00
2  A 2010-02-15 00:00:00
3  B 2010-01-01 00:00:00
4  C 2010-02-01 00:00:00
5  C 2010-02-15 00:00:00
&gt;&gt;&gt; df["everagain"] = df["ID"] == df["ID"].shift(-1)
&gt;&gt;&gt; df
  ID                Date everagain
0  A 2010-01-01 00:00:00      True
1  A 2010-02-01 00:00:00      True
2  A 2010-02-15 00:00:00     False
3  B 2010-01-01 00:00:00     False
4  C 2010-02-01 00:00:00      True
5  C 2010-02-15 00:00:00     False
</code></pre>

<p>If you wanted ones and zeroes instead of <code>True and False</code>, you could use <code>(df["ID"] == df["ID"].shift(-1))*1)</code> or <code>(df["ID"] == df["ID"].shift(-1)).astype(int)</code> to convert them.</p>
