<p>SurfaceView and scrolling don't go well together, because the SurfaceView has two parts -- the Surface and the View -- and movement of one tends to lag behind movement of the other.  The View is rendered by the app, but the Surface is composited by SurfaceFlinger, so window movement has to get passed through the Window Manager.  TextureView doesn't have this problem, but does introduce some additional overhead.</p>

<p>If you want it to look good when scrolling, you'll probably want a TextureView.</p>

<p>It is possible for multiple EGL contexts to share data, and it is possible to use a single EGL context to render to more than one surface.  <a href="https://github.com/google/grafika" rel="nofollow">Grafika</a> has examples of both ("show + capture camera" uses GLSurfaceView and a shared EGL context, "continuous capture" uses SurfaceView and a single EGL context; both activities render to an on-screen surface and an off-screen surface).</p>

<p>All hardware-accelerated Views do their own EGL context management, and there's no reason to mess with that if you're rendering onto SurfaceView or TextureView.</p>

<p>If you're planning to draw multiple versions of the live camera preview in real time, you'll get the best performance by rendering them all yourself in a single scene.  Rendering multiple TextureViews will be less efficient.  Depending on your UI choices, this might mean handling the item drawing and scrolling yourself instead of handing it off to ListView.  (At the very least, you'd want to ensure that you're only live-updating the thumbnails that are actually on screen.)</p>
