<p>One way to do this is to have <code>myMap["my_method_hello"]("Tim", 25)</code> return a proxy object that defines <code>operator int()</code>, <code>operator std::string()</code>, etc for each type you want it to return. Another way is to have the proxy object define explicit <code>.asInt()</code>, <code>.asString()</code> methods for each type.</p>

<p>The overloaded operator technique can get confusing if the target type isn't explicit in the source code (for example, if you're passing the result to a function). Similarly, the proxy type is likely to confuse template functions you pass it to, and won't be able to easily select an overloaded function if the candidate set includes functions taking both <code>int</code> and <code>std::string</code> (or other types the proxy auto-converts to. So I recommend providing the <code>.asInt()</code>, etc. functions in addition to any operators.</p>

<p>You can also spell the <code>.asInt()</code>, etc. functions like <code>template&lt;typename T&gt; as()</code> and use explicit specialization to define new conversions. The only downside to this is that the source code gets a bit harder to read.</p>
