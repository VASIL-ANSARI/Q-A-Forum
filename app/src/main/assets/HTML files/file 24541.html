<p>The simplest example I can think of:</p>

<pre><code>std::optional&lt;int&gt; try_parse_int(std::string s)
{
    //try to parse an int from the given string,
    //and return "nothing" if you fail
}
</code></pre>

<p>The same thing might be accomplished with a reference argument instead (as in the following signature), but using <code>std::optional</code> makes the signature and usage nicer.</p>

<pre><code>bool try_parse_int(std::string s, int&amp; i);
</code></pre>

<p>Another way that this could be done is <strong>especially bad</strong>:</p>

<pre><code>int* try_parse_int(std::string s); //return nullptr if fail
</code></pre>

<p>This requires dynamic memory allocation, worrying about ownership, etc. - always prefer one of the other two signatures above.</p>

<hr>

<p>Another example:</p>

<pre><code>class Contact
{
    std::optional&lt;std::string&gt; home_phone;
    std::optional&lt;std::string&gt; work_phone;
    std::optional&lt;std::string&gt; mobile_phone;
};
</code></pre>

<p>This is extremely preferable to instead having something like a <code>std::unique_ptr&lt;std::string&gt;</code> for each phone number! <code>std::optional</code> gives you data locality, which is great for performance.</p>

<hr>

<p>Another example:</p>

<pre><code>template&lt;typename Key, typename Value&gt;
class Lookup
{
    std::optional&lt;Value&gt; get(Key key);
};
</code></pre>

<p>If the lookup doesn't have a certain key in it, then we can simply return "no value."</p>

<p>I can use it like this:</p>

<pre><code>Lookup&lt;std::string, std::string&gt; location_lookup;
std::string location = location_lookup.get("waldo").value_or("unknown");
</code></pre>

<hr>

<p>Another example:</p>

<pre><code>std::vector&lt;std::pair&lt;std::string, double&gt;&gt; search(
    std::string query,
    std::optional&lt;int&gt; max_count,
    std::optional&lt;double&gt; min_match_score);
</code></pre>

<p>This makes a lot more sense than, say, having four function overloads that take every possible combination of <code>max_count</code> (or not) and <code>min_match_score</code> (or not)!</p>

<p>It also <strong>eliminates</strong> the <strong>accursed</strong> "Pass <code>-1</code> for <code>max_count</code> if you don't want a limit" or "Pass <code>std::numeric_limits&lt;double&gt;::min()</code> for <code>min_match_score</code> if you don't want a minimum score"!</p>

<hr>

<p>Another example:</p>

<pre><code>std::optional&lt;int&gt; find_in_string(std::string s, std::string query);
</code></pre>

<p>If the query string isn't in <code>s</code>, I want "no <code>int</code>" -- <strong>not</strong> whatever special value someone decided to use for this purpose (-1?).</p>

<hr>

<p>For additional examples, you could look at the <code>boost::optional</code> <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html">documentation</a>. <code>boost::optional</code> and <code>std::optional</code> will basically be identical in terms of behavior and usage.</p>
