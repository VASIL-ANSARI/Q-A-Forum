<p>Your arange function could return the values you compute for x,y and z directly, what would save a lot of computations. The round function is not needed at all. You run the loop 5*800*500 = 2.000.000 times and every time you divide by 100 and round. Better do it like this:</p>

<pre><code>    for y in np.arange(0,5,1):
        for x in np.arange(0,8,0.01):
            for z in np.arange(5,0,-0.01):
</code></pre>

<p>Collect the points in one array like in the following code. </p>

<pre><code>    point = np.array([x,y,z])
    a1 = np.array([a.p1.x,a.p1.y,a.p1.z])
    a2 = np.array([a.p2.x,a.p2.y,a.p2.z])
    a3 = np.array([a.p3.x,a.p3.y,a.p3.z])

    if np.linalg.norm(point-a1) &lt;=1:
        print point
        continue
    if np.linalg.norm(point-a2) &lt;=1:
        print point
        continue
    if np.linalg.norm(point-a3) &lt;=1:
        print point
        continue
</code></pre>

<p>It is better to store the points directly as numpy arrays in your object specifiedPoints[key] and not to collect them again and again in every loop. This would get you this code:</p>

<pre><code>    point = np.array([x,y,z])

    if np.linalg.norm(point-a.p1) &lt;=1:
        print point
        continue
    if np.linalg.norm(point-a.p2) &lt;=1:
        print point
        continue
    if np.linalg.norm(point-a.p3) &lt;=1:
        print point
        continue
</code></pre>
