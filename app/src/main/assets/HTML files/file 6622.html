<p>The biggest benefit is to create a contract between libraries. In your instance where you're enforcing IFoo, you're saying that your class will accept any class that implements the IFoo contract. This means your class doesn't care how IFoo works or is implemented, just that it IS implemented. This has the benefit of allowing changes to the inherited classes or the function of IFoo methods without breaking dependent classes. This is fundamental in <a href="http://www.google.com/url?sa=t&amp;source=web&amp;cd=3&amp;ved=0CD0QFjAC&amp;url=http%3A%2F%2Fmsdn.microsoft.com%2Fen-us%2Fmagazine%2Fcc163739.aspx&amp;ei=eXL6TP2rNoSgnwfz6bXJCg&amp;usg=AFQjCNHA25tX8jHMGshtXclf8xsAFzG1qw&amp;sig2=qEF5o1mCNKAop8BmtkYdlQ" rel="nofollow">Dependency Injection</a>.</p>

<p><strong>Edit</strong><br />
The reason that an interface is different from inheriting a class is that an interface implements specific methods whereas a class is not required to do so:</p>

<pre><code>public interface IFoo
{
    public int myMethod1();
    public void myMethod2(); 
}

public class A : IFoo
{
    // This class MUST IMPLEMENT myMethod1 and myMethod2 to be valid
    // This means any class that relies on A can depend that myMethod1
    // and myMethod2 will be there. That's the contract, and it can't
    // be broken because the interface requires it.
}

======

public class IFoo
{
    public int myMethod1();
}

public class A : IFoo
{
    // There is now no requirement that myMethod1 or myMethod2 is
    // implemented. Any class inheriting or relying on A no longer
    // can trust that it IS implemented. If a consuming dll is 
    // relying on class A and there is no interface involved, the
    // consuming classes can't trust that the base class won't change.
}
</code></pre>

<p>In developing applications for smaller groups or applications, this is less of a problem. You have your base class and you know what it does. You know who and when it changes, so it's easier to manage. In larger applications and development groups, this structure breaks down because you have class libraries developed in one group consumed by another group, and if the dll is changed without the interface contract, it could create a lot of problems. The interface becomes an architectural promise of sorts, and in large development environments becomes a critical component of development. This is not the only reason for them, but IMO it's the biggest/best reason.</p>
