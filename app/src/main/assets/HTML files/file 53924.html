<p>It says that you're already in a existing rails application.</p>

<p>So either:</p>

<ol>
<li>this is true, and you're doing something that isn't supported; or</li>
<li>this is false, and this error is wrong.</li>
</ol>

<p>Lets look at the code that shows this error.</p>

<p>By using:</p>

<pre><code>$ grep -r 'initialize a new Rails application within the directory' ~/.gem/ruby/2.1.0/gems/
</code></pre>

<p>I found that this error is shown in:</p>

<pre><code>/home/martin/.gem/ruby/2.1.0/gems/railties-4.2.5.2/lib/rails/commands/commands_tasks.rb:        puts "Can't initialize a new Rails application within the directory of another, please change to a non-Rails directory first.\n"
</code></pre>

<p>By opening that file I found that this is in the function <code>exit_with_initialization_warning!</code>, which is called just once:</p>

<pre><code>def new
  if %w(-h --help).include?(argv.first)
    require_command!("application")
  else
    exit_with_initialization_warning!
  end
end
</code></pre>

<p>So how does this work? When you type <code>rails</code> it loads up <code>/home/martin/.gem/ruby/2.1.0/gems/railties-4.2.5.2/bin/rails</code>, which does <code>require "rails/cli"</code>, which looks like:</p>

<pre><code>require 'rails/app_rails_loader'

# If we are inside a Rails application this method performs an exec and thus
# the rest of this script is not run.
Rails::AppRailsLoader.exec_app_rails

require 'rails/ruby_version_check'
Signal.trap("INT") { puts; exit(1) }

if ARGV.first == 'plugin'
  ARGV.shift
  require 'rails/commands/plugin'
else
  require 'rails/commands/application'
end
</code></pre>

<p>The logic to find if this is a rails directory is:</p>

<pre><code>def exec_app_rails
  original_cwd = Dir.pwd

  loop do
    if exe = find_executable
      contents = File.read(exe)

      if contents =~ /(APP|ENGINE)_PATH/
        exec RUBY, exe, *ARGV
        break # non reachable, hack to be able to stub exec in the test suite
      elsif exe.end_with?('bin/rails') &amp;&amp; contents.include?('This file was generated by Bundler')
        $stderr.puts(BUNDLER_WARNING)
        Object.const_set(:APP_PATH, File.expand_path('config/application', Dir.pwd))
        require File.expand_path('../boot', APP_PATH)
        require 'rails/commands'
        break
      end
    end

    # If we exhaust the search there is no executable, this could be a
    # call to generate a new application, so restore the original cwd.
    Dir.chdir(original_cwd) and return if Pathname.new(Dir.pwd).root?

    # Otherwise keep moving upwards in search of an executable.
    Dir.chdir('..')
  end
end
</code></pre>

<p>This seems pretty fool-proof to me, and can't be "fooled" with just the existence of a <code>bin/rails</code> in some parent directory; it also looks at the contents, and actually <em>runs</em> the file (which would require various dependencies and would most likely error out unless you're in a rails directory).</p>

<p>We see that <code>require 'rails/commands'</code> is called <em>only</em> when we're running inside a rails directory, so this is why the <code>new</code> function always throws an error (the <code>%w(-h --help).include?(argv.first)</code> is there to allow running <code>rails new -h</code> from inside rails apps).</p>

<p>When you're outside a rails directory, the <code>new</code> command in implemented in <code>commands/application.rb</code>, which is called from <code>cli.rb</code> (which runs <code>Rails::Generators::AppGenerator.start</code>).</p>

<p><strong>Conclusion</strong>: You're almost certainly creating a rails application inside a rails application. Don't do this.</p>
