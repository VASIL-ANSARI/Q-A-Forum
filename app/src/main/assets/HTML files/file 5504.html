<p>Well, firstly the common splitting identifier is the <code>*</code>, so firstly I would explode by them:</p>

<pre><code>$segments = explode('*', $text);
</code></pre>

<p>Then I see that there will be spaces because at the sides of the <code>*</code> we have spaces, so they need to be trimmed away, but firstly we need to set up a blank array to store the new cleaned data in.</p>

<pre><code>$results = array();
</code></pre>

<p>Then loop through each segment, trimming and check for the <code>@</code> symbol:</p>

<pre><code>$first = true;
foreach($segments as $segment) {
    // Strip trailing/leading whitespace and line breaks
    $segment = trim(segment);

    if ($first === true) {
        // Name: The very first line would be the name.
        $results['name'] = $segment;
        $first = false;
    } else {
        // Params and return
        if ($segment[0] === "@") {
            // Find the first space, usually after @xxxx text
            $pos = strpos(' ', $segment);

            // Get the name of the var so param for @param
            $index = substr($segment, 1, $pos);
            // rest of the string
            $value = substr($segment, $pos+1);
            switch($index) {
                case 'param':
                case 'params':
                    $results['params'][] = $value;
                    break;
                case 'return':
                case 'returns':
                    $params['return'] = $value;
                    break;
                default:
                    $params[$index] = $value;
                    break;
            }
        }
    }
}
</code></pre>

<p>Hopefully you will be able to see what this code bock is doing, but if not a little explanation below.</p>

<p>After exploding the string into segments, we start looping through them. There's a small <code>$first</code> variable that is set to true as default so we know if it's the first iteration of the array, the reason being the first line is the function name and it does not have have an <code>@</code> symbol to denote a named line.</p>

<p>After that, we check to see if the character at index 0 is equal to <code>@</code>. If so, then we cut out the string so that:</p>

<pre><code>@param fun ...
0123456789 ...
^     ^
</code></pre>

<p>So that we cut from 1 to the index if the space (6) and this would give 'param'.</p>

<p>After creating a switch statement, we just use <code>substr()</code> to cut off only the part of the string after the <code>param</code> prefix (offset 6 in this case).</p>

<p>This code more than likely will not work as it's untested, but it's written to show you how to go about it. I hope it gets you going.</p>

<p>Some other resources:</p>

<ul>
<li><p><em>[Is there a good (standalone) PHPDoc parser class or function in PHP?][2]</em></p></li>
<li><p><em>[How to parse a phpDoc style comment block with PHP?][3]</em></p></li>
</ul>

<p>I really don't think a regular expression is the way to go, but if that's really what you want to do then <em>[How to parse a phpDoc style comment block with PHP?][6]</em> is the way to go.</p>
