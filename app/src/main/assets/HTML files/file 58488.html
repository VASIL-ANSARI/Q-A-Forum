<p>The default here:</p>

<pre><code>template&lt;typename T = XXX&gt;
inline Vector3&lt;T&gt;::operator std::string() const { ... }
</code></pre>

<p>doesn't matter at all, there's no deduction going on at this point, and <code>T</code> is already defined. It's legal, but it's just noise. </p>

<p>Now, you can't partially specialize a member function in a class template either, but we can dispatch on traits:</p>

<pre><code>template &lt;class T&gt;
class Vector3 {
public:
    // ...
    operator std::string() const {
        return as_string(std::is_arithmetic&lt;T&gt;{});
    }

private:
    std::string as_string(std::true_type ) {
        // implementation for arithmetic types
    }

    std::string as_string(std::false_type ) {
        // implementation for non-arithmetic types
    }
};
</code></pre>
