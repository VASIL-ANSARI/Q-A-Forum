<p>It sounds like you're really looking at splitting up your <code>interface</code> into multiple interfaces, and change the method that accepts this <code>interface</code> as a parameter, so that it will instead accept the <code>interface</code> that it requires (e.g. <code>InterfaceOne</code>) in order to call a method in that <code>interface</code> (e.g. <code>function1()</code>). Another method might want to call <code>function2()</code>, in which case it will accept an argument of type <code>InterfaceTwo</code>.</p>

<p>If however you need to always call both methods of the <code>interface</code> in your method, but you don't always need to call any code in the methods of that <code>interface</code>, what you're looking at instead is the following.</p>

<p>Instead of creating a new anonymous class of type <code>interfacename</code>, you could use a base class with empty method bodies, and simply override the ones you need. Methods implemented by the abstract base class are essentially optional, while those that are not implemented are required methods.</p>

<p>This is a very common pattern in Java development.</p>

<pre><code>public interface InterfaceName {

    void function1();
    void function2();

}

public abstract class BaseInterfaceName implements InterfaceName {

    public void function1() {
    }

    public void function2() {
    }

}

public class MyClass {

    public void myMethod() {
        myMethodWithInterface(new BaseInterfaceName() {
            @Override
            public void function2() {
                System.out.println("function2");
            }
        })
    }

    public void myMethodWithInterface(InterfaceName intf) {
        intf.function1();
        intf.function2();
    }

}
</code></pre>
