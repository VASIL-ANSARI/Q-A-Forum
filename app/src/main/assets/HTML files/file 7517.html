<p>I would probably create a set of the names from <code>ActiveItems</code> and then use that:</p>

<pre><code>var activeNames = new HashSet&lt;string&gt;(activeItems.Select(x =&gt; x.Name));
var itemsWithActiveNames = items.Where(x =&gt; activeNames.Contains(x.Name))
                                .ToList();
</code></pre>

<p>Another option is to use a join, e.g. with a query expression:</p>

<pre><code>var query = from activeItem in activeItems
            join item in items on activeItem.Name equals item.Name
            select item;
</code></pre>

<p>Note that this will give duplicate <code>item</code> values if there are multiple <code>ActiveItem</code> values with the same name. Another alternative join, which doesn't have this problem but is a bit clumsier:</p>

<pre><code>var query = from item in items
            join activeItem in activeItems 
                on item.Name equals activeItem.Name
                into g
            where g.Any()
            select item;
</code></pre>

<p>Note that all of these will avoid the O(N * M) check for names - they'll all use hash tables behind the scenes, to give an O(N + M) complexity.</p>
