<p>The <code>x and y or z</code> idiom doesn't work if <code>y</code> is <a href="http://docs.python.org/reference/expressions.html#boolean-operations" rel="nofollow">falsy</a>. You can swap the condition to make it work nonetheless:</p>

<pre><code>def fibonacci(n):
    return n &gt;= 2 and fibonacci(n-1) + fibonacci(n-2) or n
</code></pre>

<p>However, as of Python 2.5 (released 6 years ago), we have proper <a href="http://docs.python.org/whatsnew/2.5.html#pep-308" rel="nofollow">conditional expressions</a> and don't need the <code>and/or</code> hack any longer:</p>

<pre><code>def fibonacci(n):
    return n if n &lt; 2 else fibonacci(n-1) + fibonacci(n-2)
</code></pre>

<p>Now this has an exponential runtime complexity. If you want to be efficient, use the <code>O(n)</code> algorithm:</p>

<pre><code>def fibonacci(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a
</code></pre>

<p>Or even write a generator to yield all the numbers and only take as much as you need.</p>
