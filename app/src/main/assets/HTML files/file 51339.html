<p>You can not do this because the 'generic type erasure'. The generic information is lost after the compile time, after generate the bytecode class file there are not any generic information and at compile time you have not specified the concrete type for generic T.</p>

<p>See this code for type erasure check, the result is Equal:</p>

<p>A</p>

<pre><code>package a;


public class A {

    public static void main(String[] args) {

        final B&lt;String, Integer&gt; b = new B&lt;String, Integer&gt;();

        b.check();
    }

}
</code></pre>

<p>B</p>

<pre><code>package a;

import java.util.ArrayList;
import java.util.List;

public class B&lt;T, E&gt; {

    public void check(){

        final List&lt;T&gt; listT = new ArrayList&lt;T&gt;();
        final List&lt;E&gt; listE = new ArrayList&lt;E&gt;();

        if (listT.getClass().equals(listE.getClass())) {
            System.out.println("Equal");
        }
    }

}
</code></pre>

<p>See this link too: <a href="http://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#cannotCatch" rel="nofollow">http://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#cannotCatch</a></p>
