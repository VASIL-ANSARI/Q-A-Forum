<p>Just add <code>const</code>. This </p>

<pre><code>extern const BitChar BitFont[];
...
const BitChar BitFont[] = {
    B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,2, // 32 - Space
    B10000000,B10000000,B10000000,B10000000,B10000000,B00000000,B10000000,B00000000,1, // 33 - !
    ...
    B00000000,B00000000,B11100000,B11100000,B11100000,B00000000,B00000000,B00000000,3, // 127 - Unknown
};
</code></pre>

<p>should work perfectly fine in C. (Assuming that your compiler knows what these <code>B00000000</code> identifiers mean.)</p>

<p>This will also work perfectly fine in C++. The only potential for error in the C++ version is based on C++-specific properties of <code>const</code>.  If the definition does not see the declaration, then you have to specify the explicit <code>extern</code> in the definition as well</p>

<pre><code>extern const BitChar BitFont[] = {
    B00000000
    ...
</code></pre>

<p>because in C++ <code>const</code> objects have <em>internal</em> linkage by default. However, if the declaration already contains the <code>extern</code> and the definition can see the declaration, then that <code>extern</code> in the definition is optional.</p>

<p>The error message you quoted suggests that somewhere in your code you are trying to initialize a reference of type <code>BitChar &amp;</code> (aka <code>unsigned char (&amp;)[9]</code>) with a const-qualified <code>BitChar</code> array. This will not work, since it violates the basic rules of const-correctness. The reference has to become const-qualified as well, i.e. it has to change to <code>const BitChar &amp;</code> (aka <code>const unsigned char (&amp;)[9]</code>).</p>
