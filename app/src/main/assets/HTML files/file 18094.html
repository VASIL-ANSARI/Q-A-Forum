<p>Of course, the most obvious thing to do would be to use threads instead of processes. That would solve the whole problem with no effort at all.</p>

<p>Other than that, short of hacking the runtime library of your compiler to replace its memory management, you can actually override "operator new" for a class, and/or you can provide a global one. This will let you replace "new" calls with your own memory allocation code. You could use a global flag that you set before making CGAL calls and reset afterwards, to tell the memory allocator what memory heap you want to use (you will obviously have to make some form of heap management for the shared memory).</p>

<p>Overriding the new operator will only work for "new" calls, of course. Anything that gets allocated e.g. through malloc() or some system call isn't going to go through your code. You could try to provide your own malloc() and free() calls (functions contained in object files are preferred over functions from libraries) to see if this can work, but these would probably have to deal with the operating system for the memory management since you loose the library functions. It's definitely going to be messy.</p>
