<p>The best solution for my scenario appears to be bypass the base <strong>OnAuthorization</strong> completely. Since I have to authenticate each time cookies and caching the principle are not of much use. So here is the solution I came up with:</p>

<pre><code> public override void OnAuthorization(HttpActionContext actionContext)
 {

     string username;
     string password;
     if (GetUserNameAndPassword(actionContext, out username, out password))
     {
         if (Membership.ValidateUser(username, password))
         {
             if (!isUserAuthorized(username))
                 actionContext.Response = new HttpResponseMessage(System.Net.HttpStatusCode.Forbidden);
         }
         else
         {
             actionContext.Response = new HttpResponseMessage(System.Net.HttpStatusCode.Unauthorized);
         }
     }
     else
     {
         actionContext.Response = new HttpResponseMessage(System.Net.HttpStatusCode.BadRequest);
     }
 }
</code></pre>

<p>I developed my own method for validating the roles called <strong>isUserAuthorized</strong> and I am not using the base <strong>OnAuthorization</strong> any more since it checks the current <strong>Principle</strong> to see if it <strong>isAuthenticated</strong>.  <strong>IsAuthenticated</strong> only allows gets so I am not sure how else to set it, and I do not seem to need the current <strong>Principle</strong>.  Tested this out and it works fine.</p>

<p>Still interested if anyone has a better solution or can see any issues with this this one.</p>
