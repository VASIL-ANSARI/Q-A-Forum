<p>The value in the prototype has no meaning to the compiler and is ignored! The function declared above is equivalent to</p>

<pre><code>void somefunc(float* arg);
</code></pre>

<p>and</p>

<pre><code>void somefunc(float arg[]);
</code></pre>

<p>When using C++ you can deal with the size restriction at compile-time using references. If you really mean to have an array of 10 <code>float</code>s, you can pass it by reference which will enforce that the size is correct:</p>

<pre><code>void somefunc(float (&amp;arg)[10]);
</code></pre>

<p>However, this will prevent bigger arrays from being passed. You can play with a template forwarding function if you want to pass bigger arrays:</p>

<pre><code>void somefunc_intern(float* arg);
template &lt;int Size&gt;
typename std::enable_if&lt;(10 &lt;= Size)&gt;::type
somefunc(float (&amp;arg)[Size]) {
    somefunc_intern(arg);
}
</code></pre>

<p>Of course, this won't generate a warning but an error if a too small array is passed.</p>
