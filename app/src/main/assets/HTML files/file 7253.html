<p><code>Application.Current.Resources["MainColor"] = ...</code> stores your object in the key <code>"MainColor"</code>, if that key <strong>already exists</strong> that is. To add a new resource with that key use <code>Resources.Add(key,object)</code>.</p>

<p>Should look like this:</p>

<pre><code>Application.Current.Resources.Add("MainColor", Infragistics.Windows.Ribbon.RibbonBrushKeys["RibbonGroupCollapsedNormalBorderDarkFillKey"]);
</code></pre>

<p><strong>Edit:</strong> As your resource apparently does exist this is a matter of <a href="http://msdn.microsoft.com/en-us/library/ms173105.aspx" rel="nofollow">casting</a></p>

<pre><code>(Application.Current.Resources["MainColor"] as SolidColorBrush).Color =
     (Infragistics.Windows.Ribbon.RibbonBrushKeys[Infragistics.Windows.Ribbon.RibbonGroupCollapsedNormalBorderDarkFillKey] as SolidColorBrush).Color;
</code></pre>

<p>You XAML points towards the key being used in the resource hierarchy, depending on where you want to add that key (i.e. code-context) and where the original key is defined you might be able to get the color via <code>FindResource</code>:</p>

<pre><code>(Application.Current.Resources["MainColor"] as SolidColorBrush).Color =
    (FindResource(Infragistics.Windows.Ribbon.RibbonGroupCollapsedNormalBorderDarkFillKey) as SolidColorBrush).Color;
</code></pre>

<p>Alternatively you can overwrite the whole brush with a new one which loads its color from your other resource. Note that in both cases this change is done <strong>by value</strong>, if either resource changes the other one is <em>not</em> affected.</p>
