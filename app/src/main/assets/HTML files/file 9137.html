<p>The problem is that you are using image's size rather than the image view's frame size. Image seems to be much larger than its image view so when you use the image's size the other image's size ends up being much smaller in comparison although it is still the correct size. You can modify your snippet to this â</p>

<pre><code>UIGraphicsBeginImageContext(image.frame.size);  

// Draw the users photo  
[image.image drawInRect:CGRectMake(0, 0, image.frame.size.width, image.frame.size.height)];  
[overlay.image drawInRect:overlay.frame];

UIImage * resultingImage = UIGraphicsGetImageFromCurrentImageContext();

UIGraphicsEndImageContext();
</code></pre>

<p><strong>Avoiding loss of quality</strong></p>

<p>While the above method leads to loss of resolution, trying to draw the parent image in its proper resolution might have an unwanted effect on its child image i.e. if the overlay wasn't of high resolution itself then it can end being stretchy. However you can try this code to draw it in the parent image's resolution (untested, let me know if you've problems ) â</p>

<pre><code>float verticalScale = image.image.size.height / image.frame.size.height;
float horizontalScale = image.image.size.width / image.frame.size.width;

CGRect overlayFrame = overlay.frame;
overlayFrame.origin.x *= horizontalScale;
overlayFrame.origin.y *= verticalScale;
overlayFrame.size.width *= horizontalScale;
overlayFrame.size.height *= verticalScale;

UIGraphicsBeginImageContext(image.image.size);  

// Draw the users photo  
[image.image drawInRect:CGRectMake(0, 0, image.image.size.width, image.image.size.height)];  
[overlay.image drawInRect:overlayFrame];

UIImage * resultingImage = UIGraphicsGetImageFromCurrentImageContext();

UIGraphicsEndImageContext();
</code></pre>
