<p>You do not need to use recursion for path reconstruction (in fact, you never <em>have to</em> use recursion in Java, it just happens to be a lot more convenient to use it to solve certain problems, including this one).</p>

<p>In order to be able to figure out the shortest path in addition to the length, you need a second 2D array that stores successors of your node in the path. Take a look at <a href="http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm#Path_reconstruction" rel="nofollow">this article</a>, the array I am talking about is called <code>next</code> in their pseudocode.</p>

<p>Recall that the logic of the algorithm goes as follows: "if you can get from <code>i</code> to <code>j</code> through <code>k</code> faster than going from <code>i</code> to <code>j</code> through any previously discovered path, then use the path though <code>k</code> as your current shortest path". Now all you need to do is to store the decision to go through <code>k</code> in some other array, like this:</p>

<pre><code>if (path[i][k] + path[k][j] &lt; path[i][j]) {
    path[i][j] = path[i][k]+path[k][j];
    next[i][j] = k;
}
</code></pre>

<p>Once Floyd-Warshal finishes, you can reconstruct the path from <code>i</code> to <code>j</code> by first reconstructing the path from <code>i</code> to <code>k</code> and then from <code>k</code> to <code>j</code>.</p>

<pre><code>String GetPath (int i, int j) {
    if (path[i][j] == INF) return "no path";
    int intermediate = next[i][j];
    if (intermediate &lt; 0) return " ";
    return GetPath(i,intermediate) + intermediate + GetPath(intermediate,j);
}
</code></pre>
