<p>It is possible, you have to use the flag PTHREAD_PROCESS_SHARED:</p>

<pre><code>pthread_mutexattr_t mattr;
pthread_mutexattr_init(&amp;mattr);
pthread_mutexattr_setpshared(&amp;mattr, PTHREAD_PROCESS_SHARED);


// Init the shared mem barrier
if ( (rv = pthread_mutex_init(&amp;nshared, &amp;mattr)) != 0 ) {
      fprintf(stderr, "Failed to initiliaze the shared mutex.\n");
      return rv;
}
</code></pre>

<p>Where the variable <code>nshared</code> is mapped in shared memory.</p>

<p>Take a look at this <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutexattr_setpshared.html" rel="nofollow">documentation</a>. Also, keep in mind that the default value for the mutex is to not share it among processes.</p>

<p>also, take a look at these posts <a href="http://stackoverflow.com/questions/2389353/do-pthread-mutexes-work-across-threads-if-in-shared-memory/2390670#2390670">post1</a> <a href="http://stackoverflow.com/questions/20325146/share-condition-variable-mutex-between-processes-does-mutex-have-to-locked-be">post2</a></p>

<p>Bonus code to chek the status of the mutex:</p>

<pre><code>void showPshared(pthread_mutexattr_t *mta) {
  int           rc;
  int           pshared;

  printf("Check pshared attribute\n");
  rc = pthread_mutexattr_getpshared(mta, &amp;pshared);

  printf("The pshared attributed is: ");
  switch (pshared) {
  case PTHREAD_PROCESS_PRIVATE:
    printf("PTHREAD_PROCESS_PRIVATE\n");
    break;
  case PTHREAD_PROCESS_SHARED:
    printf("PTHREAD_PROCESS_SHARED\n");
    break;
  default :
    printf("! pshared Error !\n");
    exit(1);
  }
  return;
}
</code></pre>

<p>I don't remember were I took this piece of code ... found it! <a href="https://www.ibm.com/support/knowledgecenter/ssw_i5_54/apis/users_57.htm" rel="nofollow">here</a> is the source of hal knowledge.</p>
