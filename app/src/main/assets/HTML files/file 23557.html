<p>Don't do that to yourself.  Rather than making one data-structure per attribute, define a sphere object to hold all of a sphere's attributes.  Write synchronized methods so that multiple threads don't alter a single sphere at once.</p>

<p>Here's a quick and dirty start:</p>

<pre><code>//Sphere.java
public class Sphere {
    private float[] position;
    private float[] mem; 
    private float[] velocity;

    public Sphere(float[] position, float[] mem,  float[] velocity) {
        this.position = position;
        this.mem = mem;
        this.velocity = velocity;
    }

    public synchronized float[] getPosition() {
        return position;
    }
    public synchronized float[] getVelocity() {
        return velocity;
    }

    public synchronized void move() {
        position[0]+=velocity[0];
        position[1]+=velocity[1];
    }
}
</code></pre>

<p>Then you might initialize your data somewhere else:</p>

<pre><code>    int sphereCount = 30;
    List&lt;Sphere&gt; spheres = new ArrayList&lt;Sphere&gt;();
    Random rand = new Random();
    for( int i = 0; i &lt; sphereCount; i++) {
        spheres.add(
            new Sphere(
                new float[]{20*rand.nextFloat(), 20*rand.nextFloat()}, //position
                new float[]{20*rand.nextFloat(), 20*rand.nextFloat()}, //mem
                new float[]{2*rand.nextFloat(), 2*rand.nextFloat()} //velocity
            )
        );
    }
</code></pre>

<p>Again, this is just rough, vague code, and I haven't given it much thought.  The big idea here is to use objects to describe 'things' so that you can put all the nitty-gritty code to manipulate them in those objects and out of the rest of your code.  </p>

<p>As for the <code>synchronized</code> keyword, it means that everything within that method happens either completely before or completely after any other synchronized method call on that same object.</p>
