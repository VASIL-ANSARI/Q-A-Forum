<p>This will work - provided you actually fully evaluate the query.  </p>

<p>However, the behavior will be very odd, and would be something I would strongly avoid.  Since the out parameter is being used directly within the query, the behavior will be fairly normal here (provided you don't do anything else with this), but that is specific to this use case, not a general "rule" with using out mixed with LINQ.</p>

<p>The problem is that LINQ's deferred execution will cause the out parameter to get set, but only when you <em>use</em> the resulting enumerable, not when you declare it.  This can cause very unexpected behavior, and lead to difficult to maintain and understand software.</p>

<p>I would personally just write a separate method, and use it to allow your query to be written as:</p>

<pre><code>var q = from type in types 
        from property in type.GetProperties() 
        let propertyName = GetName(property)
        let nullable = GetIsNullable(property)
        // ...
</code></pre>

<p>This is much more clear, and less prone to mistakes and errors.  It will also work with parallelization (ie: PLINQ via <code>.AsParallel()</code>) and other techniques if somebody tries to change this later. </p>
