<p>You can pass in a <code>$rootScope</code> to a service, but it's generally not a good idea to pollute your <code>$rootScope</code>, however your problem in this particular case is that no digest was forced and thus your controllers <code>$scope</code> was unaware of the change. In the code you posted if you wrap your <code>$rootScope.error</code> inside a <code>$rootScope.$apply()</code> things will work fine. But a callback is much cleaner.</p>

<p>I suggest you pass a callback into the service method, and set your scope variable inside the callback:</p>

<pre><code>login:function(email,password,callback){
    $http({
            // send credentials to server, ask if there's a match
        })
        .success(function(data) {
         callback(data.match);
        })
}
</code></pre>

<p>and in your controller:</p>

<pre><code>$scope.logIn = function() {
    loginServcie.login($scope.email,$scope.password,function(dataIsMatched){
   //you now have the result of call, and dataIsMatched is true or false
    $scope.error = !dataIsMatched;
})
}
</code></pre>
