<p>I think C32 hit on the problem (although he answered it in a comment for some reason).  Since tuples are immutable, you have to create a new tuple each time rather than appending to an existing tuple.  This gives you quadratic behaviour, and if you make your tuple 10 times longer it'll take 100 times as long.  Your code probably would have finished in about 100 minutes or so.  For example:</p>

<pre><code>def build_tup(n):
    td = ()
    for i in range(n):
        td = td + ((1,2),)
    return td    

def add_to_list(n):
    td = []
    for i in range(n):
        td += (1,2),
    return td
</code></pre>

<p>gives quadratic behaviour for <code>build_tup</code>:</p>

<pre><code>&gt;&gt;&gt; %timeit build_tup(100)
10000 loops, best of 3: 21.7 Âµs per loop
&gt;&gt;&gt; %timeit build_tup(1000)
1000 loops, best of 3: 1.7 ms per loop
&gt;&gt;&gt; %timeit build_tup(10000)
10 loops, best of 3: 165 ms per loop
</code></pre>

<p>but effectively linear behaviour for <code>add_to_list</code>:</p>

<pre><code>&gt;&gt;&gt; %timeit add_to_list(100)
100000 loops, best of 3: 3.64 Âµs per loop
&gt;&gt;&gt; %timeit add_to_list(1000)
10000 loops, best of 3: 35 Âµs per loop
&gt;&gt;&gt; %timeit add_to_list(10000)
The slowest run took 4.96 times longer than the fastest. This could mean that an intermediate result is being cached 
1000 loops, best of 3: 348 Âµs per loop
</code></pre>
