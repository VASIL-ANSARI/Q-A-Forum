<p>Your mistake is that you just blindly shift characters and don't use your <code>letters</code> array to wrap around. </p>

<pre><code>def play_pass(str, n)
  letters = ('a'..'z').to_a

  str.chars.map do |x| 
    if letters.include?(x.downcase)
      idx = letters.index(x)
      new_idx = (idx + n) % letters.length
      letters[new_idx]
    else
      x
    end
  end.join

end

play_pass('ay1', 2) # =&gt; "ca1"
</code></pre>

<p>The key to success here is the <a href="https://en.wikipedia.org/wiki/Modulo_operation" rel="nofollow"><strong>modulo</strong> operator (%)</a>. We use to get an index of a substitution character from <code>letters</code> array. It guarantees that the index will always be within bounds of the array. Instead of going past the end, it wraps around. </p>

<p>Read up on it. It's useful in many places.</p>
