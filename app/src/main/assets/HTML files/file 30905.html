<p>So, it is totally not clear to me why your XOR function is so complicated. If I understand your problem correctly, the XOR function can be simply written as:</p>

<pre><code>UNIT XOR( vector&lt;UNIT&gt; list )
{
    // Find the length of the longest unit
    int maxLength = 0;
    for (int i=0; i&lt;list.size(); ++i)
        maxLength = std::max(maxLength, list[i].size);

    // Allocate space for the new unit.
    // Note that calloc will zero out any allocated space.
    UNIT xorUnit;
    xorUnit.size = maxLength;
    xorUnit.content = (char *) calloc(maxLength + 1, sizeof(char)); 

    // xor each member of the list with xorUnit
    for (int i = 0; i&lt;list.size(); ++i)
        for (int j=0; j&lt;list[i].size; ++j)
            xorUnit.content[j] ^= list[i].content[j];

    return xorUnit;
}
</code></pre>

<p>This produces an output of:</p>

<pre><code>Vector(0): hallo 5
Vector(1): servus 6
Vector(2): moin 4
XOR: vkwts 6


Vector(0): moin 4
Vector(1): hallo 5
Vector(2): vkwts 6
XOR: servus 6
</code></pre>

<p><strong>Note</strong>: You are quite lucky with this example that you get printable characters back. In general, this type of code will produce lots of characters that are <strong>not</strong> considered printable characters. For example, <code>"Hi" ^ "Ho" =&gt; "\0\9"</code>, neither of which are printable characters.</p>
