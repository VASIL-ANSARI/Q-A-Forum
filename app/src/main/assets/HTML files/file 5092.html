<p>Here are my two cents: <br><br>
<em>Thread</em>: When you feel comfortable enough that you can handle all the IDEAL number of threads. This is almost always never the case. It is hear for people that would cry out that I want REAL threads not the .NET thread pool. If you don't want to ask this question : <a href="http://stackoverflow.com/questions/1718465/optimal-number-of-threads-per-core">Optimal number of threads per core</a> don't go with thread. 
<br><br><em>ThreadPool</em>: This was the .net answer to in the box solution for the optimal number of threads. The API however was not the best. For new projects use TPL. 
<br><br><em>BackgroundWorker</em>: If you are want to start threading from your GUI app with easy post backs. This provides the simplest API. 
<br><br><em>Dispatcher</em> : Like you said. Just for calling back to the GUI thread. It is Vital for that. There is no other way you could use it anyways without some obscure code I do not know. <br>Note: It is not called delegate. Delegate is what you pass into a Dispatcher to dispatch. 
<br><br><em>Task Parallel Library</em> : This came with .net 4. Recommended that you use it for new projects. 
<br><br><em>Parallel</em>: No you got this wrong. Parallel.For will not return control until the entire loop is complete. It is there as a convenience when all you want to do is execute a loop in parallel. Great for mapping an input to an output e.g x -> x*2. Using Parallel.For (or ForEach) you can run this on multiple threads (again the number is decided by .NET) to run the loop faster. Check out: <a href="http://www.lovethedot.net/2009/02/parallelfor-deeper-dive-parallel.html" rel="nofollow">http://www.lovethedot.net/2009/02/parallelfor-deeper-dive-parallel.html</a></p>
