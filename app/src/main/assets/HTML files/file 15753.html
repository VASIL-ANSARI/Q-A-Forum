<p>I have it now, not just the most beautiful way af solved, but since I had used URGENT a solution, I've realized now so ... The "replace" I like not, but I think it's just quicker than assuming you have the eternally long XML data into a new node first, then to copy the original ... 
If someone thinks to do better, please'm thankful for every tip.</p>

<pre><code>public static string SearchToChangeXML(string input, int changetype = 0)
{
    //Replace -.- | no time, hope later more time to make better... But it works
    input = input.Replace("&lt;_asd_cas01d0005p0000013303Response", "&lt;_asd_cas01d0005p0000013203");
    input = input.Replace("&lt;/_asd_cas01d0005p0000013303Response&gt;", "&lt;/_asd_cas01d0005p0000013203&gt;");
    for (int i = 20; i &lt;= 40; i++)
    {
        input = input.Replace("&lt;Ec_" + i.ToString() + "Ki&gt;", "&lt;Ic_" + i.ToString() + "Ki&gt;");
        input = input.Replace("&lt;/Ec_" + i.ToString() + "Ki&gt;", "&lt;/Ic_" + i.ToString() + "Ki&gt;");
        input = input.Replace("&lt;Ec_" + i.ToString() + "Ki /&gt;", "&lt;Ic_" + i.ToString() + "Ki /&gt;");
        input = input.Replace("&lt;Ec_" + i.ToString() + "Ki/&gt;", "&lt;Ic_" + i.ToString() + "Ki/&gt;");
    }

    XmlDocument xml = new XmlDocument();
    xml.LoadXml(input);
    XmlNode dp = xml.DocumentElement;
    for (int i = 0; i &lt; dp.ChildNodes.Count; i++)
    {
        //Things i dont need (not all Variables are present in other Class)
        if (dp.ChildNodes[i].Name == "Ic_38Ki" || dp.ChildNodes[i].Name == "Ic_39Ki" || dp.ChildNodes[i].Name == "EtMessages" ||
                dp.ChildNodes[i].Name == "EvCeeRequestId" || dp.ChildNodes[i].Name == "EvStatusCode")
            dp.ChildNodes[i].RemoveAll();

    }
    using (var stringWriter = new StringWriter())
    using (var xmlTextWriter = XmlWriter.Create(stringWriter))
    {
        xml.WriteTo(xmlTextWriter);
        xmlTextWriter.Flush();
        return stringWriter.GetStringBuilder().ToString();
    }
}
</code></pre>
