<p><code>self::</code>, <code>parent::</code> and <code>static::</code> are special cases. They always act as if you'd do a non-static call and support also static method calls without throwing an <code>E_STRICT</code>.</p>

<p>You will only have problems when you use the class' names instead of those relative identifiers.</p>

<p>So what will work is:</p>

<pre><code>class x { public function n() { echo "n"; } }
class y extends x { public function f() { parent::n(); } }
$o = new y;
$o-&gt;f();
</code></pre>

<p><em>and</em></p>

<pre><code>class x { public static function n() { echo "n"; } }
class y extends x { public function f() { parent::n(); } }
$o = new y;
$o-&gt;f();
</code></pre>

<p><em>and</em></p>

<pre><code>class x { public static $prop = "n"; }
class y extends x { public function f() { echo parent::$prop; } }
$o = new y;
$o-&gt;f();
</code></pre>

<p>But what won't work is:</p>

<pre><code>class x { public $prop = "n"; }
class y extends x { public function f() { echo parent::prop; } } // or something similar
$o = new y;
$o-&gt;f();
</code></pre>

<p>You still have to address properties explicitly with <code>$this</code>.</p>
