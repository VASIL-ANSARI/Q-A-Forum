<p>Your design is likely wrong if you are doing this, but you already have it correct. </p>

<pre><code>var child1a = child1 as child;
</code></pre>

<p>Does <strong>not</strong> instantiate a new object. It simply downcasts to the <code>child</code> type. Downcasting is a code-smell, so consider re-working your design to where this isn't necessary.</p>

<p>Also, <code>as</code> will return <code>null</code> if the cast fails, so you should be checking it:</p>

<pre><code>var child1a = child1 as child;

if (child1a != null)
  Console.WriteLine(child1a.age);
</code></pre>

<p>Finally, you never <em>actually</em> used the dictionary in your code, you likely wanted to do:</p>

<pre><code>var child1a = dictionary[1] as child;

if (child1a != null)
  Console.WriteLine(child1a.age);
</code></pre>

<p>To your update, that loop will <em>never</em> work (nor should it). Not all the objects in your collection are guaranteed to have the "age" property.</p>

<p>With respect to your loop, you <em>can</em> do this:</p>

<pre><code>foreach (child item in dictionary.Values)
{
    ...
}
</code></pre>

<p>or:</p>

<pre><code>foreach (KeyValuePair&lt;int, parent&gt; kvp in dictionary)
{ 
   if (kvp.Value is child)
   {
       child item = (child)kvp.Value;
       ...
   }
}
</code></pre>

<p>Which will pull out the <code>child</code> items from your values collection and let you use them as such. If thats all you are doing though, a <code>Dictionary</code> is <em>way</em> overkill here.</p>
