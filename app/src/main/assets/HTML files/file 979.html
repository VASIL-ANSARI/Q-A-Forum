<p>/EDIT: I see, an own iterator is actually necessary here (I misread the question first). Still, I'm letting the code below stand because it can be useful in similar circumstances.</p>

<p><hr /></p>

<p>Is an own iterator actually necessary here? Perhaps it's sufficient to forward all required definitions to the container holding the actual Points:</p>

<pre><code>// Your class `Piece`
class Piece {
private:
    Shape m_shape;

public:

    typedef std::vector&lt;Point&gt;::iterator iterator;
    typedef std::vector&lt;Point&gt;::const_iterator const_iterator;

    iterator begin() { return m_shape.container.begin(); }

    const_iterator begin() const { return m_shape.container.begin(); }

    iterator end() { return m_shape.container.end(); }

    const_iterator end() const { return m_shape.const_container.end(); }
}
</code></pre>

<p>This is assuming you're using a <code>vector</code> internally but the type can easily be adapted.</p>
