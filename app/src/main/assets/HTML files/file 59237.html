<p>As KerrekSB <a href="http://stackoverflow.com/questions/39926180/operator-is-ambiguous-for-stdstring/39926203#comment67135954_39926180">suggested</a>, you can use</p>

<pre><code>s = std::string(x);
</code></pre>

<p>Alternatively, you can perform a cast:</p>

<pre><code>s = (std::string) x;
// or
s = static_cast&lt;std::string&gt;(x);
</code></pre>

<p>A third alternative (which I would hope not to see in the wild very often due to readability concerns) is to access the operator directly:</p>

<pre><code>s = x.operator std::string();
</code></pre>

<hr>

<p>If you're willing to make the tradeoff of a slightly different API (and fixing any potential breakages) you can do what Roberto <a href="http://stackoverflow.com/a/39926241/510036">suggested</a> and force the explicit casting of <em>just</em> the <code>const char *</code> type operator:</p>

<pre><code>class X
{
public:
  explicit operator const char*() const {
    return "a";
  }
  operator std::string() {
    return "c";
  }
};
</code></pre>

<p>This tells the compiler to only allow <em>implicit</em> conversions to <code>std::string</code>, and requires you do explicitly cast to <code>const char *</code> when you want to invoke that particular operator.</p>

<hr>

<p>One last thing to note: if you are designing other classes or methods that would consume this particular class, another thing to try is to reverse the way they're used by providing an overload for <code>class X</code> rather than converting <code>X</code> to something else.</p>

<p>Always good to consider alternative ways for your API to work.</p>
