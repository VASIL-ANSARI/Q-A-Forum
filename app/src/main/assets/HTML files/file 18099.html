<p>OK - Sorted.</p>

<p>There were 2 main problems</p>

<p>1/ I was only adding CustomerName and not the CheckListItem so </p>

<p><code>ObservableCollection&lt;Customer&gt;</code>  should be <code>ObservableCollection&lt;CheckedListItem&lt;Customer&gt;&gt;</code></p>

<p>2/ Same again adding the customers. </p>

<p><code>new Customer() { CustomerName = "Kelly Smith" }</code> should be <code>new CheckedListItem&lt;Customer&gt;(new Customer() { CustomerName = "Kelly Smith" })</code></p>

<p>So full working code is</p>

<p><strong>Settings.Designer.cs</strong></p>

<pre><code>using System.Collections.ObjectModel;
namespace WpfApplication1.Properties {


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "10.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default {
            get {
                return defaultInstance;
            }
        }

        [global::System.Configuration.UserScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public ObservableCollection&lt;WpfApplication1.TestSettings.CheckedListItem&lt;WpfApplication1.TestSettings.Customer&gt;&gt; Customers
        {
            get
            {
                return ((ObservableCollection&lt;WpfApplication1.TestSettings.CheckedListItem&lt;WpfApplication1.TestSettings.Customer&gt;&gt;)(this["Customers"]));
            }
            set
            {
                this["Customers"] = value;
            }
        }
    }
}
</code></pre>

<p><strong>TestSettings.xaml</strong></p>

<pre><code>&lt;Window x:Class="WpfApplication1.TestSettings"
        xmlns:local="clr-namespace:WpfApplication1.Properties"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="TestSettings" Height="300" Width="300" Closing="Window_Closing"&gt;
    &lt;Grid&gt;
        &lt;ListBox ScrollViewer.VerticalScrollBarVisibility="Auto" ItemsSource="{Binding Source={x:Static local:Settings.Default}, Path=Customers, Mode=TwoWay}" Margin="12,22,12,79"&gt;
            &lt;ListBox.ItemTemplate&gt;
                &lt;DataTemplate&gt;
                    &lt;CheckBox IsChecked="{Binding IsChecked}" Content="{Binding Path=Item.CustomerName}" /&gt;
                &lt;/DataTemplate&gt;
            &lt;/ListBox.ItemTemplate&gt;
        &lt;/ListBox&gt;
    &lt;/Grid&gt;
&lt;/Window&gt;
</code></pre>

<p><strong>TestSettings.xaml.cs</strong></p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using System.ComponentModel;
using System.Collections.ObjectModel;

namespace WpfApplication1
{
    /// &lt;summary&gt;
    /// Interaction logic for TestSettings.xaml
    /// &lt;/summary&gt;
    public partial class TestSettings : Window
    {

        public ObservableCollection&lt;CheckedListItem&lt;Customer&gt;&gt; Customers
        {
            get;
            set;
        }


        public class Customer
        {
            public string CustomerName { get; set; }
        }

        public TestSettings()
        {
            InitializeComponent();

            if (Properties.Settings.Default.Customers == null)
            {
                Properties.Settings.Default.Customers = new ObservableCollection&lt;CheckedListItem&lt;Customer&gt;&gt;
                { 
                        new CheckedListItem&lt;Customer&gt;(new Customer() { CustomerName = "Kelly Smith" }),
                        new CheckedListItem&lt;Customer&gt;(new Customer() { CustomerName = "Joe Brown" }),
                        new CheckedListItem&lt;Customer&gt;(new Customer() { CustomerName = "Herb Dean" }),
                        new CheckedListItem&lt;Customer&gt;(new Customer() { CustomerName = "fg4" }),
                        new CheckedListItem&lt;Customer&gt;(new Customer() { CustomerName = "fg5" }),
                        new CheckedListItem&lt;Customer&gt;(new Customer() { CustomerName = "fg6" }),
                        new CheckedListItem&lt;Customer&gt;(new Customer() { CustomerName = "fg7" }),
                        new CheckedListItem&lt;Customer&gt;(new Customer() { CustomerName = "fg8" }),
                        new CheckedListItem&lt;Customer&gt;(new Customer() { CustomerName = "fg9" }),
                        new CheckedListItem&lt;Customer&gt;(new Customer() { CustomerName = "fg10" }),
                        new CheckedListItem&lt;Customer&gt;(new Customer() { CustomerName = "fg11" }),
                        new CheckedListItem&lt;Customer&gt;(new Customer() { CustomerName = "fg12" }),
                        new CheckedListItem&lt;Customer&gt;(new Customer() { CustomerName = "fg13" }),
                        new CheckedListItem&lt;Customer&gt;(new Customer() { CustomerName = "fg14" })

                };
                Properties.Settings.Default.Save();

            }
            else
            {
                //var a = Properties.Settings.Default.Customers;
                //Customers = ObservableCollection&lt;CheckedListItem&lt;&gt;&gt;;

            }
        }

        public class CheckedListItem&lt;T&gt; : INotifyPropertyChanged
        {
            public event PropertyChangedEventHandler PropertyChanged;

            private bool isChecked;
            private T item;

            public CheckedListItem()
            { }

            public CheckedListItem(T item, bool isChecked = false)
            {
                this.item = item;
                this.isChecked = isChecked;
            }

            public T Item
            {
                get { return item; }
                set
                {
                    item = value;
                    if (PropertyChanged != null) PropertyChanged(this, new PropertyChangedEventArgs("Item"));
                }
            }


            public bool IsChecked
            {
                get { return isChecked; }
                set
                {
                    isChecked = value;
                    if (PropertyChanged != null) PropertyChanged(this, new PropertyChangedEventArgs("IsChecked"));
                }
            }
        }

        private void Window_Closing(object sender, CancelEventArgs e)
        {
            Properties.Settings.Default.Save();
        }
    }
}
</code></pre>

<p>EDIT: It appears that this does work but as the <code>Settings.Designer.cs</code> has been amended the settings don't persist between separate run-times as generic types cannot be stored in the settings. Rather than change Settings.Designer.cs I've ended up created and XML string which gets saved in the settings as a string and then build ObservableCollection> from the XML and vice versa.</p>
