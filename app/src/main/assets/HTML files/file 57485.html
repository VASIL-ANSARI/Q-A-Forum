<p>Look at this loop in the second piece of code:</p>

<pre><code>for (int i = 0; i &lt; 5; i++)
{
  std::cout &lt;&lt; *p &lt;&lt; " ";
  x = *p;
  p++;
  *p = x + 1;   // &lt;--- Here
}
</code></pre>

<p>Notice that in this line, you write to the memory address currently pointed at by <code>p</code>. Since you always increment <code>p</code> and then write to it, you end up writing off past the end of the region that you allocated for <code>p</code>. (If we imagine <code>pOrig</code> as a pointer to where <code>p</code> initially points, then this writes to <code>pOrig[1]</code>, <code>pOrig[2]</code>, <code>pOrig[3]</code>, <code>pOrig[4]</code>, and <code>pOrig[5]</code>, and that last write is past the end of the region). This results in undefined behavior, meaning that literally anything can happen. This is Bad News.</p>

<p>Additionally, <code>delete[]</code> assumes that you are passing in a pointer to the very first element of the array that you allocated. Since you've incremented <code>p</code> so many times in that loop, you're trying to <code>delete[]</code> a pointer that wasn't at the base of the allocated array, hence the issue.</p>

<p>To fix this, don't write to <code>p</code> after incrementing it, and store a pointer to the original array allocated with <code>new[]</code> so that you can free that rather than the modified pointer <code>p</code>.</p>
