<p>For siblings, you generally need to move whatever state they both need to reference up into a common parent component and pass it down as props (or sideways into an external storage object - see react-training's <a href="https://github.com/ryanflorence/react-training/blob/gh-pages/lessons/04-less-simple-communication.md" rel="nofollow">Less Simple Communication</a> lesson for an example) and pass it to them as props.</p>

<p>e.g. if the component rendering <code>Box</code> and <code>Mover</code> had the following state:</p>

<pre><code>getInitialState: function() {
  return {
    x: 0,
    y: 0
  }
}
</code></pre>

<p>Then you could pass <code>Mover</code> a callback function which updates it:</p>

<pre><code>handleMove: function(x, y) {
  this.setState({x: x, y: y})
}

// within render() - you could also pass x and y if Mover needs them
&lt;Mover onMove={this.handleMove}/&gt;

// within Mover
this.props.onMove(newX, newY)
</code></pre>

<p>If you passed this state to <code>Box</code> as props, it wouldn't necessarily need an explicit <code>move()</code> method (depending on what it does) but could either use the props in its <code>render()</code> method (which would automatically re-render when the props change), or you could react to the <code>x</code> and <code>y</code> values changing by detecting the change with a <code>componentWillReceiveProps()</code> method:</p>

<pre><code>// within render()
&lt;Box x={this.state.x} y={this.state.y}/&gt;

// within Box
componentWillReceiveProps: function(nextProps) {
  if (nextProps.x !== this.props.x || nextProps.y !== this.props.y) {
    // ...
  }
}
</code></pre>
