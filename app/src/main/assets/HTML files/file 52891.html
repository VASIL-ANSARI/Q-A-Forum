<p>I searched this question on google and found very interesting answer on <a href="http://googleresearch.blogspot.in/2006/06/extra-extra-read-all-about-it-nearly.html" rel="nofollow">http://googleresearch.blogspot.in/2006/06/extra-extra-read-all-about-it-nearly.html</a></p>

<p>Here is example:</p>

<pre><code>1:     public static int binarySearch(int[] a, int key) {
2:         int low = 0;
3:         int high = a.length - 1;
4:
5:         while (low &lt;= high) {
6:             int mid = (low + high) / 2;
7:             int midVal = a[mid];
8:
9:             if (midVal &lt; key)
10:                 low = mid + 1
11:             else if (midVal &gt; key)
12:                 high = mid - 1;
13:             else
14:                 return mid; // key found
15:         }
16:         return -(low + 1);  // key not found.
17:     }
</code></pre>

<blockquote>
  <p>The bug is in this line:</p>

<pre><code>int mid =(low + high) / 2;
</code></pre>
  
  <p>In Programming Pearls Bentley says that the analogous line "sets m to the average of l and u, truncated down to the nearest integer." On the face of it, this assertion might appear correct, but it fails for large values of the int variables low and high. Specifically, it fails if the sum of low and high is greater than the maximum positive int value (231 - 1). The sum overflows to a negative value, and the value stays negative when divided by two. In C this causes an array index out of bounds with unpredictable results. In Java, it throws ArrayIndexOutOfBoundsException.</p>
  
  <p>This bug can manifest itself for arrays whose length (in elements) is 230 or greater (roughly a billion elements). This was inconceivable back in the '80s, when Programming Pearls was written, but it is common these days at Google and other places. In Programming Pearls, Bentley says "While the first binary search was published in 1946, the first binary search that works correctly for all values of n did not appear until 1962." The truth is, very few correct versions have ever been published, at least in mainstream programming languages.</p>
</blockquote>

<p>So what's the best way to fix the bug? Here's one way:</p>

<pre><code> int mid = low + ((high - low) / 2);
</code></pre>
