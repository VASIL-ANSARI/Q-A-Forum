<p>Name lookup works from inner scopes outwards so you don't need to go from the top down each time. Omitting the leading <code>::</code> effectively gives you lookup that backtracks until it finds the name that you are looking for so <code>f::p</code> effectively backtracks until it finds an <code>f</code> and then looks for a <code>p</code> inside that <code>f</code>. You don't need a full <code>::f::p()</code> although in your case, as <code>f</code> is in the global namespace, there isn't a huge typing difference.</p>

<p>Consider this example, where the saving for calling <code>::f::g::f::p()</code> is more obvious.</p>

<pre><code>namespace f {
    void p();
    namespace g {
        void p();
        namespace f {
            void p();
            namespace h {
                void p()
                {
                    f::p();   // same as ::f::g::f::p()
                    ::f::p(); // fully qualified
                    g::p();   // same as ::f::g::p();
                    p();      // recurse!
                }
            }
        }
    }
}
</code></pre>

<p>There is no explicit way of forcing lookup to exlcude the immediate scope level (block or namespace, no <code>..::p()</code> or <code>^::p()</code> or something.</p>
