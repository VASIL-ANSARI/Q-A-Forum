<p>You are iterating over a range of the <em>current</em> length of <code>lst</code>. Every time you do <code>lst.remove(lst[k])</code>, the <code>lst</code> gets shorter, so the range you were using becomes unsuitable. For example, if you start with 8 elements, it goes from indices of <code>0</code> to <code>7</code> inclusive, but if you remove an element, the last index will then be <code>6</code>, not <code>7</code>.</p>

<p>The easiest way to fix this is to simply create a new <code>list</code>:</p>

<pre><code>lst = []
for i in range(1,13196):
    if 13195 % i == 0:
        lst.append(i)

result = lst[:] # create a copy to work with
for k in range(len(lst)):
    for j in range(1,lst[k]):
        if lst[k] % j != 0 and lst[k] in result: # check that it's there before removal
            result.remove(lst[k])

print(result)
</code></pre>

<p>That said, this code eliminates every number which cannot be evenly divided by every positive integer smaller than that number, which understandably produces a result of <code>[1]</code>. If that's not what you wanted, you'll have to take another look at your algorithm.</p>
