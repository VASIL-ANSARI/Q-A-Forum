<p>Try using interfaces. <code>interface</code> works like <code>abstract class</code> but can only contain method or property definitions that are to be "fleshed out" by the classes that implement them. Classes can then implement as many interfaces as you need. Take a look at how <code>IEnumerable</code> allows lists, dictionaries, and arrays to all share a common set of methods, allowing them to be used in <code>foreach</code>, or how <code>IDisposable</code> allows a class to be declared in <code>using</code>.</p>

<p>I made a set of ink textbox controls that are all supposed to get their display style settings from the user config of multiple applications, so I made them grab those settings from an IInkInputSettings interface and implemented that interface in all of the applications' UserConfig classes.</p>

<p>Alternatively, you could achieve global configuration by way of a Singleton:</p>

<pre><code>public class GlobalConfig{
    /* your configuration properties here */
    private static GlobalConfig instance = null;
    public static GlobalConfig Instance{
        get{
            if(instance == null) instance=new GlobalConfig();
            return instance;
        }
    }
    private GlobalConfig(){ /* set default property values */ }
}
</code></pre>

<p>This is better than a static class with static members, because it is only instantiated the first time you use it.</p>
