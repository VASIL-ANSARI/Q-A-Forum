<blockquote>
  <p>Forward iterator requirements do not include the requirements of output iterators</p>
</blockquote>

<p>This sounds backwards. OutputIterators need to satisfy <em>fewer</em> criteria than ForwardIterators.
(Forward iterators should be reusable after increment, i.e. incrementing them twice should yield the same result).</p>

<p>Therefore, it is ok <em>provided</em> that the output iterator <em>stays</em> valid until the algorithm completes. IOW:</p>

<pre><code>auto outit = std::begin(v2);
std::advance(outit, v1.size()); // or: std::distance(std::begin(v1), std::end(v2))
// outit should still be valid here
</code></pre>

<p><strong>Edit</strong> To the comment:</p>

<blockquote>
  <h3>Â§ 24.2.1</h3>
  
  <p>Iterators that further satisfy the requirements of output iterators are called <code>mutable</code> <code>iterators</code>. Nonmutable iterators are referred to as <code>constant</code> <code>iterators</code>.</p>
</blockquote>

<p>Now, let me find the bit that ties this together saying <code>vector::begin()</code> returns <em>mutable</em> Random Access iterator.</p>

<p>For info</p>

<blockquote>
  <h3>Â§ 24.2.5 Forward iterators [forward.iterators]</h3>
  
  <p><sup>1</sup> A class or pointer type X satisfies the requirements of a forward iterator if</p>
  
  <ul>
  <li>X satisfies the requirements of an input iterator (24.2.3),</li>
  <li>X satisfies the DefaultConstructible requirements (17.6.3.1),</li>
  <li>if X is a mutable iterator, reference is a reference to T; if X is a const iterator, reference is a reference to const T,</li>
  <li>the expressions in Table 109 are valid and have the indicated semantics, and</li>
  <li>objects of type X offer the multi-pass guarantee, described below.</li>
  </ul>
</blockquote>
