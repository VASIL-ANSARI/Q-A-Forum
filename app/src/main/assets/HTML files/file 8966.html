<p>That's a pretty dense way of saying "don't add an observer to the set itself, add an observer to the class that contains the set":</p>

<pre><code>[myObjWithASetAsIvar addObserver:self
                      forKeyPath:@"nameOfIvarHoldingTheSet"
                         options:NSKeyValueObservingOptionNew
                         context:nil];
</code></pre>

<p>The one tricky bit is that you need to wrap all your accesses to the set in order for the proper notifications to be sent. In the class containing the set:</p>

<pre><code>[self willChangeValueForKey:@"nameOfIvarHoldingTheSet"];
// Do something with the set
[self didChangeValueForKey:@"nameOfIvarHoldingTheSet"];
</code></pre>

<p>There are also two notification methods specifically for sets: <a href="http://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Protocols/NSKeyValueObserving_Protocol/Reference/Reference.html#//apple_ref/doc/uid/20002299-BABHJAAC"><code>willChangeValueForKey:withSetMutation:usingObjects:</code></a> and <a href="http://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Protocols/NSKeyValueObserving_Protocol/Reference/Reference.html#//apple_ref/occ/instm/NSObject/didChangeValueForKey%3awithSetMutation%3ausingObjects%3a"><code>didChangeValueForKey:withSetMutation:usingObjects:</code></a>; you may find that they work better for you than the generic "value change" methods.</p>

<p>All that said, I believe that the solution you mentioned in your first paragraph, and <a href="http://stackoverflow.com/questions/1610422/kvo-on-an-nscountedset/1610918#1610918">outlined by Peter Hosey</a> in the question Girish linked to, is probably the best way to go.</p>
