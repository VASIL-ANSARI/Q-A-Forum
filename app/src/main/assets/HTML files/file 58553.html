<p>Rick -
If you're coming from the world of C++, the most important thing to remember is that any time you have an instance of a <code>class</code> or an <code>interface</code> in your code, this is roughly equivalent to a pointer in C++. We call these reference types. When you assign one class reference to another class reference variable, you are essentially doing exactly what you're asking to do, which is to have both variables point to the same object in memory. </p>

<p>Note there are also value types - these are the fundamental types (<code>int</code>, <code>char</code>, etc.) and <code>struct</code>s. For <code>struct</code>'s in particular, these behave very similarly to <code>struct</code>s in C++, (although it's not particularly easy to obtain the equivalent of a pointer to a <code>struct</code>).</p>

<p>It can be confusing because the <code>.</code> operator in C# doubles as the member accessor for both reference and value types. (There is no separate <code>-&gt;</code> operator like in C++). You just need to be aware of whether your data items are reference types or value types to determine whether an assignment (<code>=</code>) will result in the value being copied or the "pointer" (reference) being copied. Consequently, you cannot create <strong>copies</strong> of class instances by simply using the assignment operator <code>=</code> like you can in C++. For that you have to use the <code>Object.MemberwiseClone</code> method.</p>

<p>As observed in the comments, you don't need the <code>ref</code> in your situation because your method argument is already a "pointer". (The <code>ref</code> keyword is similar to the reference type flag (<code>&amp;</code>) in C++). However, if you wanted to change the value of the input parameter <code>new_demo</code> itself, to assign it to a <strong>different</strong> class instance, then you would indeed need the <code>ref</code>.</p>

<p>So, if it helps as you transition, you might want to just mentally imagine the C/C++ pointer flag <code>*</code> after every reference type variable you define and mentally picture the <code>-&gt;</code> when you see the <code>.</code> when you're accessing class members.</p>

<p>Hope this helps. As someone who also transitioned from C++ to C# I definitely can see how you would find it confusing at first. But in time you'll learn to speak both languages fluently. </p>

<p>Edit - I'd be curious to see your code that you say is not resulting in the right outcome. As has been pointed out, what you posted should work as written. </p>
