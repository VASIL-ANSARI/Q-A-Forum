<p>Use <code>std::function</code> to have a generic type-erased deleter.</p>

<p><a href="http://ideone.com/uVjZ3J" rel="nofollow">Ideone link</a></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;functional&gt;

template&lt;typename T&gt;
using TypeErasedUPtr = std::unique_ptr&lt;T, std::function&lt;void(T*)&gt;&gt;;

int main() 
{
    TypeErasedUPtr&lt;int&gt; p1{new int(5), [](int* x){ delete x; }};
    TypeErasedUPtr&lt;int&gt; p2{someAllocator&lt;int&gt;(5), [](int* x){ someDeallocator(x); }};

    // `p1` and `p2` have the same type, `TypeErasedUPtr&lt;int&gt;`.

    return 0;
}
</code></pre>

<hr>

<p>This works because <code>std::unique_ptr&lt;T, TDeleter&gt;</code> takes any callable <code>TDeleter</code> type that can be called with a <code>T*</code> parameter.</p>

<p>An <code>std::function&lt;void(T*)&gt;</code> fulfills that requirements, and also polymorphically wraps any kind of function with that signature at run-time (by paying a small run-time overhead price).</p>
