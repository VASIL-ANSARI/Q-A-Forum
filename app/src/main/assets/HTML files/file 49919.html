<p><em>"Why do we have to use j++ and i &lt; (array.length-j) as the test expression?"</em></p>

<p>The reason behind is at any time elements <code>array[ array.length -j ]</code> to <code>array[array.length - 1]</code> are already sorted.</p>

<hr>

<p>Example:  Say you have array of length <code>n</code>.  </p>

<p>So after the first iteration the biggest element will be placed at <code>array[n - 1]</code>.<br>
 So because the largest element is already sorted on the next iteration we will only sort array of length <code>n - 1</code>.</p>

<p>After the second iteration the second biggest element will be placed at <code>array[ n - 2]</code>. </p>

<p>So because the 1st largest and 2nd largest elements are already sorted on the next iteration we will only sort array of length <code>n - 2</code>, and so on...</p>

<p>The running time of the algorithm will be <a href="http://i.stack.imgur.com/jCP6v.gif" rel="nofollow"><img src="http://i.stack.imgur.com/jCP6v.gif" alt="n2/2"></a> which is <a href="http://i.stack.imgur.com/39Zgm.gif" rel="nofollow"><img src="http://i.stack.imgur.com/39Zgm.gif" alt="O(n2)"></a></p>

<p>As you said it we could have used <code>i &lt; (array.length - 1)</code> but we will be just doing a lot of work for nothing. If we do this the running time will be (n<em>n) which is O(n</em>n). But though the running time is still O(n*n) but it is obvious that <a href="http://i.stack.imgur.com/jCP6v.gif" rel="nofollow"><img src="http://i.stack.imgur.com/jCP6v.gif" alt="n2/2"></a> is smaller than <a href="http://i.stack.imgur.com/vp66O.gif" rel="nofollow"><img src="http://i.stack.imgur.com/vp66O.gif" alt="n2"></a>, hence the first one is efficient.</p>
