<p>Generally, it is better to avoid filters where you can, since they can be run on every digest, even if the list or filter criteria haven't changed. Instead, whenever the filter criteria changes, call a controller function to manually create a new filtered list for the view to bind to. This allows you to use any logic you like.</p>

<p>The basic structure then becomes:</p>

<pre><code>&lt;form&gt;
    &lt;input type="text" ng-model="searchRoom" ng-change="view.roomFilterChanged(searchRoom)"&gt;
&lt;/form&gt;

&lt;table class="table table-striped table-bordered"&gt;
    &lt;tr ng-repeat="room in view.filteredRooms track by room.id"&gt;
        &lt;td&gt;
            &lt;a ng-href="room/{{room.id}}"&gt;
                {{ view.building.code }}-{{ room.number }}
            &lt;/a&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</code></pre>

<p>And in your controller:</p>

<pre><code>function RoomViewController() {
   // (set this.rooms here)
   this.filteredRooms = this.rooms;
}

RoomViewController.prototype.roomFilterChanged = function (filterText) {
    this.filteredRooms = this.rooms.filter(function (room) {
         // (filter criteria here)
    });
};
</code></pre>

<p>The exact filter criteria has been left as an exercise for you.</p>

<p>Note that I used <code>track by</code> in the <code>ng-repeat</code> expression. This is a good practice to get into, since it improves performance of <code>ng-repeat</code> whenever the collection changes by allowing it to reuse an existing DOM node for a given item in the collection if it is still in the collection after the change. In this case, the <code>.id</code> is a good choice for a uniquely identifying property on each item.</p>
