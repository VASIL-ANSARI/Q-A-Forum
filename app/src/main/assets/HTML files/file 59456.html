<p>To answer this question you can <a href="http://gcc.godbolt.org/">look at the generated assembler code</a>. With -O2, x86-64 gcc 6.2 generates exactly the same code for both methods:</p>

<pre><code>addNumber(int, int):
    lea     eax, [rdi+rsi]
    ret
addNumber2(int, int):
    lea     eax, [rdi+rsi]
    ret
</code></pre>

<p>Only without optimization turned on, <a href="https://godbolt.org/g/Qfs4rO">there is a difference</a>:</p>

<pre><code>addNumber(int, int):
    push    rbp
    mov     rbp, rsp
    mov     DWORD PTR [rbp-20], edi
    mov     DWORD PTR [rbp-24], esi
    mov     edx, DWORD PTR [rbp-20]
    mov     eax, DWORD PTR [rbp-24]
    add     eax, edx
    mov     DWORD PTR [rbp-4], eax
    mov     eax, DWORD PTR [rbp-4]
    pop     rbp
    ret
addNumber2(int, int):
    push    rbp
    mov     rbp, rsp
    mov     DWORD PTR [rbp-4], edi
    mov     DWORD PTR [rbp-8], esi
    mov     edx, DWORD PTR [rbp-4]
    mov     eax, DWORD PTR [rbp-8]
    add     eax, edx
    pop     rbp
    ret
</code></pre>

<p>However, performance comparison without optimization is meaningless</p>
