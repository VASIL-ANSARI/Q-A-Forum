<pre><code>def integral2(function, n=1000, start=0, stop=100): return (float(1)/n) * sum([eval(function) for x in [(float(x) / n) for x in range(start*n, (stop*n)+1)]])
</code></pre>

<p>Note that there is a big difference between <code>integral</code> and <code>integral2</code>: <code>integral2</code> makes <code>(stop*n)+1-(start*n)</code> rectangles, while <code>integral</code> only makes <code>n</code> rectangles.</p>

<hr>

<pre><code>In [64]: integral('x**2')
Out[64]: 333833.4999999991
In [68]: integral2('x**2')
Out[68]: 333338.33334999956
</code></pre>

<hr>

<pre><code>In [69]: %timeit integral2('x**2')
1 loops, best of 3: 704 ms per loop

In [70]: %timeit integral('x**2')
100 loops, best of 3: 7.32 ms per loop
</code></pre>

<hr>

<p>Perhaps a more comparable translation of <code>integral</code> would be:</p>

<pre><code>def integral3(function, n=1000, start=0, stop=100): return (float(stop-start)/n) * sum([eval(function) for x in [start+(i*float(stop-start)/n) for i in range(n)]])

In [77]: %timeit integral3('x**2')
100 loops, best of 3: 7.1 ms per loop
</code></pre>

<hr>

<p>Of course, it should go with say that there is no purpose for making this a one-liner other than (perverse?) amusement :)</p>
