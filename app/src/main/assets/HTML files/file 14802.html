<p>From the <a href="http://msdn.microsoft.com/en-us/library/system.threading.threadabortexception.aspx">doc</a>:</p>

<blockquote>
  <p>When a call is made to the Abort method to destroy a thread, the
  common language runtime throws a ThreadAbortException.
  <strong>ThreadAbortException is a special exception that can be caught, but it
  will automatically be raised again at the end of the catch block</strong>. When
  this exception is raised, <strong>the runtime executes all the finally blocks
  before ending the thread</strong>. Because the thread can do an unbounded
  computation in the finally blocks or call Thread.ResetAbort to cancel
  the abort, there is no guarantee that the thread will ever end. If you
  want to wait until the aborted thread has ended, you can call the
  Thread.Join method. Join is a blocking call that does not return until
  the thread actually stops executing.</p>
</blockquote>

<p>So in other words, after your catch block for the <code>ThreadAbortException</code> executes, the exception is re-raised, so your last logger line (e.g. <code>Logger.d(TAG, "run() - ended")</code>)  never executes. But since the call to <code>this.doSoemthing</code> is in the catch block for the <code>ThreadAbortException</code>, it <strong>will</strong> execute.</p>

<p>Note also that, your <code>finally</code> block <strong>does</strong> execute (refer to doc above).</p>
