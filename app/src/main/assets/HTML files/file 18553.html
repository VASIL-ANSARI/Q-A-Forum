<p>How about using a Monitor with a timeout of 10 seconds. You can wake the sleeping thread up with the Pulse method of the Monitor class</p>

<p>Thread 1:</p>

<pre><code>Monitor.Wait(monitor, 10000);
</code></pre>

<p>Thread 2:</p>

<pre><code>Monitor.Pulse(monitor);
</code></pre>

<p>Or you could look at <a href="http://msdn.microsoft.com/en-us/library/system.threading.manualresetevent.waitone.aspx" rel="nofollow">ManualResetEvent.WaitOne</a>. Block the thread with a 10 second timeout. To unblock, signal an event.</p>

<p>EDIT:</p>

<p>The CancellationToken has a .WaitHandle property:</p>

<blockquote>
  <p>Gets a WaitHandle that is signaled when the token is canceled.</p>
</blockquote>

<p>You can wait on that handle to be signaled, with a timeout of 10 seconds?</p>
