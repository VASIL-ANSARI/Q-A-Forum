<p>For the Active Directory part, and if you're using .NET 3.5 or newer, you can look into the new <code>System.DirectoryServices.AccountManagement</code> namespace.</p>

<p>You can use a <code>PrincipalSearcher</code> and a "query-by-example" principal to do your searching:</p>

<pre><code>// create your domain context
PrincipalContext ctx = new PrincipalContext(ContextType.Domain);

// define a "query-by-example" principal - here, we search for a UserPrincipal 
UserPrincipal qbeUser = new UserPrincipal(ctx);

// create your principal searcher passing in the QBE principal    
PrincipalSearcher srch = new PrincipalSearcher(qbeUser);

List&lt;string&gt; userNames = new List&lt;string&gt;();

// find all matches
foreach(var found in srch.FindAll())
{
    // do whatever here - "found" is of type "Principal"
    if(!userNames.Contains(found.Name))
    {
       userNames.Add(found.Name);
    }
}
</code></pre>

<p>If you haven't already - absolutely read the MSDN article <a href="http://msdn.microsoft.com/en-us/magazine/cc135979.aspx" rel="nofollow">Managing Directory Security Principals in the .NET Framework 3.5</a> which shows nicely how to make the best use of the new features in <code>System.DirectoryServices.AccountManagement</code></p>

<p>For the local machine accounts, you can do basically the same thing - just with a different <code>PrincipalContext</code>:</p>

<pre><code>// create your local machine context
PrincipalContext local = new PrincipalContext(ContextType.Machine);
</code></pre>

<p>The rest of the code is identical - but your principal objects might have a lot fewer of the properties actually populated (since the local machine accounts don't have as much information stored for them as the Active Directory accounts) - but every principal definitely does have at least a <code>.Name</code> property!</p>
