<p>I don't think there's any way to create a Python <code>mmap</code> object out of a native mapping like this. The protocol isn't published, and neither is the internal format.</p>

<p>But of course <a href="http://hg.python.org/cpython/file/3.3/Modules/mmapmodule.c" rel="nofollow">the source</a> is available. So, as long as your mapping meets all the same criteria as one created by <code>new_mmap_object</code>, you could manually construct an <code>mmap_object</code> wrapping the information, and pass it back. (You can't <em>actually</em> access the <code>mmap_object</code> type, because it's not in any header file. But if you create an equivalent type, or just copy-and-paste the code, you'll be passing it around as a <code>PyObject *</code>, and as long as its type field points to the right type, it'll work.)</p>

<p>However, I'm not sure you need to do this. Do you really need an <code>mmap</code>, or just any buffer that you can treat as a string/list/iterator? Because the latter is a lot easier. For that, you can just create an <a href="http://docs.python.org/2/c-api/objbuffer.html#old-buffer-protocol" rel="nofollow">old-style buffer</a> or <a href="http://docs.python.org/2/c-api/buffer.html#buffers-and-memoryview-objects" rel="nofollow">new-style buffer</a> classâor, if you only need 2.7+, use the concrete <a href="http://docs.python.org/2/library/stdtypes.html#memoryview" rel="nofollow"><code>memoryview</code></a> type. Conceptually, it seems to make sense that you're returning a view of the mapped memory, rather than the mapping itself, but I can imagine some use cases where this might be inappropriate.</p>

<p>Finally, you can always create a new class that exposes whatever interface you want around your mapping, and make it as much (or as little) like <code>mmap</code> as you want.</p>
