<p>Two reasons:</p>

<ol>
<li><p>You can only implement <code>IEquatable&lt;T&gt;</code> for your own types... whereas you can specify an <code>IEqualityComparer&lt;T&gt;</code> for <em>any</em> type, whether you can modify it yourself or not.</p></li>
<li><p>There may be multiple ways of comparing a type for equality, but implementing <code>IEquatable&lt;T&gt;</code> only allows you to express one of them.</p></li>
</ol>

<p>A simple example of all of this would be strings - consider:</p>

<pre><code>string[] x = { "A", "B", "C" };
string[] y = { "A", "c" };

var bc = x.Except(y);
var justB = x.Except(y, StringComparer.OrdinalIgnoreCase);
</code></pre>

<p>We might want both results in different circumstances, which means we couldn't handle both with <code>IEquatable&lt;T&gt;</code>... and we can't change how <code>string</code> implements <code>IEquatable&lt;T&gt;</code> anyway. (You're not limited to <code>StringComparer</code> of course - you could write an equality comparer which just used the length of the string, for example.)</p>

<p>This isn't specific to LINQ, either - it's generally the case for any API which deals in equality, e.g. <code>HashSet&lt;&gt;</code>, <code>Dictionary&lt;,&gt;</code> etc.</p>
