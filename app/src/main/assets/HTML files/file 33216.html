<p>Looks like most of the performance difference in this example can be eliminated with the <code>raw=True</code> option:</p>

<pre><code>%timeit pd.rolling_mean(d, window=3, center=True)
1000 loops, best of 3: 281 Âµs per loop

%timeit d.apply(lambda x: pd.rolling_mean(x, window=3, center=True))
1000 loops, best of 3: 1.02 ms per loop
</code></pre>

<p>Now add the <code>Raw=True</code> option:</p>

<pre><code>%timeit d.apply(lambda x: pd.rolling_mean(x, window=3, center=True),raw=True)
1000 loops, best of 3: 289 Âµs per loop
</code></pre>

<p>Adding <code>reduce=False</code> gets you a minor speed-up since pandas doesn't have to guess the return:</p>

<pre><code>%timeit d.apply(lambda x: pd.rolling_mean(x, window=3,center=True),raw=True,reduce=False)
1000 loops, best of 3: 285 Âµs per loop
</code></pre>

<p>So in this case it looks like most of the performance difference is related apply converting each column to a <code>Series</code> and passing each series separately to rolling_mean. Having it use <code>Raw=True</code> has it just pass ndarrays.</p>
