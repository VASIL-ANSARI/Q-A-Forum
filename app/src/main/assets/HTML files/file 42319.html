<p>It is possible to do more or less what you want, though not all that straightforward. The key point is that the MXBean spec requires a CompositeData to have at least one item. You can satisfy this requirement by having a property <code>type</code> in your base class, which I've called <code>AnyCompositeData</code> here. The <code>type</code> property can also serve to decide how to translate back from <code>CompositeData</code> to the specific types such as your <code>Foo</code> and <code>Bar</code>. In the code here I stuffed everything into the <code>AnyCompositeData</code> class, though more realistically it would be separate classes of course. I only spelled out the concrete class <code>Foo</code> but it should be obvious how to extend the pattern to support other classes.</p>

<pre><code>public abstract class AnyCompositeData implements CompositeDataView {
  private final String type;

  public AnyCompositeData(String type) {
    this.type = type;
  }

  public String getType() {
    return type;
  }

  public static AnyCompositeData from(CompositeData cd) {
    switch ((String) cd.get("type")) {
      case "Foo":
        return new Foo((String) cd.get("foo"));
      default:
        throw new IllegalArgumentException("Don't know how to reconstruct: " + cd.get("type"));
    }
  }

  public static class Foo extends AnyCompositeData {
    private final String foo;

    Foo(String foo) {
      super("Foo");
      this.foo = foo;
    }

    public String getFoo() {
      return foo;
    }

    @Override
    public CompositeData toCompositeData(CompositeType ct) {
      try {
        String[] items = {"type", "foo"};
        OpenType&lt;?&gt;[] itemTypes = {SimpleType.STRING, SimpleType.STRING};
        Object[] itemValues = {"Foo", foo};
        CompositeType compositeType = new CompositeType("Foo", "Foo", items, items, itemTypes);
        return new CompositeDataSupport(compositeType, items, itemValues);
      } catch (OpenDataException e) {
        throw new RuntimeException(e);
      }
    }
  }

  @MXBean
  public interface Baz {
    AnyCompositeData f();
  }

  static class BazImpl implements Baz {
    @Override
    public AnyCompositeData f() {
      return new Foo("whatever");
    }
  }

  public static void main(String[] args) throws Exception {
    MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
    ObjectName objectName = new ObjectName("test:baz=baz");
    mbs.registerMBean(new BazImpl(), objectName);
    Baz bazProxy = JMX.newMXBeanProxy(mbs, objectName, Baz.class);
    AnyCompositeData result = bazProxy.f();
    assert result instanceof Foo;
    assert ((Foo) result).getFoo().equals("whatever");
  }
}
</code></pre>

<p>If you had a lot of subclasses like <code>Foo</code>, then you might want to consider using reflection in some way rather than having the <code>from(CompositeData)</code> method know about all the subclasses.</p>
