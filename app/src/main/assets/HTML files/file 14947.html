<p>There is a general pitfall with concurrent collections (not limited to .net) that people have to be aware of, which is that <strong>individual operations may be thread-safe, but sequences of operations are not atomic</strong>. What I mean by this is the following: assume this scenario, where I have a concurrent collection with a <code>Check</code> and an <code>Add</code> operation, both atomic. </p>

<p>What I want to do is check if a value exists and if not, add it. So I can write this:</p>

<pre><code>if(!collection.Check(value)) 
{
    collection.Add(value);
}
</code></pre>

<p>Although both operations are atomic, the above sequence is not, as a thread may be interrupted between the check and the add by another thread, which leads to inconsistent results. Thus, the entire sequence should be made atomic by wrapping it in a <code>lock</code> statement for example.</p>

<pre><code>lock(locker)
{
   if(!collection.Check(value)) 
   {
       collection.Add(value);
   }
}
</code></pre>
