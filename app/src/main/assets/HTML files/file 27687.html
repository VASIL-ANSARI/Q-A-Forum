<p>I have a recursive solution.</p>

<pre><code>def makeListAndFlatten(tree):
    treeList = makeList(tree)
    branchA = treeList[0]
    branchB = treeList[1]
    flatA = flatten(branchA)
    flatB = flatten(branchB)
    return [flatA, flatB]

def makeList(tree):
    if len(tree) == 2:
        return tree[1]
    else:
        for i in range(1,len(tree)):
                return [tree[len(tree)-1][1], makeList(tree[i])]

def flatten(nestedList):
        def aux(listOrItem):
            if isinstance(listOrItem, list):
                for elem in listOrItem:
                    for item in aux(elem):
                        yield item
            else:
                yield listOrItem
        return list(aux(nestedList))
</code></pre>

<p>If we run:</p>

<pre><code>makeListAndFlatten(tree)
</code></pre>

<p>This gives the result:</p>

<pre><code>[['a'], ['b', 'c', 'd']]
</code></pre>

<p>A list containing two lists with the leaves from the lower branches on both sides.</p>

<p><strong>EDIT:</strong></p>

<p>This code was based on the format given in the original question:</p>

<p>tree = (1.0, (0.5, (0.25, (0.125, 'd'),(0.125, 'c')), (0.25, 'b')), (0.5,'a'))</p>

<p>if the input format is changed then this will not work.</p>
