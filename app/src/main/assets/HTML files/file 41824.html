<pre><code>iinc 0 1 [i] 
</code></pre>

<p>This means that the local variable number 0, which is [i], is incremented by one. </p>

<p>The JVM Just-in-time compiler probably stores this local variable into the CPU register, therefore can just call INC assembly operation for each cycle of the loop. Which probably takes one CPU cycle on any modern CPU.</p>

<pre><code>iload_1 [i] 
iconst_1
iadd
istore_1 [i]
</code></pre>

<p>This one first puts local variable number 1, which is [i], on the stack. Then puts the constant 1 on the stack. Then adds two top elements on the stack and put the result on top of the stack. And the last step its copies the sum to the local variable number 1, which is [i].</p>

<p>Even if all these operations happen using L1 cache of the CPU and the local variable stored in the CPU register, it still will require many more cycles than the other case. </p>

<p>JVM Just-in-time compiler could be smart enough to recognize this as a pattern and replace with one-liner below. But people who initially wrote it would not have such motivation because their Java compiler would never output such code. Plus, JVM Just-in-time compiler has a very limited time budget that it has for all optimizations. So it can only check the finite list of optimization. </p>

<p>This seems like something that can be easily solved by fixing the Scala compiler.  </p>
