<p>Maybe the worker tries to connect to the database when starting (always) and throws an exception? Have you any errors logged by the worker?</p>

<p>Did you write your worker in Rails? Maybe write a shell script, which will assume the database is down when the worker cannot start?</p>

<p>UPDATE: In your stack trace there is the starting point: <code>script/workling_starling_client:17</code>. What is there, in the line 17?</p>

<p>As the first line (the exception message itself) says that "<i>real_connect': Can't connect to MySQL server on '10.223.2.50' (111) (Mysql::Error)</i>" then it will be enough if you wrap the line 17 (possibly with  a few more) in a "rescue" block, and check the error message whether it has the answer you are looking for:</p>

<p>(Of course, don't stop here. Continue your checks, as the lack of exception does <em>not</em> mean that the connection IS established)</p>

<pre><code>begin
  line_17_is_here
rescue =&gt; e
  if e.message =~ /Can't connect to MySQL/
    handle_your_no_connection_state
  else
    raise e
  end
end
</code></pre>

<p>The question is: can you handle the no-connection state without ActiveRecord?</p>
