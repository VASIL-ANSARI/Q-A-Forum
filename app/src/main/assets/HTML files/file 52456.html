<p>You can use a known <a href="http://stackoverflow.com/questions/24534782/how-do-skip-or-f-work-on-regex">SKIP-FAIL trick</a>. If you do not have nested parentheses nor braces, you can use</p>

<pre><code>/(
  \([^()]*\) # Match (...) like substrings
 |
  {[^{}]*}   # Match {...} like substrings
)
(*SKIP)(*F)  # Ignore the texts matched
|
(?:FIRSTNAME|LASTNAME|PHONE|EMAIL)/x
</code></pre>

<p>See the <a href="https://regex101.com/r/fO8zA5/1" rel="nofollow">regex demo</a></p>

<p>If you want to ignore the words like <code>PHONE</code>, <code>EMAIL</code> inside nested, balanced parentheses and braces, use a regex based on subroutines:</p>

<pre><code>/(?:
 (\((?&gt;[^()]|(?1))*\)) # Match (..(.)) like substrings
 |
 ({(?&gt;[^{}]|(?2))*})   # Match {{.}..} like substrings
)
(*SKIP)(*F)  # Ignore the texts matched
|
(?:FIRSTNAME|LASTNAME|PHONE|EMAIL)/x
</code></pre>

<p>See <a href="https://regex101.com/r/yP6oJ7/1" rel="nofollow">another regex demo</a></p>

<p>Here is an <a href="http://ideone.com/0bvHJX" rel="nofollow">IDEONE demo</a>:</p>

<pre><code>$re = "/(?:
 (\\((?&gt;[^()]|(?1))*\\)) # Match (..(.)) like substrings
 |
 ({(?&gt;[^{}]|(?2))*})   # Match {{.}..} like substrings
)
(*SKIP)(*F)  # Ignore the texts matched
|
(?:FIRSTNAME|LASTNAME|PHONE|EMAIL)/x"; 
$str = "FIRSTNAME LASTNAME PHONE EMAIL {FIRSTNAME LASTNAME PHONE EMAIL{FIRSTNAME LASTNAME PHONE EMAIL }FIRSTNAME LASTNAME PHONE EMAIL }"; 
$n = preg_replace($re, "", $str);
echo $n;
</code></pre>
