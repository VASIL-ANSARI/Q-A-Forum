<p>You are comparing the string representation of your array. <code>toString()</code> doesn't give you what you think. For example, the below code makes it clear:</p>

<pre><code>char[] arr1 = {'a', 'b'};
char[] arr2 = {'a', 'b'};

System.out.println(arr1.toString() + " : " + arr2.toString());
</code></pre>

<p>this code prints:</p>

<pre><code>[C@16f0472 : [C@18d107f
</code></pre>

<p>So, the string representation of both the arrays are different, even though the contents are equal. This is because arrays don't override <code>toString()</code> method. It inherits the <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#toString%28%29" rel="nofollow"><code>Object#toString()</code></a> method.</p>

<blockquote>
  <p>The <code>toString</code> method for class <code>Object</code> returns a string consisting of
  the name of the class of which the object is an instance, the at-sign
  character <code>@</code>, and the unsigned hexadecimal representation of the hash
  code of the object. In other words, this method returns a string equal
  to the value of:</p>

<pre><code>getClass().getName() + '@' + Integer.toHexString(hashCode())
</code></pre>
</blockquote>

<p>So, in the above output, <code>[C</code> is the output of <code>char[].class.getName()</code>, and <code>18d107f</code> is the hashcode.</p>

<p>You can't also compare the arrays using <code>forward.equals(back)</code>, as arrays in Java don't override <code>equals()</code> or <code>hashCode()</code> either. Any options? Yes, for comparing arrays you can use <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#equals%28char%5B%5D,%20char%5B%5D%29" rel="nofollow"><code>Arrays#equals(char[], char[])</code></a> method:</p>

<pre><code>if (Arrays.equals(forward, back)) {
    System.out.println(k);
}
</code></pre>

<hr />

<p>Also, to get your <code>char</code> arrays, you don't need those loops. You can use <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#toCharArray%28%29" rel="nofollow"><code>String#toCharArray()</code></a> method. And also to get the reverse of the String, you can wrap the string in a <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html" rel="nofollow"><code>StringBuilder</code></a> instance, and use it's <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html#reverse%28%29" rel="nofollow"><code>reverse()</code></a> method:</p>

<pre><code>char[] forwards = stringProd.toCharArray();
char[] back = new StringBuilder(stringPod).reverse().toString().toCharArray();
</code></pre>

<hr />

<p>And now that you have found out an easy way to reverse a string, then how about using <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#equals%28java.lang.Object%29" rel="nofollow"><code>String#equals()</code></a> method directly, and resist creating those character arrays?</p>

<pre><code>String stringPod = String.valueOf(k);
String reverseStringPod = new StringBuilder(stringPod).reverse().toString()

if (stringPod.equals(reverseStringPod)) {
    System.out.println(k);
}
</code></pre>

<hr />

<p>Finally, since it is about project euler, which is about speed and mostly mathematics. You should consider avoiding <code>String</code> utilities, and do it with general division and modulus arithmetic, to get each individual digits, from beginning and end, and compare them.</p>
