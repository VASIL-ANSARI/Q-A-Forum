<p>I did resolve this issue. In my case, the problem was that I had mistakenly added security annotations on methods that were already being tracked in Spring Security from a configuration in an intercept-url pattern in a Spring Security xml file. </p>

<p>After all was said and done it is very simple and works great. The only trick to it is that your Android client must create a static DefaultHttpClient, call the login servlet of your website with that client, and then make all subsequent calls using the same httpClient instance. Your android requests can then enter secured methods, maintain a session and be treated as any normal user. </p>

<p>The following code from my original question is superfulous and I do not use it at all:
    <code>httpclient.getCredentialsProvider().setCredentials( ...</code>
As eluded to, I also am not using the security annotations as I have my urls secured in an xml file.</p>
