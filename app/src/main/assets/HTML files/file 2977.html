<p>What you would normally do in this case is give <code>B</code> a constructor that takes an <code>A</code>:</p>

<pre><code>class B
{
public:
    B(const A&amp;);
};
</code></pre>

<p>And do the conversion there. The compiler will say "How can I make <code>A</code> a <code>B</code>? Oh, I see <code>B</code> can be constructed from an <code>A</code>".</p>

<p>Another method is to use a conversion operator:</p>

<pre><code>class A
{
public:
    operator B(void) const; 
}
</code></pre>

<p>And the compiler will say "How can I make <code>A</code> a <code>B</code>? Oh, I see <code>A</code> can be converted to <code>B</code>".</p>

<p>Keep in mind these are very easy to abuse. Make sure it really makes sense for these two types to implicitly convert to each other.</p>
