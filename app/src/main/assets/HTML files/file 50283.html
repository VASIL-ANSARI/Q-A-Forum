<p>The boost documentation for <a href="http://www.boost.org/doc/libs/1_42_0/doc/html/boost_asio/reference/io_service/run/overload1.html" rel="nofollow">io_service.run()</a> says:</p>

<blockquote>
  <p>The run() function blocks until all work has finished and there are no more handlers to be dispatched, or until the io_service has been stopped.</p>
</blockquote>

<p>So, as expected, calling this will wait until the timer expires, at which point there's no more work to call and <code>run()</code> returns. The idea is that you're supposed to put your other functions into boost handlers so they can be called by boost's IO system, and <code>run()</code> takes the place of your own main loop.</p>

<p>The alternative is polling. For your example, you would want to remove the <code>io.run()</code> call from before your loop, and place a call to <a href="http://www.boost.org/doc/libs/1_42_0/doc/html/boost_asio/reference/io_service/poll/overload1.html" rel="nofollow">io.poll()</a> within your loop. (Note that there's also a <a href="http://www.boost.org/doc/libs/1_42_0/doc/html/boost_asio/reference/io_service/poll/overload2.html" rel="nofollow">version of poll()</a> that can return information abouts errors.)</p>

<p>You'll also need to come up with a way to make your main loop stop executing if you do this; just putting the call to <code>io.poll()</code> into your loop should give you the output you're expecting, but you're still in an infinite loop.</p>
