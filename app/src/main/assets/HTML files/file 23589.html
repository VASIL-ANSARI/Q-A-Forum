<p>The <code>volatile</code> keyword tells the compiler that a variable might be changing via some mechanism outside of the current thread and so it shouldn't optimize away seemingly redundant accesses. It means nothing more, although some compilers may give it additional meaning - the Microsoft Visual C++ compiler has <a href="http://msdn.microsoft.com/en-us/library/12a04hfd%28v=vs.110%29.aspx" rel="nofollow">this to say</a>:</p>

<blockquote>
  <p>Although the processor does not reorder un-cacheable memory accesses, un-cacheable variables must be marked as volatile to guarantee that the compiler does not reorder the memory accesses.</p>
</blockquote>

<p>The mutex code will probably provide the necessary <a href="http://en.wikipedia.org/wiki/Memory_barrier#Multithreaded_programming_and_memory_visibility" rel="nofollow">memory fence</a> to ensure that the reads and writes to the protected variable don't extend beyond the bounds of the mutex, so I'd say that marking it <code>volatile</code> would not be necessary - if you've properly implemented the mutex there is no chance that another thread could try to access it.</p>
