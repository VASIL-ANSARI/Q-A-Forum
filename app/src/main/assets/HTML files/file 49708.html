<p>How about this:</p>

<pre><code>public interface IMyType { }

public interface IMyType&lt;T&gt; : IMyType where T : IMySubType
{
    event EventHandler&lt;IMyType&lt;T&gt;, EventArgs&lt;T&gt;&gt; OnSomething;
    IEnumerable&lt;T&gt; AvailableThings{get;}
    void Start();
}
</code></pre>

<p>Your list would be of type <code>List&lt;IMyType&gt;</code>:</p>

<pre><code>List&lt;IMyType&gt; myList = new List&lt;IMyType&gt;();
myList.Add(implementation1); // implementation1 is of type IMyType&lt;SubTypeImplementation&gt;
myList.Add(implementation2); // implementation2 is of type IMyType&lt;SubTypeImplementation2&gt;
</code></pre>

<p>Of course, the drawback would be that you will need to cast each element on the list in order to use it:</p>

<pre><code>var impl = (IMyType&lt;SubTypeImplementation&gt;)list[0];
impl.Start();
</code></pre>

<hr>

<p>Anyway, I wouldn't use generics in this situation.</p>

<p>My <code>IMyType</code> would look like this:</p>

<pre><code>public interface IMyType
{
     event EventHandler&lt;IMySubType, EventArgs&lt;IMySubType&gt;&gt; OnSomething;
     IEnumerable&lt;IMySubType&gt; AvailableThings { get; }
     void Start();
}
</code></pre>
