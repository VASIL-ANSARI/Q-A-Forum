<p>Registering a timer doesn't stop your code. You're registering all timers at the same time, the scheduler will try to execute them N ms after the time of registration.</p>

<p>This means that</p>

<ul>
<li>The third timer you set will be executed first 300 ms after your main code is executed</li>
<li>then it will be the fourth 400 ms after the main code was executed</li>
<li>then the first and second</li>
</ul>

<p>If you want to queue your timers, either you chain them (by making each of them call the next one) or (much lighter and simpler if the tasks are short) you compute yourself the times :</p>

<pre><code>var time = 0;
setTimeout(function(){
  console.log("First Timer");
}, time += 500);
setTimeout(function(){
  console.log("Second Timer");
}, time += 600);
console.log("Executed immediately");
setTimeout(function(){
  console.log("Third Timer");
}, time += 300);
setTimeout(function(){
  console.log("Fourth Timer");
}, time += 400);
</code></pre>

<p><a href="http://stackoverflow.com/questions/14365318/delay-to-next-function-in-method-chain/14365382#14365382">In this somewhat related answer</a> I give an implementation of a simple queue.</p>
