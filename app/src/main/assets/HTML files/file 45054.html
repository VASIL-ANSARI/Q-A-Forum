<p>You could solve this by runlength encoding. Use a <a href="https://docs.oracle.com/javase/7/docs/api/java/io/DataOutputStream.html" rel="nofollow">DataOutputStream</a> to write an integer at the start that represents the amount of bytes that are written afterwards. When decrypting, read that integer, and only use the amount of bytes it says.</p>

<p><strike>I noticed you are using the <a href="https://docs.oracle.com/javase/7/docs/api/javax/crypto/Cipher.html" rel="nofollow">Cipher</a> class in a wrong way. Use the <code>update</code> method to add bytes to <code>cipher</code> and only use <code>doFinal</code> once. It is important that you use <a href="https://docs.oracle.com/javase/7/docs/api/javax/crypto/Cipher.html#update%28byte[],%20int,%20int%29" rel="nofollow">this</a> overloaded version of the update method. Set the <code>inputOffset</code> parameter to zero and the <code>inputLen</code> parameter to <code>i</code>. This will make sure, that the <code>Cipher</code> is only using the bytes it should.</strike></p>

<p>See JB Nizets answer.</p>
