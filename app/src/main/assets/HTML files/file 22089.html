<p>I feel like I found a satisfactory answer to my own question, and so I'm just going to close this out myself.
I ended up doing two things.</p>

<p>Firstly I disabled Lazy Loading entirely on the dbContext.
Something akin to this in the dbContext constructor.</p>

<p><code>this.Configuration.LazyLoadingEnabled = false;</code></p>

<p>I wasn't really using the lazy load feature of EF, so turning it off was no big loss.  This just means that if I want related entities to be populated, I have to specify them in an <code>Include</code> on my query.  No big deal.</p>

<p>The other thing I did was rework the deep clone injection convention to use the <code>SmartConventionInjection</code> code found here <a href="http://valueinjecter.codeplex.com/wikipage?title=SmartConventionInjection&amp;referringTitle=Home" rel="nofollow">SmartConventionInjection source</a>.  Besides being an even faster injection than the base injection, it also doesn't touch property values until the <code>SetValue</code> call, so even if I did have some lazy loading properties, they wouldn't be touched unless the DTO also had that property.</p>
