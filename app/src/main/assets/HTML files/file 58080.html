<p>You can add an enumeration and use that value in your code so the code is self-explanatory:</p>

<pre><code>class TimerHao
{
 private:

    enum flag_states
    {
        FLAG_STATE_NOT_STARTED = 0,
        FLAG_STATE_IN_ACCUMULATION,
        // etc
    };

    double seconds;
    flag_states flag = FLAG_STATE_NOT_STARTED;  //0: Have not start accumulation. 1: In accumulation, between init() and end();

 public:

    void init();
    void end();
};

void TimerHao::init() 
{
    if(flag != FLAG_STATE_NOT_STARTED) { throw runtime_error( "ERROR!!! Cannot initial the timer before it is ended!" ); }

    flag = FLAG_STATE_IN_ACCUMULATION;
}

void TimerHao::end()
{
    if(flag != FLAG_STATE_IN_ACCUMULATION) { throw runtime_error("ERROR!!! Cannot end the timer before it is initialized!");}

    flag= FLAG_STATE_NOT_STARTED;
}
</code></pre>

<p>If you have access to C++11 you can even make it a scoped enumeration and disallow casting:</p>

<pre><code>class TimerHao
{
 private:

    enum class flag_states
    {
        FLAG_STATE_NOT_STARTED = 0,
        FLAG_STATE_IN_ACCUMULATION,
        // etc
    };

    double seconds;
    flag_states flag = flag_states::FLAG_STATE_NOT_STARTED;  //0: Have not start accumulation. 1: In accumulation, between init() and end();

 public:

    void init();
    void end();
};

void TimerHao::init() 
{
    if(flag != flag_states::FLAG_STATE_NOT_STARTED) { throw runtime_error( "ERROR!!! Cannot initial the timer before it is ended!" ); }

    flag = flag_states::FLAG_STATE_IN_ACCUMULATION;
}

void TimerHao::end()
{
    if(flag != flag_states::FLAG_STATE_IN_ACCUMULATION) { throw runtime_error("ERROR!!! Cannot end the timer before it is initialized!");}

    flag= flag_states::FLAG_STATE_NOT_STARTED;
}
</code></pre>
