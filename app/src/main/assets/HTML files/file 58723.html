<blockquote>
  <p>I thought this should be handled one abstraction layer below.</p>
</blockquote>

<p>Why? The abstraction that TCP offers is a (potentially endless) stream of bytes in both directions. If you want messages, it's up to you to either implement that yourself (as you're doing here) or move to a higher level abstraction</p>

<blockquote>
  <p>I meant the abstraction that a Stream provides. But I seem to have a misunderstanding. As I expect a stream to give me n bytes if I request n bytes</p>
</blockquote>

<p>Unfortunately, that's a misapprehension as well. Whilst some <code>Stream</code> implementations may be able to offer such a guarantee, the abstract <code>Stream</code> class defines the <a href="https://msdn.microsoft.com/en-us/library/system.io.stream.read(v=vs.110).aspx" rel="nofollow"><code>Read</code></a> method:</p>

<blockquote>
  <p>The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, </p>
</blockquote>

<p>And so <code>NetworkStream</code> takes advantage of this flexibility - it gives you at least one byte and as much as it can conveniently, once it has some data available.</p>

<p>Whilst it doesn't fit your use case, it may be that some consumers are able to work with whatever data is available - so they may supply a large buffer (in case lots of data is available) but can do <em>something</em> useful with just a single byte. Those consumers will be calling exactly the same API as you are, and its behaviour suits their needs.</p>
