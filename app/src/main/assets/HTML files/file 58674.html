<p>It was pointed out to me that using <code>strcpy()</code> for this is wrong, because "copying that takes place between objects that overlap" is undefined in the standard (ISO/IEC 9899:1999 7.21.2.4).</p>

<p>Here is a version that uses <code>memmove()</code>, with some checks for valid indices. It swaps the indices if the first is larger than the second, and returns NULL if the indices are out of bounds:</p>

<pre><code>char * remove_portion(char *str, int start, int end)
{
    int str_len = strlen(str);
    int temp;

    if (start &gt; end) {
        temp = start;
        start = end;
        end = temp;
    }

    if (end &gt; (str_len - 1) || start &lt; 0 || end &lt; 0) {
        str = NULL;
    } else {
        int ncopy = str_len - end; 
        memmove(&amp;str[start], &amp;str[end+1], ncopy);
    }

    return str;
}
</code></pre>

<p>Of <code>memmove()</code> the standard says: "Copying takes place as if the n characters from the object pointed to by s2 are first copied into a temporary array of n characters that does not overlap the objects pointed to by s1 and s2, and then the n characters from the temporary array are copied into the object pointed to by s1." (ISO/IEC 9899:1999 7.21.2.2)</p>

<p>So <code>memmove()</code> is specifically designed to handle situations such as copying a part of an array to itself.</p>
