<p>1) Most of the intersections can be filtered if you use findContours() with CV_RETR_EXTERNAL flag. This means that contours that are contained inside other contours won't be returned. Of course this will not prevent all the cases of intersections of bounding boxes but this will considerably improve performance of your post-processing</p>

<p>2) vectors are definitely good for sorting. The code will be short and efficient. And it is better than list anyway since the data will be continuous in the memory.</p>

<p>3) Deleting values from vector one by one is not effective indeed but you don't need to do that. Just create temporary vector that will contain chosen boxes, like this:</p>

<pre><code>vector &lt; Rect &gt; nonIntersect;
for(unsigned int i=0; i &lt; sortedBoxes.size(); i++) {
    bool toAdd = true;
    Point center = (sortedBoxes[i].tl()+sortedBoxes[i].br())*0.5;
    for(unsigned int j=0; j &lt; nonIntersect.size(); j++)
        if (nonIntersect[j].contains(center)) {
            toAdd = false;
            break;
        }
    if (toAdd)
        nonIntersect.push back(sortedBoxes[i]);
 }
</code></pre>

<p>This can be done 'inplace' as well but why bother. This memory is ignorable comparing to memory of original image, or memory of contours found by findContours.</p>
