<p>For each item in the array, up to 5 comparisons are done for the min list and 5 for the max list.<br>
Suggest calling a function to do this in a tidy fashion.  </p>

<pre><code>#include&lt;assert.h&gt;

// `list` is `const` as OP says "withouth changing any of the arregment".
void sort_ends(const int *list, size_t listlen, int *minlist, int *maxlist, 
    size_t mlen) {
  assert(list);
  assert(minlist);
  assert(maxlist);
  assert(mlen &gt;= 1);
  assert(listlen &gt;= mlen);

  minlist[0] = list[0];
  // For each element after the first ...
  for (size_t i = 1; i &lt; listlen; i++) {
    int mincandidate = list[i];
    size_t mini = i;
    if (mini &gt; mlen) mini = mlen;
    do {
      mini--;
      if (mincandidate &gt;= minlist[mini]) 
        break;
      // swap mincandidate and minlist[mini]
      int t = mincandidate;
      mincandidate =  minlist[mini];
      minlist[mini] = t;
    } while (mini &gt; 0);
  }
  // Do similar for maxlist, left for OP
}

int main() {
  int ari;
  // ...
  int pinakas[ari];
  // ...
  int mlen = 5;
  int minlist[mlen];
  int maxlist[mlen];
  sort_ends(pinakas, ari, minlist, maxlist, mlen);
  return 0;
}
</code></pre>

<p>Alternative approach, find min index and then <code>memove()</code>.</p>
