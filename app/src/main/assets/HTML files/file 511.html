<p>I guess you have 2 choices</p>

<p>If your use-cases never require updates to both databases within the same transaction, then you can use two JpaTransactionManagers, but I'm not sure you will be able to use the @Transactional approach? In this case, you would need to fallback on the older mechanism of using a simple <a href="http://static.springframework.org/spring/docs/2.5.5/api/org/springframework/transaction/interceptor/TransactionProxyFactoryBean.html">TransactionProxyFactoryBean</a> to define transaction boundaries, eg:</p>

<pre><code>&lt;bean id="firstRealService" class="com.acme.FirstServiceImpl"/&gt;
&lt;bean id="firstService"  
    class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="firstJpaTm"/&gt;
    &lt;property name="target" ref="firstRealService"/&gt;
    &lt;property name="transactionAttributes"&gt;
        &lt;props&gt;
           &lt;prop key="insert*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
           &lt;prop key="update*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
           &lt;prop key="*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;!-- similar for your second service --&gt;
</code></pre>

<p>If you are require a transaction spanning both databases, then you will need to use a JTA transaction manager. The <a href="http://static.springframework.org/spring/docs/2.5.5/api/org/springframework/orm/jpa/JpaTransactionManager.html">API</a> states:</p>

<blockquote>
  <p>This transaction manager is appropriate for applications that use a single JPA EntityManagerFactory for transactional data access. JTA (usually through JtaTransactionManager) is necessary for accessing multiple transactional resources within the same transaction. Note that you need to configure your JPA provider accordingly in order to make it participate in JTA transactions.</p>
</blockquote>

<p>What this means is that you will need to provide a JTA transaction manager. In our application, we use config similar to the following:</p>

<pre><code>&lt;tx:annotation-driven transaction-manager="txManager"/&gt;

&lt;bean id="txManager" 
    class="org.springframework.transaction.jta.JtaTransactionManager"&gt;
    &lt;property name="transactionManagerName" value="appserver/jndi/path" /&gt;
&lt;/bean&gt;
</code></pre>

<p>If you are deploying within an appserver, then the spring JtaTransactionManager needs to do a lookup to the real XA-compliant JTA transaction manager provided by the appserver. However, you can also use a standalone JTA transaction manager (but I haven't tried this myself yet)</p>

<p>As for configuring the Jpa persistence provider, I'm not that familiar. What JPA persistence provider are you using?</p>

<p>The code above is based on our approach, where we were using native Hibernate as opposed to Hibernate's JPA implementation. In this case, we were able to get rid of the two HibernateTransactionManager beans, and simply ensure that both SessionFactories were injected with the same JTA TM, and then use the tx:annotation-driven element.</p>

<p>Hope this helps</p>
