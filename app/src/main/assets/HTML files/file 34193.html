<p>I do not believe it can get much "simpler" than what you have. You need to mutually exclude shared variables that are being modified by numerous processes. You could possibly have a "read only" type of situation where a mutex is not needed but that will not help your simplification. </p>

<p>Having the mutex release on its destruction(when it falls out of scope) is probably the best way and I have seen numerous threading libraries use that exact same method. Portable Tools Library, <a href="http://sourceforge.net/projects/opalvoip/files/v3.12%20Eridani/Stable%209/" rel="nofollow">PTLib</a>, is an abstraction library that includes threading abstraction and it releases mutexes when they fall out of scope but you still have to use them. However, you should also keep track of the number of calls and releases against the mutex so that you can signal the other thread when it is available. </p>

<p>Also, as Bgie pointed out in his answer, you do need to protect your code. <strong><em>Never trust other programmers</em></strong>, that includes your future self.</p>

<p>But your idea of releasing a lock when the scope is left is a good first general implementation, just needs some additional work :).</p>

<p>(Edit due to Bgie's comment)</p>
