<p>Basically the answer is operator overloading. Functions can have the same name as long as they take different parameters. <code>operator&lt;&lt;</code> is the function name you're wondering about. The compiler knows the type of what you're trying to print out, and calls the correct <code>operator&lt;&lt;</code>.</p>

<p>This is why if you create your own object you can't just write <code>std::cout &lt;&lt; yourObject;</code> and expect it to work how you'd probably like it to. You have to specify how it should be printed,</p>

<pre><code>ostream&amp; operator&lt;&lt;(ostream&amp; os, const YourObject&amp; rhs) {
  os &lt;&lt; rhs.member;
  return os;
}
</code></pre>

<p>But, happily, that's already been done for you behind the scenes in the case of something like an <code>int</code>. See: <a href="http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt2" rel="nofollow">http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt2</a> for a full list of provided overloads.</p>
