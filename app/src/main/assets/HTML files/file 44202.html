<p>I am surprised you get so far; when I try running the program, it actually hangs much earlier. Here's why:</p>

<p>Your main function calls <code>add_transition(0, ...)</code>, which calls <code>add_state(0)</code>, just after your <code>cout &lt;&lt; "Gaat dit goed?" &lt;&lt; endl;</code>.</p>

<p>At this point, inside <code>add_state</code>, <code>if(state &gt;= number_of_states)</code> evaluates to true (it's <code>if(0&gt;=0)</code>), and then you call <code>new</code> to allocate 0 <code>transition*</code> elements, which is a bad thing which could lead to errors (<a href="http://stackoverflow.com/questions/1087042/c-new-int0-will-it-allocate-memory">C++ new int[0] -- will it allocate memory?</a>). Anyway, in this case your error isn't here. Just go on, you now skip the <code>for</code> loop as the condition isn't met, and go straight to <code>free_action_table();</code>.</p>

<p>Inside it, you skip the <code>for</code> (same reason) and then... You try to <code>delete[] action_table;</code>.</p>

<p>When was <code>action_table</code> initialised? Never! Therefore it has a random value. If you try to delete it, you will most probably access an address that isn't reserved to your process and get a nice segmentation fault. The output you show indicates you went beyond that, so you were (un)lucky enough to have a random value that actually corresponds to your program's memory space, therefore it didn't throw a segmentation fault the first time you reached it.</p>

<p>So to fix your problem (though I can't guarantee it's the only one) you have to either initialise that pointer before you delete it, or you have to avoid deleting it when it hasn't been initialised yet. You might also have a look at smart pointers, they can take care of memory management and prevent these errors.</p>
