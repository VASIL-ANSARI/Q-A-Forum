<p>Actually the <a href="https://docs.python.org/3/library/functions.html?highlight=enumerate#any" rel="nofollow"><code>any()</code></a> function is equal to following function :</p>

<pre><code>def any(iterable):
    for element in iterable:
        if element:
            return True
    return False
</code></pre>

<p>which is like your second function, but since the <code>any()</code> returns a boolean value by itself, you don't need to check for the result and then return a new value, So the difference of performance is because of that you are actually use a redundant return and <code>if</code> conditions,also calling the <code>any</code> inside another function.</p>

<p>So the advantage of <code>any</code> here is that you don't need to wrap it with another function because it does all the things for you.</p>

<p>Also as @interjay mentioned in comment it seems that the most important reason which I missed is that you are passing a generator expression to <code>any()</code> which doesn't provide the results at once and since it produce the result on demand it does an extra job.</p>

<p>Based on <a href="https://www.python.org/dev/peps/pep-0289/" rel="nofollow">PEP 0289 -- Generator Expressions</a></p>

<blockquote>
  <p>The semantics of a generator expression are equivalent to creating an anonymous generator function and calling it. For example:</p>
</blockquote>

<pre><code>g = (x**2 for x in range(10))
print g.next()
</code></pre>

<p>is equivalent to:</p>

<pre><code>def __gen(exp):
    for x in exp:
        yield x**2
g = __gen(iter(range(10)))
print g.next()
</code></pre>

<p>So as you can see each time that python want to access the next item it calls the <code>iter</code> function and the <code>next</code> method of a generator.And finally the result is that it's overkill to use <code>any()</code> in such cases.</p>
