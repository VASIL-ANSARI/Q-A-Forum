<p>The operator <code>==</code> checks if the objects are the same instance in memory whereas when you override <code>equals</code> you usually want to perform a logical test.</p>

<p>Let's take an example:</p>

<pre><code>public class Person {
   private String name;

   // Here there are constructor and getters and setters
}
</code></pre>

<p>Now let's run these lines:</p>

<pre><code>Person a = new Person();
Person b = a;
Person c = new Person();
</code></pre>

<p>If you compare these instances with <code>==</code> this is what you'll get:</p>

<pre><code>a == a ==&gt; true
a == b ==&gt; true
a == c ==&gt; false
</code></pre>

<p>Now, let's set the name:</p>

<pre><code>a.setName("Joe"); // This also sets b because they're the same object
c.setName("Joe");
</code></pre>

<p>If our <code>equals</code> looks like this:</p>

<pre><code>public boolean equals (Object other) {
    if(other == this) return true;

    if(other instanceof Person == false) return false;


    if(this.getName().equals(((Person) other).getName())) return true;

}
</code></pre>

<p>So we'll now get that <code>a.equals(c)</code> is <code>true</code> even though <code>a==c</code> is false.</p>

<p><strong>So, why do we have the first line?</strong> - Some objects' equality is more expensive to compute and by checking this condition at the beginning <strong>you might spare some unnecessary computations</strong></p>
