<p>Assuming a timeout is good enough and you don't need to solve the <a href="http://en.wikipedia.org/wiki/Halting_problem" rel="nofollow">halting problem</a>: </p>

<pre><code>public class TimeoutChecker
{
    private static Dictionary&lt;Thread, DateTime&gt; hashTimeouts
        = new Dictionary&lt;Thread, DateTime&gt;();
    static TimeoutChecker()
    {
        new Thread(CheckThread).Start();
    }
    protected static void CheckThread()
    {
        while (true)
        {
            try
            {
                Thread.Sleep(500);
                foreach (DateTime t in hashTimeouts.Values)
                {
                    if (DateTime.Now.AddMilliseconds(10 * 1000) &lt; t)
                    {
                        //Perform recovery logic.
                    }
                }
            }
            catch (Exception) { }
        }
    }
    public static void BeforeCall()
    {
        hashTimeouts.Add(Thread.CurrentThread, DateTime.Now);
    }
    public static void AfterCall() //be sure to execute in a finally...
    {
        hashTimeouts.Remove(Thread.CurrentThread);
    }
}
</code></pre>

<p>Here, BeforeCall and AfterCall would be in a wrapper outside the native calls, but inside the remote method invocations.  </p>

<p>Of course, it's probably a much better idea to use synchronization before calling the native code to avoid deadlocks in the first place.  </p>
