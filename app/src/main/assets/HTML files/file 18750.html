<p>There are issues, because you never set your field, so you'll return a new object everytime the property is called.</p>

<p>You should set <code>_ipDet</code> if it's null, and then return it. This is called <a href="http://en.wikipedia.org/wiki/Lazy_initialization" rel="nofollow">lazy instantiation or lazy initialization</a>.</p>

<pre><code>public class Person
{
    private RecIpDet _ipDet;

    public RecIpDet IpDet
    {
        get 
        {                 
            if (_ipDet == null)
            {
                _ipDet = new RecIpDet();
            }

            return _ipDet; 
        }
    } 
}
</code></pre>

<p>Keep in mind, this is not thread-safe, so if that's a factor for you, you'll need a more robust mechanism. For single threaded applications, this method of lazy instantiation is fine.</p>

<p>If you're using .NET 4.0 or higher, you can use the <a href="http://msdn.microsoft.com/en-us/library/dd642331.aspx" rel="nofollow"><code>Lazy&lt;T&gt;</code></a> class, which I believe is thread-safe:</p>

<pre><code>public class Person
{
    private Lazy&lt;RecIpDet&gt; _ipDet = new Lazy&lt;RecIpDet&gt;(() =&gt; new RecIpDet());

    public RecIpDet IpDet
    {
        get 
        {                 
            return _ipDet.Value; 
        }
    } 
}
</code></pre>
