<p>In general, you want to be thinking about <em>vectorized operations on columns</em> instead of operations on specific cells.</p>

<p>So, for example, if you had a <code>data</code> column, and you wanted another column that was the same but with each value multiplied by 3, you could do this in two basic ways. The first is the "cell-by-cell" operation.</p>

<pre><code>df['data_prime'] = df['data'].apply(lambda x: 3*x)
</code></pre>

<p>The second is the vectorized way:</p>

<pre><code>df['data_prime'] = df['data'] * 3
</code></pre>

<hr>

<p>So, column-by-column in your spreadsheet:</p>

<p><strong>Count</strong> (you can add 1 to the right side if you want it to start at 1 instead of 0):</p>

<pre><code>df['count'] = pandas.Series(range(len(df))
</code></pre>

<p><strong>Running total</strong>:</p>

<pre><code>df['running total'] = df['data'].cumsum()
</code></pre>

<p><strong>Difference from a scalar</strong> (set the scalar to a particular value in your df if you want):</p>

<pre><code>df['diff'] = scalar - df['data']
</code></pre>

<p><strong>Moving average</strong>:</p>

<pre><code>df['moving average'] = df['running total'] / df['count'].astype('float')
</code></pre>

<p><strong>Basic formula from your spreadsheet</strong>:</p>

<p>I think you have enough to this on your own.</p>

<p><strong>If statement</strong>:</p>

<pre><code>df['new column'] = 0
mask = df['data column'] &gt;= 3
df.loc[mask, 'new column'] = 1
</code></pre>
