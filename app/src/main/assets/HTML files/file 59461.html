<p>According to the documentation on <code>addConstraint:</code> setting the <code>active</code> property is recommended for <em>individual constraints</em>. (note: <code>active</code> property is only available iOS 8+).</p>

<blockquote>
  <p>When developing for iOS 8.0 or later, set the constraintâs active
  property to YES instead of calling the addConstraint: method directly.
  The active property automatically adds and removes the constraint from
  the correct view. (<a href="https://developer.apple.com/reference/uikit/uiview/1622523-addconstraint" rel="nofollow">reference</a>)</p>
</blockquote>

<p>Also if you look at the interface definition for <code>addConstraint:</code> it has this comment:</p>

<blockquote>
  <p>// This method will be deprecated in a future release and should be
  avoided.Â  Instead, set NSLayoutConstraint's active property to YES</p>
</blockquote>

<hr>

<p>With that being said, there is actually a 3rd [and probably better] alternative, which is to use <code>NSLayoutConstraint</code>'s class method <code>activateConstraints:</code>:</p>

<pre><code>NSLayoutConstraint.activateConstraints([
    child.topAnchor.constraint(equalTo: parent.topAnchor, constant: 20),
    child.leftAnchor.constraint(equalTo: parent.leftAnchor, constant: 5) ])
</code></pre>

<p>This is also a recommended solution according to the documentation and interface files. So if you have multiple constraints, this would be an easy solution and probably preferred in your situation.</p>

<p>(interface comment; emphasis mine):</p>

<blockquote>
  <p>Convenience method that activates each constraint in the contained
  array, in the same manner as setting active=YES. <strong>This is often more
  efficient than activating each constraint individually.</strong></p>
</blockquote>
