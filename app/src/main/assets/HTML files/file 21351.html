<p>Are you using jQuery? If you are, then do this:</p>

<pre><code>var Maps = (function () {

function Maps() {

}

Maps.prototype.getCoord = function () {
    navigator.geolocation.getCurrentPosition($.proxy(this.onPositionSuccess, this), $.proxy(this.onPositionError, this));
};

Maps.prototype.getWatchCoord = function () {
    var options = { enableHighAccuracy: true, timeout: 3000 };
    navigator.geolocation.watchPosition($.proxy(this.onWatchSuccess, this), $.proxy(this.onWatchError, this), options);
};

Maps.prototype.onPositionSuccess = function (position) {
    var pos = {
        'latitude'          : position.coords.latitude,
        'longitude'         : position.coords.longitude
    };
    console.log(pos);

    //call getWatchCoord
    this.getWatchCoord();
};

Maps.prototype.onWatchSuccess = function (position) {
    var pos = {
        'latitude'          : position.coords.latitude,
        'longitude'         : position.coords.longitude
    };
    console.log(pos);
};

Maps.prototype.onWatchError = function (error) {
    console.log(error.code);
};
Maps.prototype.onPositionError = function (error) {
    console.log(error.code);
};

return Maps;

})();

var maps = new Maps();
    maps.getCoord();
</code></pre>

<p>'this' will be global when entering the success callback if you do not pass a callback function that is scope with the right 'this' which is why I used <a href="http://api.jquery.com/jQuery.proxy/" rel="nofollow">$.proxy</a> above. Now this is untested so I do not know what other problems you have here.</p>
