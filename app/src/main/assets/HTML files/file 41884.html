<p>First, if you're trying to look up the entire <code>word[0]</code> in <code>alphabet</code>, rather than each character individually, you shouldn't be looping over the characters of <code>word[0]</code>. Just use <code>alphabet.index(word[0])</code> directly.</p>

<p>From your comments, it sounds like you're trying to look up each <em>transliterated-Burmese-script character</em> in <code>word[0]</code>. That isn't possible unless you can write an algorithm to split a word up into those characters. Splitting it up into the ASCII bytes of the transliteration doesn't help at all.</p>

<hr>

<p>Second, you probably shouldn't be using <code>index</code> here. When you think you need to use <code>index</code> or similar functions, 90% of the time, that means you're using the wrong data structure. What you want here is a <em>mapping</em> (presumably why it's called <code>map.txt</code>), like a dict, keyed by words, not a list of words that you have to keep explicitly searching. Then, looking up a word in that dictionary is trivial. (It's <em>also</em> a whole lot more efficient, but the fact that it's easy to read and understand can be even more important.)</p>

<hr>

<p>Finally, I suspect that your <code>map.txt</code> is supposed to be read as a whitespace-separated list of transliterated characters, and what you want to find is the index into that list for any given word. </p>

<hr>

<p>So, putting it all together, something like this:</p>

<pre><code>with open('map.txt', 'rb') as f:
    mapping = {word: index for index, word in enumerate(f.read().split())}
word_list = sorted(word_list, key=lambda word: mapping[word[0]])
</code></pre>

<hr>

<p>But, again, that's only going to work for one-syllable words, because until you can figure out how to split a word up into the units that should be alphabetized (in this case, the symbols), there is no way to make it work for multi-syllable words.</p>

<p>And once you've written the code that does that, I'll bet it would be pretty easy to just convert everything to proper Unicode representations of the Burmese script. Each syllable still takes 1-4 code points in Unicodeâbut that's fine, because the standard Unicode collation algorithm, which comes built-in with Python, already knows how to alphabetize things properly for that script, so you don't have to write it yourself.</p>

<p>Or, even better, unless this is some weird transliteration that you or your teacher invented, there's probably already code to translate between this format and Unicode, which means you shouldn't even have to write anything yourself.</p>
