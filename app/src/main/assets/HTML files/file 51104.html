<p>Create a wrapper for the library that catches all exceptions thrown by the library. Compile the library and the wrapper with exceptions enabled. Use the wrapper from the legacy code which has exceptions disabled. This way nothing gets thrown to the code that has exceptions disabled.</p>

<pre><code>// third party library
// compiled with exceptions
// may throw
int foo();

// wrapper library
// compiled with exceptions
// may not throw
enum class Error { no_error, code_1, code_2 };

int wrapper_foo(Error&amp; err) {
    try {
         err = Error::no_error;
         return foo();
    } catch(const std::length_error&amp; e) {
        // optionally handle specific exceptions differently
        err = Error::code_1;
        return -1;
    } catch(...) {
        // you must catch all thrown objects
        err = Error::code_2;
        return -1;
    }
}

// legacy code
// compiled without exceptions
void bar() {
    Error err;
    int baz = wrapper_foo(err);
    if(err != Error::no_error) {
        // handle error
    }
}
</code></pre>
