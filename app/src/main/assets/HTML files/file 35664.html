<p>You are not actually using your mocked object, you are creating the concrete (real) <code>some_type</code> object in your <code>MyClass</code> constructor with the <code>new</code> statement. </p>

<p>I would suggest changing your <code>MyClass</code> class to accept the <code>some_type</code> object as a constructor parameter:</p>

<pre><code>public MyClass(some_type thetype)
{
    m_member = thetype;
}
</code></pre>

<p>Then, in your test method, pass the mocked object into the ctor: </p>

<pre><code>MockFactory mock_factory = new MockFactory();
Mock&lt;some_type&gt; mock = mock_factory.CreateMock&lt;some_type&gt;();
MyClass uut = new MyClass(mock.MockObject);
</code></pre>

<p>That will mean that your <code>MyClass</code> instance will actually use the mocked object, and then you can verify against it... </p>

<p>If you can't change your constructor to have a required parameter all the time, you could use a poor man's dependency injection (not recommended but might be necessary): </p>

<pre><code>public MyClass() : this(new some_type()) {}

public MyClass(some_type thetype)
{
    m_member = thetype;
}
</code></pre>
