<p><strong>Potential simple solution</strong></p>

<p>It seems to me that you're reinventing the wheel here. There are plenty of types representing a date and time already - creating your own one is likely to lead to pain.
In this case I'd recommend using <a href="http://joda-time.sourceforge.net/api-release/org/joda/time/LocalDateTime.html" rel="nofollow"><code>LocalDateTime</code></a> from <a href="http://joda-time.sf.net" rel="nofollow">Joda Time</a>.</p>

<p><strong>Answering the actual question</strong></p>

<p>You mention a "format" as if we're really dealing with strings - but I can't see anything about strings there.</p>

<p>Why are you using <code>float</code> values? These seem like natural integers - although you'll want seconds as well.</p>

<p>You could make your type implement <code>Comparable&lt;T&gt;</code> fairly easily and naturally - then you just need to call <code>Collections.sort</code> and it will do the right thing. Here's a sample implementation of <code>Comparable&lt;Foo&gt;</code>, assuming your type is called <code>Foo</code>:</p>

<pre><code>public int compareTo(Foo other)
{
    if (other == null)
    {
        throw new NullPointerException();
    }
    if (year &lt; other.year)
    {
        return -1;
    }
    if (year &gt; other.year)
    {
        return 1;
    }
    if (month &lt; other.month)
    {
        return -1;
    }
    if (month &gt; other.month)
    {
        return 1;
    }
    // etc
    // If we haven't returned after comparing everything
    // then the values must be equal
    return 0;
}
</code></pre>

<p>chburd's answer of implementing <code>Comparer&lt;T&gt;</code> instead is equally valid; if your object is <em>just</em> a date/time, then you've got a natural sort order and <code>Comparable&lt;T&gt;</code> is probably a better choice; if you actually have more properties in the object and you may want to sort by those instead, then <code>Comparer&lt;T&gt;</code> would be better.</p>
