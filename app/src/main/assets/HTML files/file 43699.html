<p>Assuming the <code>arr</code> is 16-aligned (make it so), you could do something like this (not tested)</p>

<pre><code>__m128i vstop = _mm_set1_epi16(stopValue);
__m128i vnext = _mm_set1_epi16(next);
int found_mask = 0;
int stop_mask = 0;
do
{
    __m128i data = _mm_load_si128(arrIterator++);
    __m128i contains_next = _mm_cmpeq_epi16(data, vnext);
    __m128i contains_stop = _mm_cmpeq_epi16(data, vstop);
    found_mask = _mm_movemask_epi8(contains_next);
    stopmask = found_mask | _mm_movemask_epi8(contains_stop);
} while (stopmask == 0);
</code></pre>

<p>You can then tell the index where <code>next</code> was found by doing a bitscan over <code>found_mask</code> and some stuff with the current value of the iterator.</p>
