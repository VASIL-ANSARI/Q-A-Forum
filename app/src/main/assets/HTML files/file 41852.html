<p>While I don't recommend this by any means - see my comment on the original question - nested structures typically call for recursive descent. You'd write a function that examines each of the values in a dict's values() list and does one of three things:</p>

<ul>
<li>If the value is callable, call it</li>
<li>If the value is a dictionary, make a recursive call</li>
<li>Else, skip it. </li>
</ul>

<p>Not very different from exploring a file tree, really. </p>

<p>However, and I don't apologize for repeating this, it is important to review your actual problem here and decide if this is really a thing you want to do. I can't see what problem this is a good solution for. </p>

<p>EDIT: based on further information from the OP, it looks like the @property decorator may be what's required. Example of usage:</p>

<pre><code>&gt;&gt;&gt; class Foo:
...     @property
...     def current_time(self):
...             from datetime import datetime
...             return datetime.now()
... 
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; f.current_time
datetime.datetime(2014, 12, 10, 15, 29, 35, 146096)
&gt;&gt;&gt; f.current_time
datetime.datetime(2014, 12, 10, 15, 29, 42, 383874)
</code></pre>

<p>Note that the syntax evaluates the <code>current_time</code> name as if it were a simple value, but the value returned is the result of calling the function, resulting in the value at the time of evaluation, which I think is what you're after. </p>

<p>(but as @abarnert observes, you're putting these into a dictionary, so this isn't going to work for you)</p>
