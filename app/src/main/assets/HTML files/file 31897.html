<p>To be able to access the <code>ArrayList</code> from accross methods within the <em>same</em> class, you would need to promote that local variable to a global variable (field), like below:</p>

<pre><code>public class GraphNode {
    /*Global Variables*/
    boolean visited;
    List&lt;GraphNode&gt; nodeNeighbours;
    /*Global Variables*/

    public GraphNode() {
        this.nodeNeighbours = new ArrayList&lt;GraphNode&gt;();  // store neighbors
        this.visited = false;

    }

    public void addNeighbor(GraphNode target) {
        this.nodeNeighbours.add(target);    //This will add target to the neighbours of this given node.
    }
}
</code></pre>

<p>EDIT:<br>
Shortest path algorithms (as far as memory serves) have a fixed starting point, meaning that the root will always be the same. The same can be said to their weight, which usually does not change. </p>

<p>However, as different paths are explored, the distance to the root node is most likely to change. With that in mind, you could re write your class as follows:</p>

<pre><code>public class GraphNode {
    /*Global Variables*/
    protected double weight;
    protected double distanceFromRoot;
    protected List&lt;GraphNode&gt; neighbours;
    protected boolean visited;
    /*Global Variables*/

    public GraphNode(double weight, double distanceFromRoot) {
        this.weight = weight;
        this.distanceFromRoot = distanceFromRoot;
        this.neighbours = new ArrayList&lt;GraphNode&gt;();
        this.visited = false;
    }

    public void setDistanceFromRoot(double distanceFromRoot) {
         this.distanceFromRoot = distanceFromRoot;
    }

    public void setVisited(boolean visited) {
         this.visited = visited;
    }

    public double getWeight() {
        return this.weight;
    }

    public double getDistanceFromRoot() {
        return this.distanceFromRoot;
    }

    public List&lt;GraphNode&gt; getNeighbours() {
        return this.neighbours;
    }   

    public void addNeighbour(GraphNode neighbour) {
        this.neighbours.add(neighbour)
    }
}
</code></pre>

<p>This might be a little bit more extensive than what you started with. The main change in your code is that this code promoted <em>encapsulation</em>. Encapsulation is one of the core fundamentals of OOP in which you essentially deny direct access to your global variables. The access is offered through appropriate <code>set</code> and <code>get</code> method which you can use to define how and when does someone external to your program modifies the internal state of your program.</p>
