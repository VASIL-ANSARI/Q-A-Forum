<p><code>atest().Result</code> is a synchronous call, causing a deadlock (the continuation of <code>await Task.Delay(10)</code> is trying to run on the UI thread, that is blocked by your call).</p>

<p>Two possible fixes:</p>

<ol>
<li><p>(prefered solution) Await the result instead of using the <code>Result</code> property:</p>

<pre><code>var result = await atest();
System.Console.WriteLine(result);
</code></pre></li>
<li><p>Change your asynchronous calls so the continuations won't run on the UI thread:</p>

<pre><code>await Task.Delay(10).ConfigureAwait(false);
</code></pre>

<p>and</p>

<pre><code>var result = await Thread_sleep().ConfigureAwait(false);
</code></pre></li>
</ol>

<p>As a rule of thumb, never use <code>.Result</code> or <code>.Wait()</code> on a task in a WPF application, unless you're absolutely certain that you need to. Always try to use <code>await</code> instead.</p>
