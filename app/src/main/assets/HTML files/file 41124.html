<p>It appears that <code>auto main() { }</code> is not legal in C++14. </p>

<p>[dcl.spec.auto]</p>

<blockquote>
  <p><code>2</code> The placeholder type can appear with a function declarator in the
  <em>decl-specifier-seq</em>, <em>type-specifier-seq</em>, <em>conversion-function-id</em>, or <em>trailing-return-type</em>, in any context where such a declarator is
  valid. If the function declarator includes a <em>trailing-return-type</em>
  (8.3.5), that specifies the declared return type of the function. If
  the declared return type of the function contains a placeholder type,
  the return type of the function is deduced from <code>return</code> statements in
  the body of the function, if any.</p>
  
  <p><code>10</code> If a function with a declared return type that uses a placeholder
  type has no <code>return</code> statements, the <code>return</code> type is deduced as
  though from a return statement with no operand at the closing brace of
  the function body. [ <em>Example:</em></p>

<pre><code>auto  f() { } // OK, return type is void
auto* g() { } // error, cannot deduce auto* from void()
</code></pre>
  
  <p>â <em>end example</em> ]</p>
</blockquote>

<p>This seems to imply that since there are no <code>return</code> statements, <code>main()</code> is deduced to be <code>void</code> and therefore the program is ill-formed. Yet, it leaves an ambiguity open that seems to allow the implicit <code>return 0</code> to be deduced to <code>int</code>. Oh well.</p>
