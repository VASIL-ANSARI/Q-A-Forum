<h1>Update</h1>

<p>I've taken the more recent code you've posted and made some changes to it.</p>

<h2>Summary</h2>

<p>Let's start with your comment:</p>

<blockquote>
  <p>i can't reach "GO" button from the screen.cpp unless it is global. And
  i do not want to use any globals.</p>
</blockquote>

<p>You're on the right track in trying to avoid globals. However, I don't think your <code>Screen</code> class really <em>needs</em> to know about your <code>GO</code> button. Instead, you could do what I suggested in <a href="https://chat.stackoverflow.com/rooms/94576/discussion-between-ray-and-mikhail">our discussion</a>, which is that, instead of <code>connect</code>ing your <code>GO</code> button directly to your <code>Screen</code>'s <code>generate()</code> slot, you should instead <code>connect</code> the button to a separate <code>on_button_clicked</code> event handler in your <code>Game</code> class that will:</p>

<ol>
<li>disable or disconnect the <code>GO</code> button,</li>
<li>call your <code>screen</code>'s <code>generate()</code> method, and</li>
<li>re-enable or re-connect the button after <code>generate()</code> returns.</li>
</ol>

<p>This would also imply that <code>generate()</code> may no longer need to be a slot, but that's up to you.</p>

<h2>Your Code - With My Suggested Updates</h2>

<p>I've made the following changes:</p>

<p>In <code>game.h</code>, I added a slot to the <code>Game</code> class:</p>

<pre><code>private slots:
    void on_go_clicked();
</code></pre>

<p>In <code>game.cpp</code>, I added the implementation as follows:</p>

<pre><code>void Game::on_go_clicked()
{
    GO-&gt;setEnabled(false);  // or QObject::disconnect(....)
    screen-&gt;generate();
    GO-&gt;setEnabled(true);   // or QObject::connect(....)
}
</code></pre>

<p>And <em>also replaced</em> your constructor's <code>QObject::connect</code> call with the one below:</p>

<pre><code>QObject::connect(GO, SIGNAL(clicked(bool)), this, SLOT(on_go_clicked()));
</code></pre>

<p>Now, you can keep your <code>Screen</code> class unaware of the existence of your <code>GO</code> button, which means less coupling and complexity, but still get to prevent the user from using your button in the meantime, which is what you want.</p>

<h1>Original Response</h1>

<p>Basically, you need to use <code>QObject::disconnect</code> as follows:</p>

<pre><code>QObject::disconnect(emitter, SIGNAL(signalName()), receiver, SLOT(slotName()));
</code></pre>

<p>You can do this in the slot after the event gets handled.</p>

<p>Disconnecting the signals/slots between the objects of interest is a better approach than trying to disconnect <em>all</em> signals globally for the whole application for several reasons, including unintended side-effects that may lead to bugs or other unexpected behavior.</p>

<p>In your particular example, you have:</p>

<pre><code>QObject::connect(GO, SIGNAL(clicked(bool)), screen, SLOT(generate()));
</code></pre>

<p>So to disconnect, you may only need to write this when you start processing:</p>

<pre><code>QObject::disconnect(GO, SIGNAL(clicked(bool)), screen, SLOT(generate()));
</code></pre>

<p>And then re-connect after you're done processing.</p>

<p>Or, as @Matt said in a comment, you could simply <em>disable</em> the button widget in the user interface and not mess around with the signals. If the user cannot click the button, then the signal cannot be emitted by the user.</p>

<p>This is probably a simpler and more reliable solution.</p>

<h3>Signal-Blocking Update</h3>

<p>If you still want to connect/disconnect <em>and</em> you're using Qt 5.3+, then you should use <a href="http://doc.qt.io/qt-5/qsignalblocker.html#details" rel="nofollow"><code>QSignalBlocker</code></a>, which also takes care of preserving and restoring things back to their previous state. Quoting from their docs:</p>

<blockquote>
<pre><code>{
const QSignalBlocker blocker(someQObject);
// no signals here
}
</code></pre>
  
  <p>is thus equivalent to</p>

<pre><code>const bool wasBlocked = someQObject-&gt;blockSignals(true);
// no signals here
someQObject-&gt;blockSignals(wasBlocked);
</code></pre>
</blockquote>

<h1>Working Sample Code</h1>

<p>A short example app consisting of a window with a <code>QPushButton</code> and a <code>QListWidget</code> in a <code>QMainWindow</code> follows below.</p>

<h3>mainwindow.cpp</h3>

<pre><code>#include "mainwindow.h"
#include "ui_mainwindow.h"

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::on_button_clicked()
{
    ui-&gt;listWidget-&gt;addItem(QString("Clicked"));

    // this is the important line :o
    QObject::disconnect(ui-&gt;button, SIGNAL(clicked(bool)), this, SLOT(on_button_clicked()));
}
</code></pre>

<h3>mainwindow.h</h3>

<pre><code>#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &lt;QMainWindow&gt;

namespace Ui {
    class MainWindow;
}

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();

private slots:
    // this naming convention allows Qt to
    // create connections automatically
    void on_button_clicked();

private:
    Ui::MainWindow *ui;
};

#endif // MAINWINDOW_H
</code></pre>

<h3>main.cpp</h3>

<pre><code>#include "mainwindow.h"
#include &lt;QApplication&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.show();

    return a.exec();
}
</code></pre>

<h3>mainwindow.ui</h3>

<p>You can copy-paste the contents of the .ui file to reproduce the simple layout if needed. It's below:</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ui version="4.0"&gt;
 &lt;class&gt;MainWindow&lt;/class&gt;
 &lt;widget class="QMainWindow" name="MainWindow"&gt;
  &lt;property name="geometry"&gt;
   &lt;rect&gt;
    &lt;x&gt;0&lt;/x&gt;
    &lt;y&gt;0&lt;/y&gt;
    &lt;width&gt;400&lt;/width&gt;
    &lt;height&gt;300&lt;/height&gt;
   &lt;/rect&gt;
  &lt;/property&gt;
  &lt;property name="windowTitle"&gt;
   &lt;string&gt;MainWindow&lt;/string&gt;
  &lt;/property&gt;
  &lt;widget class="QWidget" name="centralWidget"&gt;
   &lt;layout class="QVBoxLayout" name="verticalLayout_2"&gt;
    &lt;item&gt;
     &lt;widget class="QPushButton" name="button"&gt;
      &lt;property name="text"&gt;
       &lt;string&gt;Click Me&lt;/string&gt;
      &lt;/property&gt;
     &lt;/widget&gt;
    &lt;/item&gt;
    &lt;item&gt;
     &lt;widget class="QListWidget" name="listWidget"/&gt;
    &lt;/item&gt;
   &lt;/layout&gt;
  &lt;/widget&gt;
  &lt;widget class="QMenuBar" name="menuBar"&gt;
   &lt;property name="geometry"&gt;
    &lt;rect&gt;
     &lt;x&gt;0&lt;/x&gt;
     &lt;y&gt;0&lt;/y&gt;
     &lt;width&gt;400&lt;/width&gt;
     &lt;height&gt;27&lt;/height&gt;
    &lt;/rect&gt;
   &lt;/property&gt;
  &lt;/widget&gt;
  &lt;widget class="QToolBar" name="mainToolBar"&gt;
   &lt;attribute name="toolBarArea"&gt;
    &lt;enum&gt;TopToolBarArea&lt;/enum&gt;
   &lt;/attribute&gt;
   &lt;attribute name="toolBarBreak"&gt;
    &lt;bool&gt;false&lt;/bool&gt;
   &lt;/attribute&gt;
  &lt;/widget&gt;
  &lt;widget class="QStatusBar" name="statusBar"/&gt;
 &lt;/widget&gt;
 &lt;layoutdefault spacing="6" margin="11"/&gt;
 &lt;resources/&gt;
 &lt;connections/&gt;
&lt;/ui&gt;
</code></pre>
