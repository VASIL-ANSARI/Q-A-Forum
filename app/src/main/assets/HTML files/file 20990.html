<p>When the interpreter is going through this file, it is assigning classes like this:  </p>

<pre><code>OuterClass = Class.new do 
  def foobar
    puts "FOOBAR"
  end

  InnerClass = Class.new do   
    def barfoo
      puts "BARFOO"
    end
  end
end
</code></pre>

<p>So when Ruby encounters the nested class, it assigns it to constant <code>InnerClass</code> which is assigned to constant <code>OuterClass</code>  They have no relation to each other whatsoever.  </p>

<p>The <code>InnerClass</code> has no inheritance to <code>OuterClass</code>:</p>

<pre><code>  InnerClass.ancestors
  =&gt; [InnerClass, Object, Kernel, BasicObject]
</code></pre>

<p>When you call <code>OuterClass::InnerClass</code> constant you are refering to the <code>InnerClass</code> constant that is namespaced under the <code>OuterClass</code> contstant which equals the Class.new statement assigned to it.</p>

<p>A good book to read about this is "Metaprogramming Ruby".  It goes into the details of classes, singletons, modules etc.</p>
