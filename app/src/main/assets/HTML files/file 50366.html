<p>Assuming that double-quotes are not allowed, except for the opening and closing quotes ahead of the "at" sign <code>@</code>, you can use this regular expression to capture e-mail addresses:</p>

<pre><code>((?:[^@"]+|"[^"]*")@[^;]+)(?:;|$)
</code></pre>

<p>The idea is to capture either an unquoted <code>[^@"]+</code> or a quoted <code>"[^"]*"</code> part prior to <code>@</code>, and then capture everything up to semicolon <code>;</code> or the end anchor <code>$</code>.</p>

<p><a href="https://regex101.com/r/lX7pB1/1">Demo of the regex.</a></p>

<pre><code>var input = "\"one@tw;,.'o\"@hotmail.com;\"some;thing\"@example.com;hello@world";
var mm = Regex.Matches(input, "((?:[^@\"]+|\"[^\"]*\")@[^;]+)(?:;|$)");
foreach (Match m in mm) {
    Console.WriteLine(m.Groups[1].Value);
}
</code></pre>

<p>This code prints</p>

<pre><code>"one@tw;,.'o"@hotmail.com
"some;thing"@example.com
hello@world
</code></pre>

<p><a href="http://ideone.com/o6YZ1z">Demo 1.</a></p>

<p>If you would like to allow escaped double-quotes inside double-quotes, you could use a more complex expression:</p>

<pre><code>((?:(?:[^@\"]|(?&lt;=\\)\")+|\"([^\"]|(?&lt;=\\)\")*\")@[^;]+)(?:;|$)
</code></pre>

<p>Everything else remains the same.</p>

<p><a href="http://ideone.com/XUTcno">Demo 2.</a></p>
