<p>It's a little of both. In order to use a generic class, you have to give it a type parameter at compile time, but the type parameter could be of an interface or base class, so the actual, concrete type of the objects used at runtime can vary.</p>

<p>For example, here I have a snippet of code with a <code>Stack&lt;T&gt;</code> field. I've chosen to use an interface as the type parameter. This utilizes <a href="http://en.wikipedia.org/wiki/Polymorphism_%28computer_science%29#Parametric_polymorphism" rel="nofollow">parametric polymorphism</a> at compile time. You must choose which type parameter your <code>_stack</code> field will use at compile time:</p>

<pre><code>public interface IFoo { void Foo(); }

public Stack&lt;IFoo&gt; _stack = new Stack&lt;IFoo&gt;();
</code></pre>

<p>Now, when this snippet of code is actually run, I can use any object whose class implements <code>IFoo</code>, and that decision doesn't have to be made until run time:</p>

<pre><code>public class Foo1 : IFoo { public void Foo() { Console.WriteLine("Foo1"); } }

public class Foo2 : IFoo { public void Foo() { Console.WriteLine("Foo2"); } }

public class Foo3 : IFoo { public void Foo() { Console.WriteLine("Foo2"); } }

_stack.Push(new Foo1());
_stack.Push(new Foo2());
_stack.Push(new Foo3());
</code></pre>

<p>This is an example of <a href="http://en.wikipedia.org/wiki/Polymorphism_%28computer_science%29#Subtype_polymorphism_.28or_inclusion_polymorphism.29" rel="nofollow">subtype polymorphism</a>, which is utilized at run time.</p>
