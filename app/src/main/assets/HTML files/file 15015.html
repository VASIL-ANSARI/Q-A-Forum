<p>With you construction it seems impossible to get <code>this == this-&gt;prev</code>. However, this only hold is object stay around long enough. I would suspect that they don't. The easiast way to prove this is to assert the value of <code>prev</code>:</p>

<pre><code>A::A(A* p): prev(p) { assert(this != this-&gt;prev); }
A::A(A const&amp; a): prev(a.prev) { assert(this != this-&gt;prev); }
A&amp; A::operator= (A const&amp; a) {
    this-&gt;prev = a.prev;
    assert(this != this-&gt;prev); 
}
</code></pre>

<p>I suspect that the original object which was referenced went away at some point and the location gets reused by an object unluckily referencing itself. You happy passing of object around combined with keeping pointer to these objects makes it a likely candidate. With you incomplete (and mostly irrelevant) code the problem can't be reproduced so I couldn't confirm if this indeed the problem.</p>
