<p>I'll answer with an example:</p>

<pre><code>module M
  def self.included base
    puts "M included in #{base}"
  end
end

module N
  include M

  def self.included base
    puts "N included in #{base}"
  end
end

class C
  include M
  include N
end

p C.ancestors
</code></pre>

<p>prints</p>

<pre><code>M included in N
M included in C
N included in C
[C, N, M, Object, Kernel, BasicObject]
</code></pre>

<p>As we can see, <code>M</code> is included only once into <code>C</code>. Though <em>technically</em> it was included twice since it was included into <code>N</code> which was also included into <code>C</code>. Does this matter? Probably not. Each still only occurs once in the ancestor chain, and any methods would've been overridden with equivalent implementationsâi.e., essentially a no-op. Unless you're doing something exotic with the <code>included</code> hook, you're unlikely to notice anything.</p>
