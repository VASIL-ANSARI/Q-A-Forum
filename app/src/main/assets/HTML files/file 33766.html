<h2>tl;dr</h2>

<p>A <code>Date</code> has no timezone associated with it, so you cannot create a method that adjusts the timezone of a date object. You need to work with <code>Calendar</code> objects if you want to retain TZ information or, preferably, take a look at <a href="http://www.joda.org/joda-time/" rel="nofollow">Joda-Time</a>.</p>

<h2>Explanation of Your Output</h2>

<p>A <code>Date</code> value has no timezone information; it's merely the number of milliseconds since the epoch. With that in mind, let's see what you're doing:</p>

<pre><code>SimpleDateFormat sdf = new SimpleDateFormat();
sdf.setTimeZone(timeZone);
sdf.applyPattern("dd-MM-yyyy HH:mm:ss");
String newDate = sdf.format(date);
</code></pre>

<p>This part of your code creates a formatter that will print the date in the London timezone. So the result you'll get at the time of writing is approximately: <code>17-04-2014 11:38:15</code> (assuming you just created your date object).</p>

<pre><code>sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
try {
  Date nd = sdf.parse(newDate);
  return nd;
} catch (ParseException e) {
   return null;
}
</code></pre>

<p>Here you tell the date parser to read the date as though it were a UTC date. It uses that information to know how many milliseconds since the epoch have passed. The date object you get back <em>still has no timezone associated with it</em>.</p>

<p>UTC is an hour behind British Summer Time, so it will create a date object that appears an hour ahead when printed in the BST timezone. So when I print <code>nd</code>, I get: <code>Thu Apr 17 12:38:15 BST 2014</code>.</p>
