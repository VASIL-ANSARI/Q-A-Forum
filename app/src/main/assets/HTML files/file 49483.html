<p>You can only use aggregate functions like <code>COUNT()</code> in a <code>HAVING</code> clause, or in the <code>SELECT</code> clause when a <code>GROUP BY</code> is used. The <code>WHERE</code> clause operates on rows that come from the <code>FROM</code> clause. No aggregation has taken place, so there is no way for the aggregate functions to be meaningful.</p>

<p>It looks like what you want to do is find from the ENROLL table all students that appear more than once. Then you want to get more details about those students. There are potentially many ways to do this, but I'd recommend a subquery.</p>

<pre><code>SELECT s.*
  FROM student AS s
  JOIN (
    SELECT e.sno
      FROM enroll AS e
     GROUP BY e.sno
    HAVING COUNT(*) &gt; 1
  ) AS e
    ON e.sno = s.sno
 ORDER BY s.age DESC
 LIMIT 10
</code></pre>

<p>The subquery there after <code>JOIN</code> does that first calculation (which students have multiple rows in ENROLL) and basically produces a pseudo-table with a list of student IDs. Since we're doing an inner join, only rows in the STUDENT table that have an <code>sno</code> in our subquery will show up. That's basically taken care of by the <code>ON</code> clause.</p>

<p>Since you said in a comment that you want to be able to apply additional conditions on the students, I've added in some example code where that would happen. Since that information comes from the STUDENT table, it can be done outside the subquery. You didn't specifically specifically what "oldest students" mean, so I've just assumed you wanted the 10 oldest enrolled in multiple courses. You should be able to adjust based on your needs.</p>

<p>Let me know if any of this doesn't make sense and I'll try to explain in more detail.</p>
