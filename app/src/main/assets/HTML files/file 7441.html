<p>The only nice way I can think of is actually not an extension but a wrapper:</p>

<pre><code>class Player {
    private final static Charachter me = new Character();

    public static doSomething(){ me.doSomething(); }
}
</code></pre>

<p>Of course you can also extend AND wrap:</p>

<pre><code>class Player extends Character {

    private final static Player me = new Player();

    // if you don't want anyone creating player objects
    // make the constructor private:
    private Player(){ super(); }

    public void doSomething(){
        // stuff
    }

    public static void staticDoSomething(){ me.doSomething(); }
}
</code></pre>

<p>Or, actually, since your goal is just to guarantee that there is a single player object, you can forget about making the methods static, but hide the constructor(s):</p>

<pre><code>class Player extends Character {

    private static Player thePlayer = null;

    public static Player getPlayer(){
        if( thePlayer == null ){
            // Create the player
            thePlayer = new Player();
        }
        // There is a valid player object, so return it.
        return thePlayer;
    }

    // hide the constructor(s) by making them private:

    private Player(){ super(); }
}
</code></pre>

<p>That ensures that the only way to get a <code>Player</code> is to call <code>Player.getPlayer()</code>, and that it always gives you the same object (you never create more than one).</p>
