<p>Declaring a method using prototype will mean the method is available to an instance of that prototype at any time, as long as that instance is created after the method is declared. </p>

<p>Declaring it in the constructor using <code>this.foo = function(){ ... }</code> means the method will only be available after the point in the constructor where it is declared.</p>

<p>As a simple example lets look at named and anonymous functions.</p>

<p>In the following, we declare a named function and call it twice. Notice that the function executes fine from the first call even though the first call is before the declaration of the function:</p>

<pre><code>foo();

function foo()
{
    alert("foo");
}

foo();
</code></pre>

<p>now, instead of a named function we'll use an anonymous function stored in a variable: Notice now that the first call causes an error because <code>foo</code> is undefined at this point.</p>

<pre><code>foo();

var foo = function()
{
    alert("foo");
}

foo();
</code></pre>

<p>Prototypes work in a (conceptually) similar way, when we change the prototype of a function, we're affecting it before the instance of that function is created. So the following works fine: </p>

<pre><code>function f ()
{
    this.bar();
}

f.prototype.bar = function()
{
    alert("bar");
};

var f1 = new f();
</code></pre>

<p>Notice that <code>f.prototype.bar</code> is physically declared after the line where we're calling it. Now compare that with the <code>this. ...</code> method. The following works as expected</p>

<pre><code>function g()
{
    this.h = function(){
        alert("h");
    };

    this.h();
}

var g1 = new g();
</code></pre>

<p>while this does not because we're trying to call <code>this.h</code> before we've assigned a value to it:</p>

<pre><code>function g()
{
    this.h();

    this.h = function(){
        alert("h");
    };
}

var g2 = new g();
</code></pre>

<p>Notice though that affecting the prototype of an function still uses the mechanism of assigning anonymous functions to properties of the prototype. What this means is that even using the prototype method, we can get errors if we instantiate an instance of the prototype before we've added a function to the prototype. For example, the following works fine:</p>

<pre><code>function f ()
{
    this.bar();
}

f.prototype.bar = function()
{
    alert("bar");
};

var f1 = new f();
</code></pre>

<p>but if we move the <code>var f1 = new f();</code> above the assignment to <code>f.prototype.bar</code> we get the an error:</p>

<pre><code>function f ()
{
    this.bar();
}

var f1 = new f();

f.prototype.bar = function()
{
    alert("bar");
};
</code></pre>
