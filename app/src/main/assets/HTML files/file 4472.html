<p>When <code>yield!</code> appears in a <strong>non-tail-call position</strong>, it essentiall means the same thing as:</p>

<pre><code>for v in &lt;expr&gt; do yield v
</code></pre>

<p>The problem with this (and the reason why is that quadratic) is that for recursive calls, this creates a chain of iterators with nested <code>for</code> loops. You need to iterate over the whole sequence generated by <code>&lt;expr&gt;</code> for every single element, so if the iteration is linear, you get a quadratic time (because the linear iteration happens for every element). </p>

<p>Let's say the <code>rwalk</code> function generates <code>[ 9; 2; 3; 7 ]</code>. In the first iteration, the recursively generated sequence has 4 elements, so you'd iterate over 4 elements and add 1. In the recursive call, you'd iterate over 3 elements and add 1, etc.. Using a diagram, you can see how that's quadratic:</p>

<pre><code>x
x x 
x x x
x x x x
</code></pre>

<p>Also, each of the recursive calls creates a new instance of object (<code>IEnumerator</code>) so there is also some memory cost (although only linear).</p>

<p>In a <strong>tail-call position</strong>, the F# compiler/librar does an optimization. It "replaces" the current <code>IEnumerable</code> with the one returned by the recursive call, so it doesn't need to iterate overe it to generate all elements - it is simply returned (and this also removes the memory cost).</p>

<p><strong>Related.</strong> The same problem has been discussed in the C# lanaugage design and there is an <a href="http://research.microsoft.com/en-us/projects/specsharp/iterators.pdf">interesting paper about it</a> (their name for <code>yield!</code> is <code>yield foreach</code>).</p>
