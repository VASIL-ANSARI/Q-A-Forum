<p>The biggest interest of genine (pthread) threads is to enable parallel execution (taking profit of the several cores most laptops and desktops have)...
Read some <a href="https://computing.llnl.gov/tutorials/pthreads/" rel="nofollow">pthread tutorial</a> ...</p>

<p>You may want to use barriers. Read more about <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_barrier_wait.html" rel="nofollow">pthread_barrier_wait</a> &amp; <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_barrier_init.html" rel="nofollow">pthread_barrier_init</a></p>

<p>If you want to serialize some counter, you could use (with recent C11 compilers, e.g. <a href="http://gcc.gnu.org/" rel="nofollow">GCC</a> 4.9) some <a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html" rel="nofollow">atomic builtins</a>, or more usually a <a href="http://en.wikipedia.org/wiki/Mutual_exclusion" rel="nofollow">mutex</a>, see <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_mutex_init.html" rel="nofollow">pthread_mutex_init</a> &amp; <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_mutex_lock.html" rel="nofollow">pthread_mutex_lock</a> etc....:</p>

<pre><code> static pthread_mutex_t mtx = PTHREAD_MUTEX_INIT;

 static long counter;

 void increment_serialized_counter (void) {
     pthread_mutex_lock(&amp;mtx);
     counter++;
     pthread_mutex_unclock(&amp;mtx);
 }

 long get_serialized_counter (void) {
    long r = 0;
    pthread_mutex_lock(&amp;mtx);
    r = counter;
    pthread_mutex_unclock(&amp;mtx);
    return r;
 }
</code></pre>

<p>You probably should use a mutex for your <code>message</code> variable, if it was static!</p>
