<p>let me try to propose a solution. Initially compute the values of L[i][0] and L[0][j]. Now start iterating from i=1 and j=1. Now the check for i==0 or j==0 in each iteration of the loop can be removed. And one more advantage of this is that for every L[i][j] in each iteration on a row, the value of L[i-1][j-1] is available. Now, say if the vector registers can hold 4 elements of the array. Now we can load 4 elements of refSeq, otherSeq, L(previous row) and L(current row). Theoretically we get vectorization now. I assume auto vectorizer will not recognize this. So we have to manually do it. Please correct me if I'm wrong.</p>

<pre><code>for(size_t i=0;i&lt;refSeq.length()/4;i++)
{
    if(refSeq[i]==otherSeq[0])
        L[i][0]=1;
    else
        L[i][0]=0;
}
for(size_t j=0; j&lt;otherSeq.length();j++)
{
    if(refSeq[0]==otherSeq[j])
        L[0][j]=1;
    else
        L[0][j]=0;
}

for(size_t i=1;i&lt;refSeq.length()/4;i++)
{
    for(size_t j=1; j&lt;otherSeq.length();j++)
    {
        if(refSeq[i]==otherSeq[j])
            L[i][j] = L[i-1][j-1] + 1;
        else
            L[i][j]=0;
    }
}
</code></pre>

<p>One disadvantage would be that now we are loading the previous row no matter if refSeq[i] is equal to otherSeq[j] or not as with the original code where the diagonal element is accessed only if the sequences are equal.</p>
