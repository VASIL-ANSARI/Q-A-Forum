<p>When an image is loaded for the first time in a Web browser, there is a certain degree of latency that is involved when the browser downloads the image. </p>

<p>In general, most websites have a lot of moving parts. When an HTML document is downloaded by the browser, the browser will then start processing all of the elements and events that are represented by the HTML elements in the HTML document.</p>

<p>For instance, CSS begins loading when link tags are encountered. JavaScript is loading for script elements. Other HTML elements are added to the DOM. As this happens, events are triggered that send requests to the server to download these resources. </p>

<p>When an <code>img</code> tag is added to the DOM, a request is sent to the server to retrieve the resource identified by the src attribute. Once the image is fully downloaded, it is rendered on the page.</p>

<p>Assuming we're working with images that are appropriate sizes for a Website, when we load an image normally, without effects, we don't really notice the latency because the image is more or less instantly displayed as soon as it's done downloading. </p>

<p>However, when we add in effects, such as fadeIn and fadeOut, the effects of the latency become quite clear. This occurs because the JavaScript events actually start modifying the CSS properties of the img element, even though the actual resource isn't ready.</p>

<p>Thus, the fadeIn and fadeOut events fire as soon as the DOM element is added to the DOM, not when the image is done loading. In other words, The fadeIn or fadeOut actions occur while the image is still being downloaded. This creates a jarring effect, as a partially faded yet unrendered image may suddenly appear and then fade slowly in the rest of the way. </p>

<p>This action is not the smooth, gradual effects we're looking for.</p>

<p>Now, you may notice that this doesn't happen the 2nd, 3rd, 4th, or nth time you load the image. With the image being cached by the browser, the latency is greatly reduced, and the fadeIn/fadeOut effects appear as they should. Smooth and gradual.</p>

<p>The technique I normally use when fading in an image is to first preload it. While there are libraries out there that will preload all of your images for you, here is a very simple, fast technique for preloading an image, before you apply your fadeIn event:</p>

<p><strong>Place the image in the HTML as a hidden image:</strong></p>

<pre><code>&lt;!-- Hidden by default, but now preloaded for a smooth fadeIn effect --&gt;
&lt;img id="myImage" src="/images/myImage.png" style="display:none" /&gt;
</code></pre>

<p><strong>Use jQuery to add the hidden image while binding click events:</strong></p>

<p>If the image is something that will fadeIn after a click event occurs, I've found this technique to be quite helpful:</p>

<pre><code>// preload the image while registering the click event
$('&lt;img id="myImage" src="/images/myImage.png" style="display:none" /&gt;')
    .append("body");

$('button').click(function() {
    $('#myImage').fadeIn();
});
</code></pre>

<p><strong>Use jQuery's load event to preload the image as it's needed:</strong></p>

<p>It's possible the user may never click the button to show the image; thus, here is a technique to preload the image when it's requested, but still without jarring the user. Should the user decide not to click on the button, the resource will never be requested from the server. Furthermore, since we wait for the image to load before firing the fadeIn event, we also still get the smoothness we're looking for but with a possible, slight delay before the process begins.</p>

<pre><code>// preload the image while registering the click event

$('button').click(function() {
    // place img element on page without specifying the src attribute
    $('&lt;img id="myImage" style="display:none" /&gt;').append("body");

    // bind a load event to the image element so fadeIn doesn't start until
      // the image is completely downloaded
    $('#myImage').load(function() { 
        $(this).fadeIn();   // fade in the image
    });

});
</code></pre>
