<p>In the second code, you're <em>synchronously</em> waiting for the continuation to complete. In the first version, the method will return to the caller as soon as it hits the first <code>await</code> expression which isn't already completed.</p>

<p>They're very similar in that they both schedule a continuation, but as soon as the control flow gets even slightly complex, <code>await</code> leads to <em>much</em> simpler code. Additionally, as noted by Servy in comments, awaiting a task will "unwrap" aggregate exceptions which usually leads to simpler error handling. Also using <code>await</code> will implicitly schedule the continuation in the calling context (unless you use <code>ConfigureAwait</code>). It's nothing that can't be done "manually", but it's a lot easier doing it with <code>await</code>.</p>

<p>I suggest you try implementing a slightly larger sequence of operations with both <code>await</code> and <code>Task.ContinueWith</code> - it can be a real eye-opener.</p>
