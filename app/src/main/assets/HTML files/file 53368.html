<p>The best (and fastest, by far) way to approach this is <a href="https://en.wikipedia.org/wiki/Convolution" rel="nofollow">convolution</a>. Using <a href="http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.convolve.html" rel="nofollow">numpy's convolve</a>:</p>

<pre class="lang-py prettyprint-override"><code>import numpy as np

x = np.asarray([7.0, 9.0, 5.0, 1.0, 3.0])

# create what's known as the convolution 'kernel'
# note that this sums to 1, which results in an average
kernel = np.ones(3) / 3

# do the convolution to compute the moving average
moving_avg = np.convolve(x, kernel, mode='valid')
</code></pre>

<p>You can view the convolution operation as the kernel "sliding" over the data sequence. Every point <code>moving_avg[k]</code> in the output of the convolution will be the area under the product between your data and the kernel, when the kernel is centered at that point <code>k</code>.</p>

<p>This is an animation (from the wikipedia article linked above) illustrating the principle for the square kernel used in moving average computation:</p>

<p><a href="http://i.stack.imgur.com/9truS.gif" rel="nofollow"><img src="http://i.stack.imgur.com/9truS.gif" alt="enter image description here"></a></p>
