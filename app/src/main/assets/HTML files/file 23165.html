<p>Your <code>Range#+</code> method returns <code>nil</code> when <code>if</code> condition is false. Here's what happens:</p>

<pre><code>class Range
  def +(range)
    puts "me: #{self}"
    puts "him: #{range}"
    res = (self.begin..range.end) if self.end &lt; range.end &amp;&amp; range.include?(self.end)
    puts "returning #{res.inspect}"
    res
  end
end

ary = [(1..2), (1..3), (3..4), (0..9)]
buf = ary[0]
i = 0
while i &lt; ary.size
  buf = buf + ary[i]
  i+=1
end
# &gt;&gt; me: 1..2
# &gt;&gt; him: 1..2
# &gt;&gt; returning nil
</code></pre>

<h2>Solution?</h2>

<p>Stop making unidiomatic loops and use the <a href="http://ruby-doc.org/core-2.0/Enumerable.html#method-i-reduce" rel="nofollow">power of standard library</a>. 99 of 100 times when you want to iterate a collection by manually tracking/updating current index - it's a bad idea. When you're new - it's 100 of 100. </p>

<pre><code>ary = [(1..2), (1..3), (3..4), (0..9)]
ary.reduce(:+) # =&gt; 1..9

# &gt;&gt; me: 1..2
# &gt;&gt; him: 1..3
# &gt;&gt; returning 1..3
# &gt;&gt; me: 1..3
# &gt;&gt; him: 3..4
# &gt;&gt; returning 1..4
# &gt;&gt; me: 1..4
# &gt;&gt; him: 0..9
# &gt;&gt; returning 1..9
</code></pre>
