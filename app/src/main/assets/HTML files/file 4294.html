<p>The only way to know which is faster is to profile two or more implementations. As a concrete example, this <a href="https://sites.google.com/site/drjohnbmatthews/kineticmodel" rel="nofollow">kinetic model</a> shows a slight advantage for <em>Gradient</em> mode, using <code>drawImage()</code>, over <em>Color</em> mode, using <code>fill()</code>, as seen in the <a href="https://sites.google.com/site/drjohnbmatthews/kineticmodel/code#DisplayPanel" rel="nofollow"><code>paintComponent()</code></a> method of <code>DisplayPanel</code>. In this context, <code>AffineTransform</code> is beneficial in pre-rendering the more complex gradient image.</p>

<p>Addendum:</p>

<blockquote>
  <p>I don't know how to properly implement <code>AffineTransform</code> to move/copy ovalsâ¦</p>
</blockquote>

<p>I doubt that <code>AffineTransform</code> is the cure. Instead, move the object creation out of the loop, as @camickr suggests. In the <a href="https://sites.google.com/site/drjohnbmatthews/kineticmodel" rel="nofollow">example</a>, note how an <code>Ensemble</code> only needs one <code>Ellipse2D</code>; it uses <code>setFrame()</code> repeatedly. Also, each <code>Particle</code> already <em>knows</em> its <code>Color</code>. Finally, observe how the <a href="https://sites.google.com/site/drjohnbmatthews/kineticmodel" rel="nofollow">example</a> measures paint time.</p>
