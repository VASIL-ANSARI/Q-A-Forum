<p>I believe you are trying to achieve total decoupling between your projets but in an unorthodox way. </p>

<p>First of all, using <code>provided</code>, means that while the library is present at compile time, it will not be added to your deployable (the war in this case) because it is assumed to be present in the platform where you deploy. Think of a similar case when using the servlet api but you do not need it as an explicit dependency at runtime because your servlet container <code>provides</code> it.  It does not give you decoupling but a way to prevent dependency duplication. So in your case, the web application and serviceUtilities.jar do not know anything about your service.jar at runtime, while they do at compile time. </p>

<p>It is very difficult to be able to access the jars directly as you say (even using reflection - it is still a binary dependency), while keeping the projects' lifecycle independent. </p>

<p>I think the best way to get total decoupling between layers is to use <code>Rest + Json</code> for communication. You may even be able to deploy your layers in separate nodes. As long as the services contract does not change (the rest urls in this case) you are safe to even switch between different implementations or expose multiple front ends<br>
Your serviceUtilities in the web side will then be replaced by code that uses some rest client library and your service layer will also use some rest service provider to listen to your rest urls.  Which technology you use depends on your preference and technology stack.  <a href="https://jersey.java.net/" rel="nofollow">Jersey</a> is the reference implementation for JAX-RS, while you can also easily use spring controllers in the provider side.</p>
