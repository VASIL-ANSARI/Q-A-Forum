<p>From what I can tell your code...</p>

<pre><code>//I am Getting error here i.e C-style for statement has been removed in Swift 3
for var index = trimmedString.startIndex; index &lt; trimmedString.endIndex; index = Collection.index(after: Collection.index(after: index)) {
    let byteString = trimmedString.substring(with: (index ..&lt; Collection.index(after: Collection.index(after: index))))
    let num = UInt8(byteString.withCString { strtoul($0, nil, 16) })
    data?.append([num] as [UInt8], length: 1)
}
</code></pre>

<p>Is iterating through the indices of the <code>trimmedString</code> but going 2? at a time?</p>

<p>If <code>index</code> is 0 (which it is to start) then the next index will be...</p>

<p>index after index after index... 2 after 1 after 0</p>

<p>So 2? Then 4? Then 6?</p>

<p>Then you're getting the substring from that index to the next index?</p>

<p>Then you're creating a <code>UInt8</code> from it and appending it to some data...</p>

<p>So...</p>

<p>I guess the easiest change would be a <code>while</code> loop...</p>

<pre><code>var index = trimmedString.startIndex

while index &lt; trimmedString.endIndex {
    // note I used the ... for the range to avoid the repeated... index after index after index
    let byteString = trimmedString.substring(with: (index ... Collection.index(after: index)))
    let num = UInt8(byteString.withCString { strtoul($0, nil, 16) })
    data?.append([num] as [UInt8], length: 1)

    // check the docs, there are easier ways of moving the index by more than one place.
    index = Collection(index, offsetBy: 2)
}
</code></pre>

<p>Something like that should work as an initial change.</p>

<p><strong>Much better approach suggested by @vadian</strong></p>

<p>As pointed out by @vadian there is a much simpler and more elegant way of doing all of this in one line of code...</p>

<pre><code>let enCodedUTF8String = data.map{ String(format: "%02x", $0) }.joined()
</code></pre>

<p>I thought that would be the case but I wasn't able to come up with it myself.</p>
