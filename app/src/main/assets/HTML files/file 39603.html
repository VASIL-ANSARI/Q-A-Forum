<p><code>#3</code> can be used to specialize template functions in one compilation unit without having to update other compilation units.</p>

<p>Let's say we have <code>z.cpp</code> which looks like this:</p>

<pre><code>template &lt;class T&gt; void foo (T*) { puts("1"); }
template &lt;class T&gt; void foo (T) { puts("2"); }
template &lt;&gt; void foo (int*) { puts("3"); }
void foo(int*) { puts("4"); }

int dummy() {
    foo((int*)NULL);    
    foo&lt;int&gt;((int*)NULL);
    foo(4);    
    foo((long*)NULL);    
}
</code></pre>

<p>and <code>y.cpp</code> which looks like this:</p>

<pre><code>#include &lt;stdio.h&gt;

template &lt;class T&gt; void foo (T*);
template &lt;class T&gt; void foo (T);

int main() {
    foo((int*)NULL);    
    foo&lt;int&gt;((int*)NULL);
    foo(4);    
    foo((long*)NULL);    
}
</code></pre>

<p>The first lines of main will refer to <code>#3</code> and not <code>#4</code>. This means that we can specialize <code>foo</code> for other types in <code>z.cpp</code> without having to change <code>y.cpp</code>. </p>

<p>With <code>#4</code>, you would have to update <code>y.cpp</code> everytime you added a new overload.</p>
