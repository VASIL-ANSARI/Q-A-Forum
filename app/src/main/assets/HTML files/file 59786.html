<p>The "more assertThat" way of doing things would be:</p>

<pre><code>Map&lt;String, Object&gt; expectedData = Collections.singletonMap("key", "value");

asssertThat(data, is(expectedData));
</code></pre>

<p>Please note:</p>

<ul>
<li>Maybe you need type hints for the call to singletonMap</li>
<li>Besides the <em>is</em> matcher, there are other matchers that would allow you to check that data <em>contains</em> your "expected" map data</li>
</ul>

<p>For your specific problem: that is caused because how generics come into play here; it might be sufficient to use <code>(String) data.get("key")</code> - to tell the compiler that the "actual" argument is of type String.</p>

<p>In the end - I have no idea what your problem is. I wrote down this piece of code:</p>

<pre><code>public void test() {
    Map&lt;String, Object&gt; data = new HashMap&lt;&gt;();
    data.put("key", "value");
    assertThat(data.get("key"), is("value"));

    Map&lt;String, Object&gt; expectedData = Collections.singletonMap("key", "value");
    assertThat(data, is(expectedData));
}
</code></pre>

<p>It compiles fine, and the unit test runs and passes. In other words: actually I am unable to repro your problem.</p>
