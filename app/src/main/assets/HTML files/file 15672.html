<p>Sounds to me like you are expecting a <code>java.zip.deflate</code> read of 35mb to run faster when you add multiple threads doing the <em>same job</em>.  It won't.  In fact, although you may not be IO bound, you are still incurring kernel overhead with each thread that you add -- buffer copies, etc..  Even if you are reading entirely out of kernel buffer space, you incur CPU and processing overhead.</p>

<p>That said, I am surprised that you incur 1.5 to 10 times slower.  If each of your processing threads is then writing output then obviously that won't be cached.</p>

<p>However I suspect that you may be incurring memory contention.  If you are handling a Java serialized object stream, you need to watch your memory consumption unless you are resetting it often.  Serialization keeps a lot of references around to objects so that large contiguous streams can generate a tremendous amount of GC bandwidth.</p>

<p>I'd connect to your program using jconsole and watch the memory tab closely.  As the survivor and old-gen spaces fill you <em>will</em> see non-linear CPU implications.</p>
