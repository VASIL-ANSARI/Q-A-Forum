<p>If you want to find just the dominant mode of an array, and do it recursively, here's the pseudo-code:</p>

<pre><code>def DominantMode(array):
    # if there is only one element, that's the dominant mode
    if len(array) == 1: return array[0]
    # otherwise, find the dominant mode of the left and right halves
    left = DominantMode(array[0:len(array)/2])
    right = DominantMode(array[len(array)/2:len(array)])
    # if both sides have the same dominant mode, the whole array has that mode
    if left == right: return left
    # otherwise, we have to scan the whole array to determine which one wins
    leftCount = sum(element == left for element in array)
    rightCount = sum(element == right for element in array)
    if leftCount &gt; len(array) / 2: return left
    if rightCount &gt; len(array) / 2: return right
    # if neither wins, just return None
    return None
</code></pre>

<p>The above algorithm is O(nlogn) time but only O(logn) space.</p>

<p>If you want to find the mode of an array (not just the dominant mode), first compute the histogram. You can do this in O(n) time (visiting each element of the array exactly once) by storing the historgram in a hash table that maps the element value to its frequency.</p>

<p>Once the histogram has been computed, you can iterate over it (visiting each element at most once) to find the highest frequency. Once you find a frequency larger than half the size of the array, you can return immediately and ignore the rest of the histogram. Since the size of the histogram can be no larger than the size of the original array, this step is also O(n) time (and O(n) space).</p>

<p>Since both steps are O(n) time, the resulting algorithmic complexity is O(n) time.</p>
