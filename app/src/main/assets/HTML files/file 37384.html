<p>The problem is that you want to deduce the <code>E</code> in <code>Array&lt;E&gt;::Iterator</code> from <code>x.begin()</code> that is an <code>Array&lt;int&gt;::Iterator</code>. But that is simply not possible.</p>

<p>Your best option is probably to write:</p>

<pre><code>template &lt;typename IT&gt;
T printBegin(IT it){ return (T)*it;}
</code></pre>

<p><s>If, for any reason, you need to use the <code>E</code> type, then it is better to add a nested typedef:</s></p>

<pre><code>class Iterator:public std::iterator&lt;std::output_iterator_tag, T&gt;{
    public:
        typename T array_member_type;
        //...
};
</code></pre>

<p>And then:</p>

<pre><code>template &lt;typename IT&gt;
T printBegin(IT it){
    typedef typename IT::array_member_type E;
    return (T)*it;
}
</code></pre>

<p><strong>Wait!</strong> Your iterator derives from <code>std::iterator</code> so the typedef already exists. No need to redefine:</p>

<pre><code>template &lt;typename IT&gt;
T printBegin(IT it){
    typedef typename IT::value_type E;
    return (T)*it;
}
</code></pre>
