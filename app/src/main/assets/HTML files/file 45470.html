<p>That's pretty much the way to go - you map a known identifier (such as your enum) to a class type, then construct the class. That <em>is</em> the factory design pattern. The simplest factory would just switch over the id and return new:</p>

<pre><code> static BasePacket get(int id)
 {
    switch (id) {
       case 0:
          return new HandshakePacket();
       case 1:
          return new HeartbeatPacket();
    }
 }
</code></pre>

<p>That, of course, requires you to add to the <code>switch</code> statement when a new <code>BasePacket</code> is created. If you don't want to do that, then you can (as in your example) move the mapping somewhere else (possibly loaded at runtime) and dynamically construct the object:</p>

<pre><code>static BasePacket get(int id)
{
    Packets packetId = Packets.values()[id];
    Class packetClass = packetId.getPacketClass();
    object packetInstance = packetClass.newInstance();
    return (BasePacket)packetInstance;
}
</code></pre>

<p>Of course, if any of your <code>Packet</code> subclasses don't have a default constructor, this will fail. Once you get there, you'll probably want a dependency injection container to take care of wiring that up for you.</p>
