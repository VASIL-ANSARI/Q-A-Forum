<p>You need to make the methods in your base class <code>virtual</code>, and your child classes should <code>override</code> them (instead of <code>new</code>).</p>

<pre><code>public class BaseConverter : IValueConverter
{
    public virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        // do nothing in this dummy implementation
        return null;
    }

    public virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        // do nothing in this dummy implementation
        return null;
    }
}

public class CrazyConverter : BaseConverter
{
    public override object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
       return ACrazyConverionOfTheValue(...);
    }
}
</code></pre>

<p><strong>Edit</strong>: You might also want to consider refactoring this to require that <code>Convert</code> be overridden by making the class and <code>Convert</code> abstract, like so:</p>

<pre><code>public abstract class BaseConverter : IValueConverter
{
    public abstract object Convert(object value, Type targetType, object parameter, CultureInfo culture);

    public virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        // do nothing in this dummy implementation
        return null;
    }
}
</code></pre>
