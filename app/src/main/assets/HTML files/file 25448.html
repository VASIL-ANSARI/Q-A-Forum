<p>Those are three different variables. They just happen to have the same name. Changing the value of one will not change the value of another.</p>

<p>A variable has an associated scope within which it is visible. From section <em>6.2.1 Scopes of identifiers</em> of the C99 standard:</p>

<blockquote>
  <p>An identifier can denote an object; a function; a tag or a member of a structure, union, or enumeration; a typedef name; a label name; a macro name; or a macro parameter. <strong>The same identifier can denote different entities at different points in the program.</strong> A member of an enumeration is called an enumeration constant. Macro names and macro parameters are not considered further here, because prior to the semantic phase of program translation any occurrences of macro names in the source file are replaced by the preprocessing token sequences that constitute their macro definitions. </p>
</blockquote>

<p>and:</p>

<blockquote>
  <p><strong>For each different entity that an identifier designates, the identifier is visible (i.e., can be used) only within a region of program text called its scope.</strong> Different entities designated by the same identifier either have different scopes, or are in different name spaces. <strong>There are four kinds of scopes: function, file, block, and function prototype.</strong> (A function prototype is a declaration of a function that declares the types of its parameters.) </p>
</blockquote>

<p>and:</p>

<blockquote>
  <p><strong>Every other identifier has scope determined by the placement of its declaration (in a declarator or type specifier).</strong> If the declarator or type specifier that declares the identifier appears outside of any block or list of parameters, the identifier has file scope, which terminates at the end of the translation unit. If the declarator or type specifier that declares the identifier appears inside a block or within the list of parameter declarations in a function definition, the identifier has block scope, which terminates at the end of the associated block. If the declarator or type specifier that declares the identifier appears within the list of parameter declarations in a function prototype (not part of a function definition), the identifier has function prototype scope, which terminates at the end of the function declarator. If an identifier designates two different entities in the same name space, the scopes might overlap. If so, the scope of one entity (the inner scope) will be a strict subset of the scope of the other entity (the outer scope). Within the inner scope, the identifier designates the entity declared in the inner scope; the entity declared in the outer scope is hidden (and not visible) within the inner scope. </p>
</blockquote>

<p>Each <code>a</code> (the identifier) in the posted code has <em>function</em> scope, and therefore does not interfere with an <code>a</code> declared in another function.</p>

<blockquote>
  <p>the static variable will be initialized automatlly by 0?</p>
</blockquote>

<p>The <code>static</code> specifies the lifetime of <code>a</code>, which is static storage duration. From section <em>6.2.4 Storage durations of objects</em>:</p>

<blockquote>
  <p><strong>An object whose identifier is declared with</strong> external or internal linkage, or with <strong>the storage-class specifier static has static storage duration. For such an object, storage is reserved and its stored value is initialized only once, prior to program startup.</strong> The object exists, has a constant address, and retains its last-stored value throughout the execution of the entire program.23)</p>
</blockquote>

<p>and from section <em>6.7.8 Initialization</em>:</p>

<blockquote>
  <p>If an object that has <strong>static storage duration</strong> is not initialized explicitly, then:</p>
  
  <p>-- if it has pointer type, it is initialized to a null pointer;</p>
  
  <p>-- if it has arithmetic type, it is initialized to (positive or unsigned) zero;</p>
  
  <p>-- if it is an aggregate, every member is initialized (recursively) according to these rules;</p>
  
  <p>-- if it is a union, the first named member is initialized (recursively) according to these rules.</p>
</blockquote>

<p>So <code>a</code> is initialized to <code>0</code>.</p>
