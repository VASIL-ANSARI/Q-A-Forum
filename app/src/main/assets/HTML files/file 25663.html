<p>It does sort of work. For instance if you introduce the following sequence:</p>

<pre><code>3 &lt;enter&gt;
+ &lt;enter&gt;
3 &lt;enter&gt;
d &lt;enter&gt;
3 &lt;enter&gt;
</code></pre>

<p>It produces:</p>

<pre><code>Result: 6
</code></pre>

<p>The reason is cin always expects an enter to finish. There is also an error in the logic and even when you want to stop the execution you have to introduce an extra dummy value. To solve that you must check the operator <em>before</em> asking for the rval.</p>

<p>EDIT:</p>

<p>Probably this would be close to what you want:</p>

<pre><code>#include "iostream"
#include &lt;cstdio&gt;

 using namespace std;

 int main()
 {
     cout &lt;&lt; "Please enter an expression (we can handle ""+"",""-"",""*"",""/    "")" &lt;&lt; endl;
     int lval = 0;
     int rval;
     char op;
     /*int res;*/
     cin &gt;&gt; lval; //read left most number
     if (!cin) printf("No first operand");

     while (cin &gt;&gt; op) //Repeatedly read operand and right value
     {
         if(op != '+' &amp;&amp; op != '-' &amp;&amp; op != '*' &amp;&amp; op != '/')
         {
             cout &lt;&lt; "Result: " &lt;&lt; lval &lt;&lt; endl;
             //keep_window_open();
             getchar();
             return 0;
         }

         cin &gt;&gt; rval;
         if (!cin) printf("No second operand");
         switch(op)
         {
             case '+':
                 lval += rval; //add: lval = lval + rval
                 break;
             case '-':
                 lval -=rval;//subtract: lval = lval - rval
                 break;
             case '*':
                 lval *= rval; //Multiply: lval = lval * rval
                 break;
             case '/':
                 lval /= rval; //Divide: lval = lval / rval
                 break;
         }
     }
     printf("Bad expression");
 }
</code></pre>
