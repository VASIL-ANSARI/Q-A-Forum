<p>Use an AsyncTask for this kind of thing:</p>

<pre><code>public void beginYourTask()
{
    new AsyncTask&lt;Void, Integer, Void&gt;(){

   @Override
   public Void doInBackground(Void...params){
       publishProgress(setRules());
       publishProgress(getLogs());
       publishProgress(getChartView());
       return null;
   } 

     @Override
     public void onProgressUpdate(Integer... progress) {
        progressBar.setProgress(progress[0]);
    }

    @Override
    public void onPostExecute(Void result){
        progressBar.setVisibility(View.GONE);
    }

   }.execute();
}
</code></pre>

<p>That's the idea, there may be typos.</p>

<p>The tutorial from your link hasn't been updated for a while and normally you don't want to use a <code>Thread</code> in this situation because <code>AsyncTask</code> is designed to save you from all the thread problems you would encounter while using <code>Thread</code></p>

<p>Read the <a href="http://developer.android.com/guide/components/processes-and-threads.html" rel="nofollow">documentation</a> on this and you'll know when to use a <code>Thread</code> or an <code>AsyncTask</code></p>
