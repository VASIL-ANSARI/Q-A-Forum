<blockquote>
  <p>It says class C is overriding the DoWork() of B, but the DoWork() method of class B is not made virtual. </p>
</blockquote>

<p>When you override a virtual method, it "stays" virtual unless you explicitly seal it with <code>sealed</code>. (You can <em>only</em> specify the <code>sealed</code> modifier for a method if it's also an override method.)</p>

<blockquote>
  <p>What if B does not provide an implementation of DoWork() then would C be accessing the copy of A's virtual method directly to override it?</p>
</blockquote>

<p>Yes. Or rather, it would invoke A's implementation at execution time. It's not really a "copy".</p>

<blockquote>
  <p>Also, when C inherits from B does it get a separate copy of A's members</p>
</blockquote>

<p>It's not really clear what you mean here. What sort of "copy" are you talking about, and which members? If you mean which <em>fields</em> are in each object, then it's just the union of the fields declared in all the classes up the inheritance chain.</p>

<p>EDIT: In your edited code, you're not overriding anything. You're declaring <em>new</em> methods, which aren't called polymorphically. So if you write:</p>

<pre><code>A a = new C();
a.DoWork();
</code></pre>

<p>that will just print "In Class A" - whereas if <code>B</code> and <code>C</code> <em>overrode</em> the virtual method, it would print "In Class C" and then "In Class B".</p>

<blockquote>
  <p>Also, since C# doesnot provide with the option of multiple inheritance of classes, is there a way to directly use A's implementation of DoWork() from C's class without explicitly creating an object of A and then accessing DoWork() using it?</p>
</blockquote>

<p>Assuming this is in the case where <code>B</code> overrides <code>DoWork</code>, no. That would break encapsulation - it could break the invariants of <code>B</code>, for example.</p>
