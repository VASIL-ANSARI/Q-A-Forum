<p>One workaround for this is for the parent VM to pass itself to the child VM somehow.</p>

<p>Either by setting the <code>Parent</code> property explicitly:</p>

<pre><code>var child = new ChildViewModel
{
    Parent = this
};
</code></pre>

<p>Or, assuming you have some sort of IoC-based abstraction for initialising view model objects, you could have a convention of implementing <code>Configure()</code> methods that return <code>this</code>:</p>

<pre><code>public class ChildViewModel : PropertyChangedBase, IChild
{
    // IChild members...

    public ChildViewModel Configure(IScreen parent)
    {
        Parent = parent;
        return this;
    }
}

public class ParentViewModel : Screen
{
    public ChildViewModel Child { get; set; }

    protected override void OnInitialize()
    {
        Child = _viewModelFactory.Create&lt;ChildViewModel&gt;()
                                 .Configure(this);
    }
}
</code></pre>

<p>It should be possible to customise Caliburm.Micro's view model handling code to set the parent automatically, but I'm not clever enough with it yet to know how to do that, yet. :)</p>
