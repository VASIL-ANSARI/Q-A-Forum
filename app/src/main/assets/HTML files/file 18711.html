<p>Yes and this is the standard behavior. It is written in Â§7.1.6.2[dcl.type.simple]/4, where:</p>

<blockquote>
  <p>The type denoted by <code>decltype(e)</code> is defined as follows:</p>
  
  <ul>
  <li>if <code>e</code> is an <strong>unparenthesized <em>id-expression</em></strong> or an unparenthesized class member access, <code>decltype(e)</code>
  is the type of the entity named by e.</li>
  <li>...</li>
  <li>otherwise, if <code>e</code> is an lvalue, <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code> is the type of <code>e</code>;</li>
  <li>...</li>
  </ul>
</blockquote>

<p>Since <code>c</code> does not have parenthesis and is an <em>id-expression</em> (here, an identifier, see Â§5.1.1[expr.prim.general]/7), <code>decltype(c)</code> will be the type of <code>c</code>, which is <code>int</code>. </p>

<p>Since <code>(c)</code> do have parenthesis and is an lvalue (e.g. <code>(c)=1</code> is a valid expression), <code>decltype((c))</code> will be the lvalue reference type of type of <code>(c)</code>, which is <code>int&amp;</code>.</p>
