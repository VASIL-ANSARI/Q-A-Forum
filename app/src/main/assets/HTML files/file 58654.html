<p>Edited based on comment.</p>

<p>If you have access to xslt 2.0 you can use the following replace function.</p>

<pre><code>&lt;line1&gt;
    &lt;xsl:analyze-string select="."  regex=".{{1,20}}\s" flags="x"&gt;
      &lt;xsl:matching-substring&gt;
         &lt;xsl:value-of select="."/&gt;     
         &lt;br&gt;     
       &lt;/xsl:matching-substring&gt;
       &lt;xsl:non-matching-substring&gt;
       &lt;/xsl:non-matching-substring&gt;
      &lt;/xsl:analyze-string&gt;
    &lt;/line1&gt;
</code></pre>

<p>.{{1,20}}[\s]   Creates capturing groups of 1 to 20 characters in a greedy way (as many as possible) followed by [\s] any kind of whitespace. With the analyze-string function we select any matching substring and add a <code>&lt;br/&gt;</code> after it. </p>

<p>This example results in </p>

<pre><code>&lt;line1&gt;Hello world, XSLT is &lt;br/&gt;Functional &lt;br/&gt;programming? &lt;br/&gt;additional &lt;br/&gt;&lt;/line1&gt;
</code></pre>
