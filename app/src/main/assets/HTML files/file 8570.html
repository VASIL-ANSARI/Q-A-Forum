<p>All 8 primitive wrappers and String are supported @Resource types and are available for lookup or injection via declaring them in the standard ejb-jar.xml file.</p>

<h2>Declaring the name value (and type) pairs</h2>

<p>This is done with the <code>&lt;env-entry&gt;</code> xml element in deployment descriptor.</p>

<p>In EJB 3.0 you have to do this for each bean that wishes to reference the same name/value pairs.  This is because EJB was originally designed different than Servlets and each EJB literally gets its own private JNDI namespace, <code>java:comp/env</code>, whereas all Servlets in the same module share the same <code>java:comp/env</code>.</p>

<pre class="lang-xml prettyprint-override"><code>&lt;ejb-jar&gt;
  &lt;enterprise-beans&gt;
    &lt;session&gt;
      &lt;ejb-name&gt;MySessionBean&lt;/ejb-name&gt;
      &lt;env-entry&gt;
        &lt;env-entry-name&gt;myBoolean&lt;/env-entry-name&gt;
        &lt;env-entry-type&gt;java.lang.Boolean&lt;/env-entry-type&gt;
        &lt;env-entry-value&gt;true&lt;/env-entry-value&gt;
      &lt;/env-entry&gt;
      &lt;env-entry&gt;
        &lt;env-entry-name&gt;myString&lt;/env-entry-name&gt;
        &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;
        &lt;env-entry-value&gt;hello world&lt;/env-entry-value&gt;
      &lt;/env-entry&gt;
      &lt;env-entry&gt;
        &lt;env-entry-name&gt;myDouble&lt;/env-entry-name&gt;
        &lt;env-entry-type&gt;java.lang.Double&lt;/env-entry-type&gt;
        &lt;env-entry-value&gt;1.1&lt;/env-entry-value&gt;
      &lt;/env-entry&gt;
      &lt;env-entry&gt;
        &lt;env-entry-name&gt;myLong&lt;/env-entry-name&gt;
        &lt;env-entry-type&gt;java.lang.Long&lt;/env-entry-type&gt;
        &lt;env-entry-value&gt;12345678&lt;/env-entry-value&gt;
      &lt;/env-entry&gt;
      &lt;env-entry&gt;
        &lt;env-entry-name&gt;myFloat&lt;/env-entry-name&gt;
        &lt;env-entry-type&gt;java.lang.Float&lt;/env-entry-type&gt;
        &lt;env-entry-value&gt;1.3&lt;/env-entry-value&gt;
      &lt;/env-entry&gt;
      &lt;env-entry&gt;
        &lt;env-entry-name&gt;myInteger&lt;/env-entry-name&gt;
        &lt;env-entry-type&gt;java.lang.Integer&lt;/env-entry-type&gt;
        &lt;env-entry-value&gt;1024&lt;/env-entry-value&gt;
      &lt;/env-entry&gt;
      &lt;env-entry&gt;
        &lt;env-entry-name&gt;myShort&lt;/env-entry-name&gt;
        &lt;env-entry-type&gt;java.lang.Short&lt;/env-entry-type&gt;
        &lt;env-entry-value&gt;42&lt;/env-entry-value&gt;
      &lt;/env-entry&gt;
      &lt;env-entry&gt;
        &lt;env-entry-name&gt;myByte&lt;/env-entry-name&gt;
        &lt;env-entry-type&gt;java.lang.Byte&lt;/env-entry-type&gt;
        &lt;env-entry-value&gt;128&lt;/env-entry-value&gt;
      &lt;/env-entry&gt;
      &lt;env-entry&gt;
        &lt;env-entry-name&gt;myCharacter&lt;/env-entry-name&gt;
        &lt;env-entry-type&gt;java.lang.Character&lt;/env-entry-type&gt;
        &lt;env-entry-value&gt;D&lt;/env-entry-value&gt;
      &lt;/env-entry&gt;
    &lt;/session&gt;
  &lt;/enterprise-beans&gt;
&lt;/ejb-jar&gt;
</code></pre>

<p>For readers lucky enough to be using EJB 3.1, you can use global JNDI and declare them in the application.xml and look them up from anywhere via <code>java:app/myString</code>.  A feature most vendors have had for years which is now finally standard as of Java EE 6.  Injection of those entries is also possible via <code>@Resource(lookup="java:app/myString")</code></p>

<p>Also new in Java EE 6 is support for two extra <code>env-entry-type</code> types, java.lang.Class and any enum.  For example:</p>

<pre class="lang-xml prettyprint-override"><code>&lt;env-entry&gt;
  &lt;env-entry-name&gt;myPreferredListImpl&lt;/env-entry-name&gt;
  &lt;env-entry-type&gt;java.lang.Class&lt;/env-entry-type&gt;
  &lt;env-entry-value&gt;java.util.ArrayList&lt;/env-entry-value&gt;
&lt;/env-entry&gt;
&lt;env-entry&gt;
  &lt;env-entry-name&gt;myBillingStragety&lt;/env-entry-name&gt;
  &lt;env-entry-type&gt;java.lang.Class&lt;/env-entry-type&gt;
  &lt;env-entry-value&gt;org.superbiz.BiMonthly&lt;/env-entry-value&gt;
&lt;/env-entry&gt;
&lt;env-entry&gt;
  &lt;env-entry-name&gt;displayElapsedTimeAs&lt;/env-entry-name&gt;
  &lt;env-entry-type&gt;java.util.concurrent.TimeUnit&lt;/env-entry-type&gt;
  &lt;env-entry-value&gt;MINUTES&lt;/env-entry-value&gt;
&lt;/env-entry&gt;
&lt;env-entry&gt;
  &lt;env-entry-name&gt;myFavoriteColor&lt;/env-entry-name&gt;
  &lt;env-entry-type&gt;org.superbiz.ColorEnum&lt;/env-entry-type&gt;
  &lt;env-entry-value&gt;ORANGE&lt;/env-entry-value&gt;
&lt;/env-entry&gt;
</code></pre>

<h2>Referencing them with Injection</h2>

<p>Any of the above can be injected via <code>@Resource</code>.  Just don't forget to fill in the <code>name</code> attribute to match the <code>&lt;env-entry-name&gt;</code></p>

<pre><code>@Stateless
public class MySessionBean implements MySessionLocal {

    @Resource(name="myString")
    private String striing;

    @Resource(name = "myDouble")
    private Double doouble;

    @Resource(name = "myLong")
    private Long loong;

    @Resource(name = "myName")
    private Float flooat;

    @Resource(name = "myInteger")
    private Integer inteeger;

    @Resource(name = "myShort")
    private Short shoort;

    @Resource(name = "myBoolean")
    private Boolean booolean;

    @Resource(name = "myByte")
    private Byte byyte;

    @Resource(name = "myCharacter")
    private Character chaaracter;

}
</code></pre>

<h2>Referencing them with JNDI</h2>

<p>These names can also be standardly looked up via the javax.naming.InitialContext in the EJBs private and portable <code>java:comp/env</code> namespace.</p>

<pre><code>@Stateless
public class MySessionBean implements MySessionLocal {

    @PostConstruct
    private void init() {

        try {
            final InitialContext initialContext = new InitialContext();// must use the no-arg constructor

            final String myString = (String) initialContext.lookup("java:comp/env/myString");
            final Boolean myBoolean = (Boolean) initialContext.lookup("java:comp/env/myBoolean");
            final Double myDouble = (Double) initialContext.lookup("java:comp/env/myDouble");
            final Long myLong = (Long) initialContext.lookup("java:comp/env/myLong");
            final Float myFloat = (Float) initialContext.lookup("java:comp/env/myFloat");
            final Integer myInteger = (Integer) initialContext.lookup("java:comp/env/myInteger");
            final Short myShort = (Short) initialContext.lookup("java:comp/env/myShort");
            final Byte myByte = (Byte) initialContext.lookup("java:comp/env/myByte");
            final Character myCharacter = (Character) initialContext.lookup("java:comp/env/myCharacter");
        } catch (NamingException e) {
            throw new EJBException(e);
        }
    }
}
</code></pre>

<h2>Referencing them with the SessionContext</h2>

<p>In EJB 3.0 as part of the simplification effort we added the ability to use the <code>javax.ejb.SessionContext</code> to do lookups.  It is essentially the same, but has a little bit of sugar on it.</p>

<ul>
<li>the <code>java:comp/env</code> prefix is not required</li>
<li>does not throw a checked exception (will instead throw EJBException for missing names)</li>
</ul>

<p>Service Locator patterns were all the buzz in 2003 so we decided to build a little bit of convenience into the EJB API.</p>

<pre><code>@Stateless
public class MySessionBean implements MySessionLocal {

    @Resource
    private SessionContext sessionContext;

    @PostConstruct
    private void init() {

        final String myString = (String) sessionContext.lookup("myString");
        final Boolean myBoolean = (Boolean) sessionContext.lookup("myBoolean");
        final Double myDouble = (Double) sessionContext.lookup("myDouble");
        final Long myLong = (Long) sessionContext.lookup("myLong");
        final Float myFloat = (Float) sessionContext.lookup("myFloat");
        final Integer myInteger = (Integer) sessionContext.lookup("myInteger");
        final Short myShort = (Short) sessionContext.lookup("myShort");
        final Byte myByte = (Byte) sessionContext.lookup("myByte");
        final Character myCharacter = (Character) sessionContext.lookup("myCharacter");
    }
}
</code></pre>

<h2>Side note on IntialContext evilness</h2>

<p>Also, with my vendor hat on, I can tell you that there's a fair bit of slow plumbing that can be avoided under the hood with the <code>SessionContext</code> lookup.</p>

<p>When you do 'java:' lookups on an <code>InitialContext</code>, the call goes to the VM, through a bunch of hoops to find who can resolve that name, then eventually to the vendor who will have to lookup state from the thread to figure out who asked and what namespace they're supposed to get.  It does this on each and every call no matter what properties you pass into the InitialContext and what context the vendor initialized in its construction.  The 'java:' simply jumps over all that.  It's a rather frustrating part of being a vendor.  It's also why the new <code>javax.ejb.embedded.EJBContainer</code> API does not use <code>InitialContext</code> anywhere at all and just references <code>javax.naming.Context</code> which is an actual interface rather than a concrete "factory" class with intense and obtuse plumbing.</p>

<p>Doing the call on SessionContext should be much faster if the vendor did it right.  In OpenEJB at least, all the above including the ThreadLocal is skipped and the call goes right into that bean's JNDI namespace which is already attached to the <code>SessionContext</code>.</p>

<p>Another way to avoid the <code>InitialContext</code> overhead is to simply lookup <code>java:comp/env</code> once in the @PostConstruct and keep that resulting <code>Context</code> object and only use that.  Then don't prefix lookups with <code>java:comp/env/</code> and just lookup the names directly such as <code>myString</code> and <code>myInteger</code>.  It will be faster, guaranteed.</p>
