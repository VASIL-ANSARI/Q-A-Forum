<p>What does "thread-safe" really mean?</p>

<p>Any programmer, looking at any class, is going to have expectations about how the class will behave.  To me, "thread-safe" means that if you call its methods from multiple threads, you should not have to change your expectations.</p>

<p>Instead of saying, "<code>SynchronizedInteger</code> is <em>thread-safe</em>," I'd rather be explicit about what the guarantees are, and in this case, they're pretty easy to sum up:  It acts like a <code>volatile</code>.</p>

<p>Your "solution #2" and your "solution #3" both preserve that guarantee.  Your solution #1 doesn't.</p>

<hr>

<blockquote>
  <p>Let's assume we have a [shared object].  Any method defined [on] the [shared object] should somehow synchronize access to it's [state] in order to ensure the visibility [...] Do I get it right? </p>
</blockquote>

<p>Yes.  That's a start, but it may not be enough.  If the state is complex (i.e., if it depends on relationships between two or more variables) then it may be the case that some operation that changes the state requires several steps, and it may be the case that when it's half way through the change, the state will be <em>invalid</em>.</p>

<p>In that case you need to use <em>mutual exclusion</em> (e.g., <code>synchronized</code> blocks) to ensure that no other thread except the one that is making the change will ever see the invalid state.  That means you not only need to throw a mutex around every bit of code that could create an invalid state; You must also throw a mutex around every bit of code that must be protected from <em>seeing</em> the invalid state.</p>
