<p>I think you could make your own onTaskDone interface, like this:</p>

<pre><code>public class TaskTest extends AsyncTask&lt;String, Integer, String&gt; {

    interface TaskDoneListener {
        abstract void onTaskDone(String result);
    }

    private TaskDoneListener t;

    public TaskTest(TaskDoneListener t){
        this.t = t;
    }

    @Override
    protected String doInBackground(String... params) {
        // do your stuf
        return "some thing";
    }

    @Override
    protected void onPostExecute(String result) {
        t.onTaskDone(result);
        super.onPostExecute(result);
    }
}
</code></pre>

<p>You could use the notify and wait functions and use the onTaskDone to notify some kind of Thread that is waiting for a result.</p>

<p><strong>EDIT:</strong></p>

<p>execute this code in your onTaskDone method:</p>

<pre><code>countryCode = mydb.getLatestCode();
Log.e("debug", countryCode);
mydb.close();
</code></pre>

<p><strong>EDIT 2:</strong></p>

<p>Activity example code:</p>

<pre><code>public class TestActivity extends Activity implements TaskDoneListener {
    /** Called when the activity is first created. */

    TaskTest task;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        //create your layout and stuff
    }


    @Override
    protected void onStart() {
        super.onStart();

        //Dont start you task in the onCreate this could cause some weird behavior
        //if the onCreate method is not yet done but your task is.
        task = new TaskTest((TaskDoneListener) this, ##country_code?##, ##image?##);
        task.execute();
    }


    public void onTaskDone(String result) {
        //set the results in your created views

    }

}
</code></pre>

<p>Rolf</p>
