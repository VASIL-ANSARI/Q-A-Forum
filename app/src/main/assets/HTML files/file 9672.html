<p>Is the code you listed based off of what's found <a href="http://johan.driessen.se/posts/testing-dataannotation-based-validation-in-asp.net-mvc" rel="nofollow">here</a>?</p>

<p>Personally, I write tests like so on a per annotation basis:</p>

<pre><code>    [Test]
    public void CreateEventViewModel_Description_Property_Contains_StringLength_Attribute()
    {
        // Arrange
        PropertyInfo propertyInfo = typeof(CreateEventViewModel)
                                       .GetProperty("Description");
        // Act
        StringLengthAttribute attribute = propertyInfo
                      .GetCustomAttributes(typeof(StringLengthAttribute), true)
            .Cast&lt;StringLengthAttribute&gt;()
            .FirstOrDefault();

        // Assert
        Assert.NotNull(attribute);
        Assert.AreEqual(255, attribute.MaximumLength);
    }
</code></pre>

<p>I based this off of some information that <a href="http://bradwilson.typepad.com/blog/2009/04/dataannotations-and-aspnet-mvc.html" rel="nofollow">Brad Wilson</a> posted some time back. These tests are stored separate of the controller tests. I'm not sure if there's a more efficient way of doing this today (some folks have created more generic helper methods to do this type of testing; I just prefer having explicit tests for each attribute on my own) but it will verify that your data annotations do exist on your view models as expected.</p>

<p>A combination of this type of test, specifically verifying attributes, along with tests to test model state as listed in your previous question</p>

<pre><code>UsersController.ModelState.AddModelError("username", "Bad username"); 
</code></pre>

<p>is what I typically go with.</p>
