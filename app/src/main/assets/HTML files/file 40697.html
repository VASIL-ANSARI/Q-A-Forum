<p>In my opinion the most Pythonic way would be:</p>

<pre><code>selection = [L for L in lists
             if x1 in L and x2 in L and L.index(x1) &lt; L.index(x2)]
</code></pre>

<p>the defect is that it will search each element twice, first to check the presence (forgetting the index) and second to check the ordering.</p>

<p>An alternative could be</p>

<pre><code>def match(a, b, L):
    try:
        return L.index(a) &lt; L.index(b)
    except ValueError:
        return False

selection = [L for L in lists if match(x1, x2, L)]
</code></pre>

<p>but I find it slightly uglier and I wouldn't use it unless performance is a problem.</p>

<p>If the logic required instead is to accept a list containing <code>[... x2 ... x1 ... x2 ...]</code> then the check is different:</p>

<pre><code>selection = [L for L in lists
             if x1 in L and x2 in L[L.index(x1)+1:]]
</code></pre>

<p>that translated to english as "if x1 is in the list and x2 is the part following first x1" that also works as expected if <code>x1</code> and <code>x2</code> are the same value.</p>
