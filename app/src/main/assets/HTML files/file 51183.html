<h2>Fault -> Error -> Failure</h2>

<p>I'll highlight the definitions from Hanmer, Robert (2013-07-12), <em>Patterns for Fault Tolerant Software</em> (Wiley Software Patterns Series) (pp. 3-4). Wiley. Kindle Edition. </p>

<blockquote>
  <p>The terms <strong>fault</strong>, <strong>error</strong> and <strong>failure</strong> have very specific meanings. </p>
  
  <blockquote>
    <p>A system <strong>failure</strong> occurs when the delivered service no longer complies with the specification, the latter being an agreed description of the systemâs expected function and/ or service. An <strong>error</strong> is that part of the system state that is liable to lead to subsequent failure; an error affecting the service is an indication that a failure occurs or has occurred. The adjudged or hypothesized cause of an error is a <strong>fault</strong>. [Lap91, p. 4]</p>
  </blockquote>
</blockquote>

<p>Your mission, as you've chosen to accept it:</p>

<blockquote>
  <p>The goal is to prevent exceptions. It is not our goal to handle them better once they've occurred.</p>
</blockquote>

<p>So we're talking <em>fault prevention</em> where a <em>fault</em> is the source or cause of the <em>error</em> (which is the exception). </p>

<p>In your example, if I trace back to the <strong>source</strong> of the problem, it's in the <code>someCondition</code> in block 1 that at some point had a false value resulting in the <code>obj</code> not being initialized. There's likely another fault that caused that condition to be wrong. It's like a chain.</p>

<p>If you want to prevent exceptions, then why not fix that source of the faults? Defensive code (also explained in Hanmer's book) is good because stuff happens and it helps to detect faults. But the example you give seems ineffective because you're just avoiding an error (as opposed to removing the fault).</p>

<p>Furthermore, although the block 2 approach will work to prevent an immediate exception, the assumption that you make about code being "non-mandatory" had better be correct. Otherwise, in some other place in the code the work done by that logic block (that you skipped with a goal simply to prevent an exception) could create another <em>fault</em> in the system.  </p>

<blockquote>
  <p>Is it possible to do something other than manually? Are there any tools that can help us find such patterns.</p>
</blockquote>

<p>From this <a href="http://stackoverflow.com/a/5396889/1168342">answer</a>, there's a recommendation for ReSharper (but I've never used it). But some equivalent of <em>lint</em> for ASP.NET is what you can try to find. </p>

<p>I realize your project is in C#, but there's a lot of advice at <a href="https://www.securecoding.cert.org/confluence/display/java/SEI+CERT+Oracle+Coding+Standard+for+Java" rel="nofollow">SEI CERT Oracle Coding Standard for Java</a> that could apply (conceptually). If the application makes use of threading, there are several rules that could be useful in C#.</p>

<p>Stability problems, IMO, can't be "tooled out" so easily. </p>
