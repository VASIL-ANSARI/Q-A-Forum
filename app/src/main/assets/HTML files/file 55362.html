<p>PyNaCl supports multiple types of crypto primitives, but a password hashing scheme is none of them.</p>

<p>Using encryption for password storage is an anti-pattern. Where is the key stored to decrypt the encrypted password? If the key is stored somewhere in code or in some file in the file system, then the whole thing is nothing more than obfuscation.  What if the key is lost? An attacker can directly decrypt the password and log in.<br>
<sup>I'm assuming here that users don't actually type in keys, but rather passwords. If they would type in keys, then those keys could be used directly for PyNaCl encryption.</sup></p>

<p>Instead, passwords should be hashed repeatedly and the hash stored. If a user tries to log in again, the password is hashed again with the same parameters (salt, iteration count, cost factor) and compared to the stored value. This is how it commonly solved in client-server applications, but it is not necessary to store the password hash anywhere, because PyNaCl's symmetric encryption also provides authentication (integrity). It means that you can detect a wrong password by deriving a key from that and attempting to decrypt the container. The password was wrong when PyNaCl produces an error (or the container was tampered with).</p>

<p>There are multiple schemes (PBKDF2, bcrypt, scrypt, Argon2) that can be used for this purpose, but none of them are included in PyNaCl. Although, the underlying libsodium supports two of them.</p>
