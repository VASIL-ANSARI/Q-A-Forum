<p>The biggest burden is the loop, so it is best to be addressed if we want to gain something for optimization.
You have to reverse the problem, instead of looking for numbers indivisible by 2 or 3 or 5, we were looking for numbers divisible by 2 or 3 or 5. The resulting number of such numbers subtract all the numbers will give us the number of indivisible numbers by 2 or 3 or 5. In this way, we obtain an algorithm with a constant execution time. Execution time does not depend on the input.</p>

<pre><code>public static long indivisbleBy_2or3or5(long t) {
    long x, y, z;

    //amount of numbers divisible by 2, and several for 3 and 5. 
    x = t / 2;

    //amount of numbers divisible by 3 - numbers divisible by 3 and 2 = amount of numbers divisible by 3, and several for 5.
    y = t / 3;
    y = y - y / 2;

    //amount of numbers divisible by 5 - numbers divisible by 5 and 2 - (numbers divisible by 5 and 3 - numbers divisible by 5 and 3 and 2)  = number only divisible by 5  
    z = t / 5;
    z = z - z / 2 - (z / 3 - z / (2 * 3) );

    //All numbers - (The amount of numbers divisible by 2, and several for 3 and 5 
    //+ The amount of numbers divisible by 3 and several for 5 + number only divisible by 5)
    //= indivisible by 2 or 3 or 5
    return t - (x + y + z);
}
</code></pre>

<p>I do not know whether the "pow" there is some optimization, but it is generally better to perform an action (2 ^ 15) ^ 2 which gives 15 operations than 2 ^ 30, which gives 29 operations. According to the principle of "divide et impera". :)</p>
