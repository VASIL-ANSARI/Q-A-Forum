<p>One approach would be to add the count as a parameter to the function</p>

<p><code>public static int move(int number, char start, char help, char end, int count)</code></p>

<p>the initial call would be something like</p>

<pre><code>int count == Math.pow(2,n) - 1
move(n,'A','B','C',count);
</code></pre>

<p>and then inside the function</p>

<pre><code>public static int move(int number, char start, char help, char end,int count){
    if(number == 1){
        print("Move the top disk from " + start + " to " + end);
        assert count == 1; 
        return 1;
    }else{
        int subCount1 = move(number-1,start,end,help, (count-1)/2);
        print("Move the top disk from " + start + " to " + end);
        int subCount2 = move(number-1,help,start,end, (count-1)/2);
        assert count == (subCount1 + subCount2 + 1);
        return count; // it's the same as returning 2*f(n-1)+1;
    }
}
</code></pre>

<p>The count parameter serves as an expected assertion value.
This is pure intuition and it may require some fine changes. I'm not 100% on the <code>(count-1)/2</code> part.</p>

<p><strong>EDIT</strong> 
If you do not want to alter the method signature try something like this: </p>

<pre><code>public static void move(int number, char start, char help, char end) {
    if (number == 1) {
        print("Move the top disk from " + start + " to " + end);
        count++;
    } else {
        int stepsBeforeMove1 = count;
        move(number - 1, start, end, help);
        int stepsAfterMove1 = count;
        print("Move the top disk from " + start + " to " + end);
        count++;
        int stepsBeforeMove2 = count; //this is just for the sake of clarity
        move(number - 1, help, start, end);
        int stepsAfterMove2 = count;
        assert ((stepsAfterMove1-stepsBeforeMove1) + (stepsAfterMove2-stepsBeforeMove1) + 1) == Math.pow(2,number) - 1;
    }
}
</code></pre>
