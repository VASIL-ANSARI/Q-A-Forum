<p>If you have a <code>my_function(utility::MyTool&lt;...&gt;)</code>, then I would say that <code>my_function</code> belongs to the interface of the class template <code>utility::MyTool&lt;...&gt;</code>. In other words, <code>my_function</code> itself belongs to the <code>namespace utility</code>.</p>

<p>This means that you can write code in the desired shorthand form:</p>

<pre><code>namespace utility {   
    typedef MyTool&lt;AFirstPolicy, ASecondPolicy&gt; SomeTool;
    my_function(SomeTool);    
}
</code></pre>

<p>You can read more about interfaces and namespaces in this old column <a href="http://www.gotw.ca/publications/mill02.htm" rel="nofollow">"What's In a Class"</a> by Herb Sutter.</p>

<p>Note that even if you want to use functions in other namespaces with classes from <code>namespace utility</code>, you can still reopen that namespace and define the policy class right there and do something like</p>

<pre><code>// SomeHeader.hpp
namespace bla {
   // your classes and functions
}

// reopen namespace utility
namespace utility {   
    typedef MyTool&lt;AFirstPolicy, ASecondPolicy&gt; SomeTool;
}

namespace bla {
    typedef utility::SomeTool BlaTool; // or using-declaration
    my_function(BlaTool);
}
</code></pre>

<p>This is of course more verbose than defining <code>my_function</code> inside the utility namespace, but at least you can assemble all the various policies without too much typing. </p>
