<p>When you do an animation, its effects are temporary, and by default they don't actually mutate  your layers/views. Typically, you would explicitly write the "end" values into the layers/views in the completion block. You will need to do this for each animation in your "chain" of animations. With your code, I suspect you'd get the desired outcome if you did this:</p>

<pre><code>- (IBAction)testDrive:(id)sender {
      CGPoint center = CGPointMake(_car.center.x, self.view.bounds.origin.y + _car.bounds.size.height/2 +100);
      [UIView animateWithDuration:3
        animations:^ { _car.center = center;}
        completion:^(BOOL finished){ _car.center = center; [self rotate];}]; 
}

- (void) rotate{
      CGAffineTransform transform = CGAffineTransformMakeRotation(M_PI);

      void (^animation)() = ^() { _car.transform = transform;
      };

      void (^completion)(BOOL) = ^(BOOL finished){
        _car.transform = transform;
        [self returnCar];
      };
     [UIView animateWithDuration:3 animations:animation completion:completion];
}
</code></pre>

<p>You'll also want to make a corresponding change in <code>-returnCar</code>.</p>

<p>The idea here is that the animation effects only the "presentation layer" but not the "model layer." If you want the model layer to reflect the "after" state of the animation, you need to explicitly do that.</p>
