<p>Considering that at each recursion you are testing the next column. you already have some kind of stack in your board, col being your stack pointer.</p>

<p>considering you have only one queen by col you can even reduce the size of the required head space.</p>

<pre><code>const int size=5; // your board size
int isSafe(const int pos[size],const int col,const int row) {
    for(int i=0;i&lt;col;i++) { //check up to the stack pointer ( anything beyond is garbage )
        if(pos[i]==row){ //check on same row
            return 0;
        }
        //check diagonals
        int delta=col-i;
        if(pos[i]==(row+delta)) { 
            return 0;
        }
        if(pos[i]==(row-delta)) {
            return 0;
        }
    }
    return 1;
}

int solveNQ() {
    int pos[size];
    int col=0;
    int row=0;
    while(col&lt;size) {
        if(isSafe(pos,col,row)) {
            pos[col]=row;
            col++;
            row=0;
        }else{
            row++;
            while(row==size) { // rollback to previous while end of col
                if(col==0) { 
                    // we seem to have found no reasonable solution
                    // as we rolled back further
                    return 0;
                }
                col--; 
                row=pos[col]+1; // pop previous position and try the next one
            }
        }
    }
    return 1;
}
int main() {
    solveNQ();
    return 0;
}
</code></pre>

<p>this is solving your problem in an pseudo recursive way</p>
