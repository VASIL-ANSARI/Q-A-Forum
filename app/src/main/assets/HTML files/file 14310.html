<p>Actually pthread library itself provides an API to <a href="http://linux.die.net/man/3/pthread_attr_setguardsize" rel="nofollow">set the guard size</a></p>

<pre><code>int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);
</code></pre>

<p>But note that if you are setting the stack location or size, either using functions like  <a href="http://linux.die.net/man/3/pthread_attr_setstack" rel="nofollow"><code>pthread_attr_setstack(3)</code></a> or <a href="http://linux.die.net/man/3/pthread_attr_setstackaddr" rel="nofollow"><code>pthread_attr_setstackaddr(3)</code></a>, which you are, then the guard size attribute is ignored (i.e., no guard area is created by the system): it is the your responsibility to handle stack overflow (perhaps by using <a href="http://linux.die.net/man/2/mprotect" rel="nofollow"><code>mprotect(2)</code></a> to manually define a guard area at the end of the stack that you have allocated.</p>

<p>So, coming to your specific question, yes, you need to malloc <code>A+B</code> bytes to include the guard area yourself if you wish to use <code>pthread_attr_setstack</code>. Else, if you are OK with the default stack size, then you use the <code>pthread_attr_setstack</code> function.</p>

<p>Read about <a href="http://www.cognitus.net/html/howto/pthreadSemiFAQ_5.html" rel="nofollow"><code>pthreads</code></a> here. Also read specifically about thread stack management <a href="https://computing.llnl.gov/tutorials/pthreads/" rel="nofollow">here</a> under the section <code>Stack Management</code></p>
