<p>The win32 api is sometimes a pain to use, but you could allways use the raw bytes in a <code>std::vector&lt;char&gt;</code> as a <code>SYSTEM_LOGICAL_PROCESSOR_INFORMATION</code>:</p>

<pre><code>std::vector&lt;char&gt; buffer(sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION));
size_t buffersize = buffer.size();

SYSTEM_LOGICAL_PROCESSOR_INFORMATION *ptr 
   = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION *)&amp;(buffer[0]);

BOOL bResult = GetLogicalProcessorInformation(ptr, &amp;buffersize);
if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
  {
    buffer.resize(buffersize);
    ptr = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION *)&amp;(buffer[0]);
    bResult = GetLogicalProcessorInformation(ptr, &amp;buffersize);
  }
</code></pre>

<p>Just be avare that the value of <code>&amp;(buffer[0])</code> may change after <code>buffer.resize(...);</code>
Other than that, I normally don't use the win32 api, so any bugs concerning how to call win32, you have to fix yourself</p>
