<p>The system call which gives you memory is <code>brk</code>. The usual <code>malloc</code> and <code>calloc</code>, <code>realloc</code> functions simply use the space given by <code>brk</code>. When that space is not enough, another <code>brk</code> is made to create new space. Usually, the space is increased in sizes of a virtual memory page.</p>

<p>Thus, if you really want to have a premade pool of objects, then make sure to allocate memory in multiples of pagesize. For example, you can create one pool of <code>4KB</code>. <code>8KB</code>, ... space.</p>

<p>Next idea, look at your objects. Some of them have one size, some have other size. It will be a big pain to handle allocations for all of them from the same pool. Create pools for objects of various sizes (powers of 2 is best) and allocate from them. For example, if you'll have an object of size <code>34B</code> you'd allocate space for it from the <code>64B</code> pool.</p>

<p>Lastly, the remaining space can be either left unused or it can be moved down to the other pools. In the above example, you have <code>30B</code> left. You'd split it in <code>16B</code>, <code>8B</code>, <code>4B</code> and <code>2B</code> chunks and add each chunk to their respective pool.</p>

<p>Thus, you'd use linked lists to manage the preallocated space. Which means that your application will use more memory than it actually needs but if this really helps you, why not?</p>

<p>Basically, what I've described is a mix between <a href="http://en.wikipedia.org/wiki/Buddy_memory_allocation" rel="nofollow">buddy allocator</a> and <a href="http://en.wikipedia.org/wiki/Slab_allocation" rel="nofollow">slab allocator</a> from the Linux kernel.</p>

<p><strong>Edit</strong>: After reading your comments, it will be pretty easy to allocate a big area with <code>malloc(BIG_SPACE)</code> and use this as a pool for your memory.</p>
