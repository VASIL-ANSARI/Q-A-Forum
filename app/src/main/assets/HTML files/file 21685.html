<p>The fact that <code>IViewA</code> derives from <code>IView</code> does not automatically mean that <code>IPresenter&lt;IViewA&gt;</code> derives from <code>IPresenter&lt;IView&gt;</code>. In fact <code>IPresenter&lt;IViewA&gt;</code> and <code>IPresenter&lt;IView&gt;</code> are two distinct types that do not have an inheritance relation between them. Their only common ancestor is <code>object</code>.</p>

<p>Let's look at an example. Assume that we have a class <code>Animal</code>, a class <code>Cat</code> deriving from <code>Animal</code> and a class <code>Dog</code> deriving from <code>Animal</code>. Now let's declare two lists</p>

<pre><code>List&lt;Animal&gt; animals;
List&lt;Cat&gt; cats = new List&lt;Cat&gt;();
</code></pre>

<p>And let's also assume that the following assignment was possible:</p>

<pre><code>animals = cats;
animals.Add(new Cat()); // OK
animals.Add(new Dog()); // Ooops!
</code></pre>

<p>The list is in reality a cats list and we are trying to add a dog! Therefore the two types <code>List&lt;Animal&gt;</code> and <code>List&lt;Cat&gt;</code> are not allowed to be assignment compatible.</p>
