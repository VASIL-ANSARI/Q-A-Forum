<p>That depends on the nature of the communication.</p>

<ul>
<li>Is it duplex (ie A talks to B and B talks to A)?</li>
<li>Is it communication of data or communication of <em>completion</em>?</li>
<li>and so on.</li>
</ul>

<p>The simplest and most advisable form of inter-thread communication is simply to wait for the completion of other threads. That's most easily done by using <code>Future</code>:</p>

<pre><code>ExecutorService exec = Executors.newFixedThreadPool(50);
final Future f = exec.submit(task1);
exec.submit(new Runnable() {
    @Override
    public void run() {
        f.get();
        // do stuff
    }
});
</code></pre>

<p>The second task won't execute until the first completes.</p>

<p>Java 5+ has <em>many</em> concurrent utilities for dealing with this kind of thing. This could mean using <a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/LinkedBlockingQueue.html"><code>LinkedBlockingQueue</code></a>s, <a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/CountDownLatch.html"><code>CountDownLatch</code></a> or many, many others.</p>

<p>For an in-depth examination of concurrency <a href="http://rads.stackoverflow.com/amzn/click/0321349601">Java Concurrency in Practice</a> is a must-read.</p>
