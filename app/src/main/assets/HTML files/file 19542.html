<pre><code>char *p = "Something";//I cant change the data
char q[] = "Wierd"; // I can change to what q points to
</code></pre>

<p><code>p</code> is a <code>char*</code> pointing to the first element of an array of ten <code>char</code>s (don't forget the 0-terminator) that you are not allowed to modify (attempting to modify a string literal is undefined behaviour; most implementations store string literals in read-only memory, then such an attempt would cause a segfault, but it's possible that an attempt to modify a string literal would modify the array and not crash). You can change <code>p</code> freely, and when it is changed to point to a modifiable object, you can modify that object through <code>*p</code>.</p>

<p><code>q</code> is an array of six <code>char</code>s (again, 0-terminator). You can't assign any value to <code>q</code>, but you can modify the contents of the array.</p>

<pre><code>p = q;
</code></pre>

<p>You let <code>p</code> point to the first element of the array <code>q</code>. In that context, <code>q</code> is implicitly converted to a pointer to its first element, <code>&amp;q[0]</code>, so <code>p = &amp;q[0];</code> is what actually happens. Now <code>p</code> points to a modifiable object, thus</p>

<pre><code>*p  = 'x';
</code></pre>

<p>is allowed and changes the first <code>char</code> in <code>q</code>.</p>

<pre><code>p = "Something";
q[0] = 'W';
</code></pre>

<p>You let <code>p</code> again point to the first element of a <code>char</code> array that you are not allowed to modify, and change the first element of <code>q</code> back to what it was before it was modified through <code>p</code>, this time using <code>q</code>.</p>

<pre><code>//q = p;// This is not possible because for q I cant change Point.
// This is the error comes
//error: incompatible types when assigning to type âchar[6]â from type âchar *â
</code></pre>

<p>The error message is slightly misleading, <em>you can't assign arrays</em>. Even with <code>char hello[] = "Hello"; char world[] = "World";</code>, although both arrays have the same type, you can't assign, <code>hello = world; produces the same error (since in that context,</code>world` is converted to a pointer to its first element, the error message is not wrong, though).</p>

<pre><code>*q = 'x';//This works fine as this is possible to change Value for q
</code></pre>

<p>Right, <code>*q</code> is the same as <code>q[0]</code>, so you can use arrays like pointers (and vice versa) in many situations. But not in all, arrays and pointers are different types of things.</p>

<pre><code>const char * r = "What";//I cant change the data to what a points to (basic def and const act on same)
char const * s = "Point";//I cant change the data to what a points to (basic def and const act on same)
</code></pre>

<p><code>const char *</code> and <code>char const *</code> mean exactly the same, a pointer to an unmodifiable <code>char</code> (which often is the first of an array of such).</p>

<pre><code>char * const t = "Pointers";//I cant change the data to what a points to because of basic def and const make c a const that now c can only point to single entity.
</code></pre>

<p><code>t</code> is a constant pointer, you can't change <em>where</em> it points to, but per the type, you can modify the object it points to. In this case, however, <code>t</code> points to the first <code>char</code> of a string literal, so you are not allowed to change the object <code>t</code> points to (but that's not a consequence of <code>t</code>'s type).</p>

<pre><code>const char u[] = "Are";//I cant change the data to what a points to because of const and I can't change to what d points because of basic def of [].
char const v[] = "Trying";//I cant change the data to what a points to because of const and I can't change to what d points because of basic def of [].
</code></pre>

<p>Again, both mean the same, <code>u</code> and <code>v</code> are arrays of <code>const char</code>, you are not allowed to change the contents of these arrays because of their types.</p>

<pre><code>//char w const [] = "To make";//This is not possible
</code></pre>

<p>Right, that is invalid syntax, you can't have a type qualifier between the array name and the brackets.</p>

<pre><code>//*r = 'x'; // This is not possible
//Error comes is:
//error: assignment of read-only location â*râ
</code></pre>

<p>The type of <code>r</code> forbids changing the pointed-to object through <code>r</code> (it can be legitimate to change it through other pointers, though).</p>

<pre><code>//now the behaviour of r is same as p but instead of getting segmentation fault I got an error at compile time.
//Also the restriction const put here is same as of restriction present with p except(error checking).
//Conclusion : This means writing const here makes no difference in terms of Value and Point. What it was before is the same now.
</code></pre>

<p>The conclusion is wrong, if you change <code>r</code> to point to a modifiable object, <code>q</code> for example, you can still not change that through <code>r</code>, the type forbids it. But you could modify it through <code>p</code>. For pointers to string literals, usually the difference is that <code>*r = 'x';</code> is a compilation failure and <code>*p = 'x';</code> a segmentation fault, but for the general case, modifying through <code>p</code> is valid (and usually even "works" if <code>p</code> points to an element of a <code>const char arr[10]</code>, but that is again undefined behaviour, it just doesn't normally lead to a crash, in contrats to string literals).</p>

<pre><code>r = s;
</code></pre>

<p>Okay, no problem. You change which object <code>r</code> points to, i.e. you change <code>r</code>, but you don't change the object <code>r</code> pointed to.</p>

<pre><code>r = t;
</code></pre>

<p>Also no problem. If <code>t</code> pointed to a modifiable object, you could then modify the object through <code>t</code> but not through <code>r</code>. But as <code>t</code> points to a string literal, you mustn't modify the object <code>t</code> points to through either, but again, one would be a compilation error, the other probably a segfault.</p>

<pre><code>//Everything Works for Point assignment - This means everything works for the 
//rules of the type of varible on the left side for Pointer assignment. (Even for r=u,r=v, r=q).
//(2) WHY this is happening.(Actualy answer related to WHY(1))
</code></pre>

<p>Read <code>const</code> as "read-only". Having a <code>const char *r;</code> means you have a pointer to <code>char</code> that the compiler will not allow you to use to modify the pointed-to object, you can use it only to read the object. Whether the object it points to was declared as <code>const</code> doesn't matter, the <code>const</code> in <code>r</code>'s declaration only limits what <code>r</code> can be used for, not what can be done with the pointed-to object through other pointers.</p>

<pre><code>//Nothing Works for Value change
//Now this is absurd. On the first look it seems that as the things happen at the time of p=q, here
//for r=u, r=v, r=q same things should had happened. But on the closer inspection you can get that u,v 
//have restrictions on Value change because of const.
//But (3)Why no Value change is happening for r=q ? 
// (4) Why fot r=p, r=q getting error due to const. not due to segmentation fault.
</code></pre>

<p>I'm not sure I understand your "Why(3)", but if I understand correctly, you expected <code>*r = 'x';</code> to work after <code>r = q;</code>, since then <code>r</code> points to a modifiable object. Then the answer is what I wrote above, the <code>const</code> qualifier in <code>r</code>'s declaration restricts what you can do through <code>r</code>, it is independent of the <code>const</code> status of the pointed-to object. That also answers (4), the type of <code>r</code> forbids an assignment <code>*r = whatever;</code>.</p>

<pre><code>//Conclusion: Writing const after or before char makes no difference.
</code></pre>

<p>Right, it makes a difference whether the <code>const</code> appears before or after the <code>*</code>, though. <code>const char *r;</code> declares a pointer you cannot use to modify the pointee, and <code>char * const x = q;</code> declares a pointer that always points to the same location; you can use it to modify the pointed-to object (if that allows it). And <code>const char * const y = q;</code> declares a read-only pointer that you cannot change.</p>

<pre><code>//*t = 'x';//This is not possible
//Error is
//Segmentation-fault
//This means that on Value change the error comes not due to const. It comes for the same reason of p.
</code></pre>

<p>You can't do <code>*t = 'x';</code> because <code>t</code> happens to point to a string literal. Had you initialised <code>t</code> to point to <code>q</code>, that would have been allowed.</p>

<pre><code>//t = r;
</code></pre>

<p>That's disallowed because you declared <code>t</code> to be unmodifiable, you cannot change where it points to.</p>

<p>// (5) Why this is happening. Why left hand side is always given precedence. Why this isn't happening p=q, 
    //because for value change t=q and p=q are exctly same both pn left side and right side of the assignment.</p>

<p>I'm not sure what the question is. You declared <code>t</code> to be <code>const</code>, that means you can't assign to <code>t</code>. It would be the same for <code>const int i = 100;</code>, you would not be allowed to write <code>i = 120;</code> in your programme.</p>

<pre><code>//*u = 'x';//This is not possible
//Error Comes is
//error: assignment of read-only location â*(const char *)&amp;uâ
//This error comes because of const.
//Conclusion: [] gives the Point restriction and const gives the Value Restriction
</code></pre>

<p>Right.</p>

<pre><code>//For above four cases

//Point Assignment
//Warning for p=r, p=s is
//warning: assignment discards âconstâ qualifier from pointer target type [enabled by default]
//Conclusion:Kind of understandable.
</code></pre>

<p>Not only "kind of". You are assigning a <code>const char*</code> to a <code>char*</code>. The object that is pointed to may be unmodifiable, but trying to modify it through the <code>char *p</code> is formally valid, and if the pointed-to object is modifiable, using <code>p</code> to modify it is even legitimate. But if the pointed-to object is not modifiable, a string literal or declared with a <code>const</code> qualifier, trying to modify it through <code>p</code> is undefined behaviour. So discarding the <code>const</code> qualifier is a dangerous thing to do, and the compiler warns about it. It may, however be perfectly legitimate, so it's only a warning, not an error. You can tell the compiler that you know what you're doing (whether you do or not) by using an explicit cast.</p>

<pre><code>// NO Warning for p=t 
//For left side type I can do Point assignment and for Right Side I can,t do.
// Left side rules are given precedence. (9)Why? (If already not solved in above answers)
</code></pre>

<p>You're assigning a <code>char * const</code> to a <code>char*</code>, there's nothing lost here. Assigning the value of <code>t</code> doesn't change it, and the <code>const</code> after the <code>*</code> only says that you cannot change the address that <code>t</code> points to.</p>

<pre><code>//Warning for p=u, p=v is
//warning: assignment discards âconstâ qualifier from pointer target type [enabled by default]
//For left side type I can do Point assignment and for Right Side I can,t do.
// Left side rules are given precedence. (10)Why? (If already not solved in above answers)
</code></pre>

<p>Same as for <code>p = r;</code>.</p>

<pre><code>//Value Change
//Segmentation fault for everything .
//Conclusion: Understndable if assume left hand side are given precedence except for p = q (showed in I.)
</code></pre>

<p>The segmentation fault is only because you're letting the pointers point to string literals. If you let them point to <code>char[]</code>, the assignments <code>*ptr = 'x';</code> will either work or not compile, depending on whether the pointer was declared to point to <code>const char</code> or only to <code>char</code>. If you throw in a few arrays of <code>const char</code>, the assignment will of course also not compile for <code>const char*</code>, but it will compile for <code>char*</code> (with the warning about discarding the <code>const</code> qualifier), and running the programme invokes undefined behaviour (it will probably not crash and modify the array contents, but anything could happen).</p>

<hr>

<p>Regarding the additional questions:</p>

<blockquote>
  <p>1) For p case object is a string literal (which one can't modifiable) i.e. it is the property of right hand side object , while for q on RHS I have the same thing but now it is behaving differently. Why such an inconsistent design.</p>
</blockquote>

<p>I'm not sure what you think is different. In both, <code>char *p = "Something";</code> and <code>char *p = q;</code>, the properties of the pointed-to object determine what uses of <code>p</code> are valid. Neither of the two is unmodifiable by its type (both are <code>char[N]</code> for some <code>N</code>), but the string literal is unmodifiable as a special case defined by the standard.</p>

<p>The declaration <code>char *p;</code> (without initialisation here, but the presence or absence of one doesn't matter for that) declares <code>p</code> as a pointer you may use to modify what it points to. But whether such an attempt to modify the pointed-to object is valid, is determined by properties of the pointed-to object.</p>

<pre><code>char q[] = "Wierd";
</code></pre>

<p>copies the contents of the string literal to the array <code>q</code> (including the 0-terminator), so <code>q</code> is initialised with a <em>modifiable copy</em> of the string literal. Letting <code>p</code> point to some <code>char</code> in the array <code>q</code> makes <code>p</code> point to a modifiable object, and such a modification is valid.</p>

<p>Letting <code>p</code> point to a <code>const</code> qualified object, <code>const char c = 'C'; p = &amp;c;</code>, say, is dangerous, since the type of <code>p</code> doesn't prevent <code>*p = 'x';</code> from compiling - after all, the compiler doesn't know in general whether at that point <code>p</code> points to a <code>const</code> qualified object, or a modifiable object (the assignment may come from a <code>const char*</code> that was made to point at a modifiable object), or to no valid location at all.</p>

<p>Therefore the assignment <code>p = &amp;c;</code> causes the compiler to emit a warning (at least with the warning level of the compiler sufficiently high, but in gcc and clang for example, it is enabled by default), or even abort the compilation with an error (gcc and clang do that if you pass the <code>-pedantic-errors</code> flag). The language standard forbids that assignment without explicitly casting the <code>const char *</code> that <code>&amp;c</code> is to a <code>char*</code>, but requires only a diagnostic, so the compiler is free to make it a warning or an error.</p>

<p>If you only use the pointer to read from the pointed-to object while it points to an unmodifiable object, that is a legitimate use, so the assignment isn't flat-out unconditionally forbidden (with the cast, it's allowed by the standard and doesn't even cause a warning, since the cast tells the compiler "I know what I'm doing").</p>

<p>So whether <code>*p = 'x';</code> is valid, can only be determined by the properties of the pointed-to object. If the pointed-to object is unmodifiable (or if <code>p</code> doesn't point to a valid object at all), the behaviour is undefined. How undefined behaviour manifests itself is, well, undefined, but in this case, usually either a segmentation fault (if the object resides in a write-protected memory region) or the pointed-to object will be modified as if it were allowed (if only the type makes the object unmodifiable and the implementation doesn't take extra measures to identify such invalid writes). In the case of string literals, which have - for historical reasons - type <code>char[N]</code>, most often they are stored in the <code>.rodata</code> (read-only data) section of the programme, and an attempt to write to that is detected by the operating system and results in a segfault.</p>

<blockquote>
  <p>2) For p if I modify the string literal, the behavior is undefined i.e. Sometimes it is modified and sometimes not. Again why such design. Actually for out of bound array access this is understandable as you access memory that you haven't allocated before, and sometimes you don't have permission to access that piece of memory so, segmentation fault. But why sometimes I can modify string literal. Why so. What is the reason behind this.</p>
</blockquote>

<p>Pragmaticism.</p>

<p>The committee defining the language doesn't like to tie the implementors' hands. It's the programmer's obligation to avoid undefined behaviour, and if (s)he doesn't, whatever happens happens.</p>

<p>Historically, as far as I know, there were implementations that stored string literals in read-only memory and ones that didn't. When the language was standardised (almost twenty years after its creation, so there was a lot of diversity in behaviours), it was mostly a write-up of existing common practices. Where behaviour widely differed, due to differences in compilers, libraries or hardware, it was left undefined or implementation-defined, to allow conforming implementations on as many platforms as possible. So some implementations allowed the modification of string literals, others didn't, and the committee decided to place the burden on the programmer by making the behaviour undefined.</p>
