<p>These aren't functions, these are classes (structs, actually, but doesn't matter). When you define your own binary functions to use with STL algorithms, you derive them from these classes in order to automatically get all the typedefs.</p>

<p>E.g.</p>

<pre><code>struct SomeFancyUnaryFunction: public std::unary_function&lt;Arg_t, Result_t&gt;
{
   Result_t operator ()(Arg_t const &amp;)
   {
      ...
   }
};
</code></pre>

<p>now you don't need to manually provide the typedefs for <code>argument_type</code>, <code>result_type</code> etc. These structs, just like the <code>iterator</code> struct are there just for our convenience, in order to reuse the typedefs needed for algorithms</p>
