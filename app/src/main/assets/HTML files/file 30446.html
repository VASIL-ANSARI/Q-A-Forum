<p>The <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Proxy.html#getProxyClass%28java.lang.ClassLoader,%20java.lang.Class...%29" rel="nofollow"><code>Proxy#getProxyClass(ClassLoader, Class)</code></a> method is declared as </p>

<pre><code>public static Class&lt;?&gt; getProxyClass(ClassLoader loader,
                                     Class&lt;?&gt;... interfaces)
</code></pre>

<p>Its return type is therefore <code>Class&lt;?&gt;</code>. The normal syntax would be</p>

<pre><code>Class proxyClass&lt;?&gt; = Proxy.getProxyClass(getClass().getClassLoader(), Transportable.class, Order.class);
</code></pre>

<p>Technically you could do (with a warning)</p>

<pre><code>public &lt;T extends Order &amp; Transportable&gt; void doSomething() {
    Class&lt;T&gt; proxyClass = (Class&lt;T&gt;) Proxy.getProxyClass(Driver.class.getClassLoader(),
            Transportable.class, Order.class);
}
</code></pre>

<p>but that gains you nothing as you will pretty much never need to use that <code>T</code> variable. The <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html" rel="nofollow"><code>Class</code></a> class provides very little methods that makes use of it, namely <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#getConstructor%28java.lang.Class...%29" rel="nofollow"><code>getConstructor(Class...)</code></a> and <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#newInstance%28%29" rel="nofollow"><code>newInstance()</code></a>. But again, the whole point of reflection is that you only know the class types at run time, not at compile time where generics are useful.</p>
