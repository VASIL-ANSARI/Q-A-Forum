<p>Exactly how much memory it takes is engine-dependent, but it has to store the closure as well as the getter methods, which do get copied for every new instance created. It also slows down execution since the method needs to run each time you want to access the variable, and it makes the code less readable (you need to call <code>.a()</code> instead of just <code>.a</code> when you want do use it).</p>

<p>I wouldn't use this because nothing prevents someone from replacing the values by doing this:</p>

<pre><code>obj = createObject('original', 'values');
obj.a(); // returns 'original'

obj.a = function() {Â return 'modified'; };
obj.a(); // returns 'modified'
</code></pre>

<p>By the way, putting argument names in parenthesis is the same as declaring variables inside the function's body. In other words, you don't need to have paramA and paramB in your code. This works out just fine:</p>

<pre><code>function createObject (a, b) {
    return {
        a: function () { return a; },
        b: function () { return b; }
    }
}
</code></pre>

<p>There's no perfect way to protect variables in JS without causing horrible overhead, so your best bet is just to put an underscore prefix or suffix the private properties with an underscore, just like in python. I prefer using a prefix so private variables won't show up in auto-completion when someone uses a library I made. Then you can actually code the getter in the prototype, so there's only one copy of the method:</p>

<pre><code>function Foo(a, b) {
    this._a = a;
    this._b = b;
}

Foo.prototype.getA = function() {Â return _a; };
Foo.prototype.getB = function() {Â return _b; };
</code></pre>

<p>This doesn't make <code>_a</code> or <code>_b</code> private at all, but it does tell anyone using your code that they shouldn't be accessing them. If they're too dumb not the break everything, it's not your problem anymore.</p>
