<p>Q1: There is a performance difference because your swapping code creates a lot of <code>String</code> objects that get operated on, while the other routine works directly with  a char array and requires no additional object creation. Let's examine your line of code:</p>

<p><code>s=s.substring(0, i)+right+s.substring(i+1, s.length()-(i+1))+left+s.substring(s.length()-i, s.length());</code></p>

<p>It does this kind of work:</p>

<p><code>s = [new String 1] + char + [new String 2] + char + [new String 3]</code></p>

<p>That's 4 new <code>String</code> objects (the three shown, plus the one resulting from the addition of <code>String</code> objects. Also, each of the 3 new strings shown has a call to substring which takes time to process. In addition you do all of this work in a for-loop so it gets repeated for each character!</p>

<p>String manipulation is convenient but expensive.  Array manipulation is direct, requires no additional object or blocks of memory, so is much faster.</p>

<p>Q2: Surrogates are a special case of unicode character created to handle longer unicode characters. See <a href="http://www.ibm.com/developerworks/library/j-unicode/" rel="nofollow">this article</a> for more details. The order of the hi/low parts of the surrogate are important so it would be wrong for the swap code to reverse those two characters, so if they are found, their order is put back the way it should be.</p>
