<p>You can't cause code to wait (e.g. pause execution of the current thread of execution) until some future event occurs.  Javascript simply does not support that or work that way.  It does not have a way to block the current thread of execution other than a couple modal functions like <code>alert()</code>.</p>

<p>What you can do is use callbacks to notify some calling code of a future event.  But, the calling code will register its callback and be returned to immediately and continue executing so the calling code has to be written to handle the callback implementation.</p>

<p>If you're trying to do all the work inside your library, then it should not be that tough.  When the caller creates a new modal, you just have to check for a pre-existing modal dialog.  If one is not up you proceed as normal.  If one is up, then you register a callback notification with the previous one, store the contents of the constructor, but don't actually create the new modal dialog.  Then, when your callback gets called to indicate the previous modal dialog has completed, you finish putting up the new modal.</p>

<p>If these modal dialogs are all of your own creation, then you need to implement completion notification on them so that when they are closed, they can notify any listeners that they're done now.  If they use an animation to close and you want to wait for the close notification until the animation is complete, then you can implement that also.  If you're using CSS3 animations, then as you appear to already know, you can use the transtionEnd event to know when an animation is done or if you know the timing of the animation and you don't need to be ms precise, you can also just use a <code>setTimeout()</code> to know approx when the animation is complete.</p>
