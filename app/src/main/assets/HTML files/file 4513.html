<p>You need an abstract class that implements the upgrade process described here. Then you extend this abstract class for each of your tables. In your abstract class you must store you tables in a way(list, hardcoded) so when the onUpgrade fires you iterate over the table items and for each table item you do the described steps. They will be self upgraded, keeping all their existing details. Please note that the onUpgrade event fires only once per database, that's why you need to iterate over all your tables to do the upgrade of all of them. You maintain only 1 version number over all the database.</p>

<ul>
<li>beginTransaction</li>
<li>run a table creation with <code>if not exists</code> (we are doing an upgrade, so the table might not exists yet, it will fail alter and drop)</li>
<li>put in a list the existing columns <code>List&lt;String&gt; columns = DBUtils.GetColumns(db, TableName);</code></li>
<li>backup table (<code>ALTER table " + TableName + " RENAME TO 'temp_"                    + TableName</code>)</li>
<li>create new table (the newest table creation schema)</li>
<li>get the intersection with the new columns, this time columns taken from the upgraded table (<code>columns.retainAll(DBUtils.GetColumns(db, TableName));</code>)</li>
<li>restore data (<code>String cols = StringUtils.join(columns, ",");
            db.execSQL(String.format(
                    "INSERT INTO %s (%s) SELECT %s from temp_%s",
                    TableName, cols, cols, TableName));
</code>)</li>
<li>remove backup table (<code>DROP table 'temp_" + TableName</code>)</li>
<li>setTransactionSuccessful</li>
</ul>

<p><em>(This doesn't handle table downgrade, if you rename a column, you don't get the existing data transfered as the column names do not match).</em></p>

<p>.</p>

<pre><code>public static List&lt;String&gt; GetColumns(SQLiteDatabase db, String tableName) {
    List&lt;String&gt; ar = null;
    Cursor c = null;
    try {
        c = db.rawQuery("select * from " + tableName + " limit 1", null);
        if (c != null) {
            ar = new ArrayList&lt;String&gt;(Arrays.asList(c.getColumnNames()));
        }
    } catch (Exception e) {
        Log.v(tableName, e.getMessage(), e);
        e.printStackTrace();
    } finally {
        if (c != null)
            c.close();
    }
    return ar;
}

public static String join(List&lt;String&gt; list, String delim) {
    StringBuilder buf = new StringBuilder();
    int num = list.size();
    for (int i = 0; i &lt; num; i++) {
        if (i != 0)
            buf.append(delim);
        buf.append((String) list.get(i));
    }
    return buf.toString();
}
</code></pre>
