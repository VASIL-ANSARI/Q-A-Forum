<p>(a follow up on my comment after your edit) I would suggest to have a different queue per thread. This is actually a very well know pattern called <a href="http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html" rel="nofollow">publish-subscribe</a>.</p>

<p>Taken from the link above:</p>

<blockquote>
  <p>A Publish-Subscribe Channel works like this: It has one input channel
  that splits into multiple output channels, one for each subscriber.
  When an event is published into the channel, the Publish-Subscribe
  Channel delivers a copy of the message to each of the output channels.
  Each output channel has only one subscriber, which is only allowed to
  consume a message once. In this way, each subscriber only gets the
  message once and consumed copies disappear from their channels.</p>
</blockquote>

<p>The main difference between a <code>ConcurrentLinkedQueue</code> and a <code>BlockingQueue</code> is that you can add a limit on how many elements are on the <code>BlockingQueue</code>. This is good in the case that the producer reading from the network generates data faster than the consumers can process. If you use an unbounded queue and this goes for a while you'll end up with an <code>OutOfMemoryError</code>. </p>
