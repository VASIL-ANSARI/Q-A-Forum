<p>I would do something like the following:</p>

<ul>
<li>First, I would make the <code>Deck</code> class implement <code>Iterator&lt;Card&gt;</code>. </li>
<li>Second, I would make the <code>Deck</code> class immutable after the first call to <code>shuffle</code> or <code>take</code>. ie. don't allow the addition of cards.</li>
</ul>

<p>Then I would do something like this...</p>

<pre><code> static List&lt;List&lt;Card&gt;&gt; previousDecks = new ArrayList&lt;&gt;();
 static List&lt;Card&gt; inputList = createListOfCards();

 static{
      privousDecks.add(inputList);
 }

 @Test
 public void testShuffle(){
    Deck deck = new Deck(inputList);
    deck.shuffle();

    List&lt;Card&gt; shuffled = new ArrayList&lt;&gt;();
    Iterators.addAll(shuffled, deck);

    assertThat(shuffled, 
       IsIterableContainingInAnyOrder.containsInAnyOrder(inputList));

    for (List&lt;Card&gt; previouslySeen : previousDecks){
        assertThat(shuffled,
            CoreMatchers.not(
            IsIterableContainingInOrder.contains(previouslySeen )));
    }
    previousDecks.add(shuffled);
 }
</code></pre>

<p>I would then find a way of running <code>testShuffle</code> multiple times to ensure that the shuffle does not produce the same result each time. This can be done multiple ways. <a href="http://stackoverflow.com/questions/1492856/easy-way-of-running-the-same-junit-test-over-and-over">Here</a> is an example.</p>

<p>As an FYI, I am using Hamcrest and Guava here.</p>

<p><a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Iterators.html" rel="nofollow">Iterators</a></p>

<p><a href="http://hamcrest.org/JavaHamcrest/javadoc/1.3/" rel="nofollow">Hamcrest</a></p>
