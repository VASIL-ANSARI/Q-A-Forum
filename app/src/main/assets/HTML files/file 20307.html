<p>Well, there <em>is</em> no switch/case statement in Python.</p>

<p>For a small <code>list</code>, you want to use <code>if</code>/<code>elif</code>:</p>

<pre><code>def do_stuff(x, *args):
    if x == 'ADD':
        return do_add(*args)
    elif x == 'SUB':
        return do_sub(*args)
    # â¦
    else:
        raise RuntimeError('Never heard of {}'.format(x))
</code></pre>

<p>For a larger <code>list</code>, you want to make sure each case is a function (I already assumed that above, but if you had code like <code>return args[0] + args[1]</code>, you'd have to change that into a <code>do_add</code> function), and create a <code>dict</code> mapping names to functions:</p>

<pre><code>func_map = {'ADD': do_add, 'SUB': do_sub, â¦ }

def do_stuff(x, *args):
    try:
        return func_map[x](*args)
    except KeyError:
        raise RuntimeError('Never heard of {}'.format(x))
</code></pre>

<p>This works because in Python, functions are normal objects that you can pass around like any other objects. So, you can store them in a <code>dict</code>, retrieve them from the <code>dict</code>, and still call them.</p>

<p>By the way, this is all explained in <a href="http://docs.python.org/2/faq/design.html#why-isn-t-there-a-switch-or-case-statement-in-python" rel="nofollow">the FAQ</a>, along with a bit of extra fanciness.</p>

<p>If you have some default function you'd like to call instead of raising an error, it's obvious how to do that with the <code>if</code>/<code>elif</code>/<code>else</code> chain, but how do you do it with the <code>dict</code> map? You <em>could</em> do it by putting the default function into the <code>except</code> block, but there's an easier way: just use the <a href="http://docs.python.org/2/library/stdtypes.html#dict.get" rel="nofollow"><code>dict.get</code></a> method:</p>

<pre><code>def do_stuff(x, *args):
    return func_map.get(x, do_default)(*args)
</code></pre>
