<p>The key is that if you do things properly, the GameManager class will not <strong>directly</strong> have all the responsibilities you have mentioned. Instead, it will delegate these responsibilities into other classes, that will be passed to it by using some form of dependency injection. So you can say that the GameManager class has a single responsibility: to coordinate the work of the other classes; and has one single reason to change: to accommodate a change in the game logic that requires a new class to participate or to change the order of the interaction between classes.</p>

<p>A very simple example (sorry, C# syntax, but you get the idea):</p>

<pre><code>public class GameManager
{
    //constructor - note that the parameter types are interfaces, not classes
    public GameManager(
        IPlayerManager playerManager,
        ITurnManager turnManager)
    {
        this.playerManager = playerManager;
        this.turnManager = turnManager;
    }

    public void DoNextTurn()
    {
        var nextPlayer = playerManager.GetNextPlayer();
        turnManager.ProcessTurn(nextPlayer);
        //etc...
    }
}
</code></pre>
