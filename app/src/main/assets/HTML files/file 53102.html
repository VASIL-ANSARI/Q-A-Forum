<p>I'd use a <code>Map&lt;String, List&lt;String&gt;</code> (or better a Google Guava <code>Multimap&lt;String, String&gt;</code>) and then apply your logic:</p>

<ul>
<li>make a lower case version of your word</li>
<li>sort the characters for the lower case version to for a key</li>
<li>use that key to put the word into the map</li>
</ul>

<p>When the user provides input you repeat steps 1 and 2 but use <code>get(key)</code> in step 3 and voilÃ  you have your list of anagrams.</p>

<p>Example:</p>

<p>Word = Anna -> key = aann</p>

<p>User input = nana -> key = aann </p>

<p>Then you do <code>dictionary.get("aann")</code> and should get the list containing the element "Anna".</p>

<p><em>Edit</em>: Issues with your code</p>

<ul>
<li>You don't show the declaration of <code>singleAddress</code> and <code>numbers</code> but I assume it's a <code>Set&lt;String&gt;</code> and a <code>Map&lt;String, Integer&gt;</code>.</li>
<li>In <code>numbers</code> the key is the word and the value is the hash. You'd have to iterate over all entries in that map then in order to retrieve all with the same hash. Better swap it around.</li>
<li>The hash function <em>might</em> result in collisions, i.e. the same hash value for non-anagrams (as an example take "ac" and "ba", the hash for "ac" would be <code>2 * 64 + 66 = 194</code> and for "ba" it would be <code>2 * 65 + 64 = 194</code>). That's why hash sets and maps in Java always use Â´hashCode()<code>_and_</code>equals()<code>.</code>hashCode()<code>is used to get the bucket which is a list in the map while</code>equals()` is then used to check whether the keys are actually the same.</li>
</ul>
