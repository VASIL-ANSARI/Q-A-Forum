<p>You can cast without ambiguity:</p>

<pre><code>function(static_cast&lt;std::auto_ptr&lt;Base&gt; &gt;(derivedPtr));
</code></pre>

<p>Be aware that for this to work, <code>Base</code> must have a virtual destructor. Otherwise the code has undefined behavior.</p>

<p>The reason for the ambiguity is as Arne says in his answer -- it's not obvious to the caller whether <code>function</code> takes a value or a reference, and therefore it's not obvious to the caller whether their <code>auto_ptr</code> will be released or not by making the call, and if it is released whether it's converted to a type that can correctly <code>delete</code> the pointer. The ambiguous conversion AFAIK is there to stop you writing such difficult code. By casting, you make it explicit in the calling code that <code>derivedPtr</code> is released.</p>
