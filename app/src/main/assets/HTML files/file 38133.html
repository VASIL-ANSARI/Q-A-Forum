<p><strong>Handle The Property Changed Event</strong></p>

<p>The PropertyChanged event is simply an event so there is nothing stopping you from listening to that event from another view model if that is what you need.</p>

<pre><code>this.loginViewModel.PropertyChanged += this.OnLoginPropertyChanged;
</code></pre>

<p>The event handler method would look something like this...</p>

<pre><code>private void OnLoginPropertyChanged(object sender, PropertyChangedEventArgs e)
{
    if (e.PropertyName == "TextboxDescription") {
        // Do something.
    }
}
</code></pre>

<p><strong>Raise StatusChanged Events:</strong></p>

<p>To be honest if I was implementing this myself I would simply be firing events from the LoginViewModel when the status changed and then handling those events instead, seems like a cleaner solution to this.</p>

<pre><code>this.loginViewModel.StatusChanged += this.OnLoginStatusChanged;

private void OnLoginStatusChanged(object sender, LoginStatusChangedEventArgs e)
{
    // Do something.
    switch (e.StatusType)
    {
        ...
    }
}
</code></pre>

<p>I would have custom event args like so...</p>

<pre><code>public class LoginStatusChangedEventArgs : EventArgs
{
     public AvailabilityStatusType StatusType { get; set; }
}
</code></pre>

<p>Just fire this event when the status changes and listeners can handle that.</p>

<p><strong>Event Aggregator:</strong></p>

<p>You could also use the event aggregator however unless you have lots of disconnected classes that need to listen to this I would probably feel it was overkill.</p>

<pre><code>this.eventAggregator.Publish(new LoginStatusChangedMessage(AvailabilityStatusType.Disconnected));
</code></pre>
