<p>The appearance of the <code>UIAlertView</code> should prevent further user interaction. You're saying, though, that there is a very short window ("a few milliseconds" is a <em>tiny</em> delay as far as the user perceives it) in which the user could touch up on some other button, and cause weird behavior. Ok, without testing, I'll just take that as true. </p>

<p>One rather brute-force way to do this would be to set <code>exclusiveTouch</code> to <code>YES</code> on the button in question. See the <a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/multitouch_background/multitouch_background.html#//apple_ref/doc/uid/TP40009541-CH5-SW15" rel="nofollow">Event Handling Guide</a> for a full explanation. Basically, when a view whose <code>exclusiveTouch</code> property is <code>YES</code> is tracking a touch, no other views may track touches. Similarly, such a view may not begin tracking touches unless no other views are tracking touches.</p>

<p>A sidenote: I think you're using <code>dispatch_after</code> to get a block onto the main queue. Typically you'd just use <code>dispatch_async</code> if your intention is to put something on the main queue for immediate execution.</p>

<p><strong>EDIT:</strong> When this question was asked, it did not specify the use of <code>UIBarButtonItem</code>. This answer will only work with <code>UIView</code> or a descendant thereof. </p>
