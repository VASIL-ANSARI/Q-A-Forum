<p>You set up your ViewController to conform to the ASIHTTPRequestDelegate protocol:</p>

<pre><code>@interface MyViewController : UIViewController &lt;ASIHTTPRequestDelegate&gt;
</code></pre>

<p>Then, you implement the </p>

<pre><code>-(void) requestFinished(ASIHTTPRequest *)request;
</code></pre>

<p>method in your ViewController's implementation. Now when the request is finished the requestFinished: method in your ViewController will be called. If you need to pass information along with the request and have it be available in the requestFinished: method, you can set the ASIHTTPRequest's userInfo property to whatever you like, and it will be available in the request parameter in  requestFinished:</p>

<p><strong>Response to comment:</strong><br>
If you are willing to block your thread until the response is received, you can use the startSynchronous method (code from the ASI site <a href="http://allseeing-i.com/ASIHTTPRequest/How-to-use" rel="nofollow">http://allseeing-i.com/ASIHTTPRequest/How-to-use</a>):</p>

<pre><code>[request startSynchronous];
NSError *error = [request error];
if (!error) {
  NSString *response = [request responseString];
}
</code></pre>

<p>This way your submitUserCredentials method would sit and wait while the server responds, but it would return the server response to that method. If blocking your UI while waiting a response won't work for you (and it probably won't) you can spin up a new thread to run your submitUserCredentials method and then call startSynchronous from there:</p>

<pre><code>[NSThread detachNewThreadSelector:@selector(submitUserCredentials:)
        toTarget:self withObject: credentials];
</code></pre>
