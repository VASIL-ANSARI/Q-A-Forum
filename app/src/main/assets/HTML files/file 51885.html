<p>No, not directly. The default parameter is substituted by the compiler at the call site without any further information.</p>

<p>However, there is a simple solution to achieve what you want to do: Use overloading instead of default parameters.</p>

<pre><code>namespace detail
{
  void
  do_something_impl(const std::vector&lt;foo&gt;&amp; foos)
  {
    // Do things that always need to be doneâ¦
  }
}

void
do_something()
{
  // Do things specific to the no-argument caseâ¦
  detail::do_something_impl({});
}

void
do_something(const std::vector&lt;foo&gt;&amp; foos)
{
  // Do things specific to the one-argument caseâ¦
  detail::do_something_impl(foos);
}
</code></pre>

<p>If your logic requires you to branch more often â not just at the beginning or the end of the function â you could pass an additional boolean parameter to <code>detail::do_something_impl</code> that encodes which overload it was called from.</p>

<p>In general, I recommend to use defaulted parameters sparingly and prefer function overloading as it gives you better control and often also better (less surprising) interfaces.</p>
