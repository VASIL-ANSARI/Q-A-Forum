<p>This algorithm should be fast and provide near-uniform hashing:</p>

<pre><code>size_t s = 0x3a7eb429; // Just some random seed value
for (int i = 0; i != 8; ++i)
{
    for (int j = 0; j != 8; ++j)
    {
        s = (s &gt;&gt; 1) | (s &lt;&lt; (sizeof(size_t) * 8 - 1));
        s ^= k.a[i][j] * 0xee6b2807;
    }
}
s *= 0xee6b2807;
s ^= s &gt;&gt; 16;
</code></pre>

<p>After that, if you want to make the hashing even stronger, hash s another time using for example <a href="http://code.google.com/p/smhasher/wiki/MurmurHash3" rel="nofollow">MurmurHash3</a>.</p>
