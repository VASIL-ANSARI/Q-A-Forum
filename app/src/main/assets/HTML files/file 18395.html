<p>my solution would be:</p>

<pre><code>#define malloc(size) mymalloc(size, __FILE__, __FUNCTION__, __LINE__)
... (realloc, calloc, free)

void *mymalloc(size_t size, char *file, char *function, int line)
{
  void *data = malloc(size);
  addList(data, size, file, function, line);
  return data;
}

void myfree(void *data)
{
  removeList(data);
  free(data);
}

void debugalloc()
{
  printList();
}
</code></pre>

<p>the removeList() would search for "data" in the global list and remove it, or gives a warning. with "debugalloc();" you should print the whole list (and normally it should be empty, or well filled with what you expect it to have).</p>

<p><strong>Another option</strong>:
your memory management gets fragmented, ... (upps, Alexey Frunze wrote that just a second ago in the comments section.)</p>

<p><strong>EDITH</strong>: XML</p>

<p>I made a comment about DOM and SAX, and I have the feeling just to expand this comment:</p>

<pre><code>&lt;head&gt;&lt;data&gt;...&lt;/data&gt;&lt;data&gt;...&lt;/data&gt;......&lt;data&gt;...&lt;/data&gt;&lt;/head&gt;
</code></pre>

<p>is an excellent candidate for SAX. In DOM, the whole XML will be read and converted into memory, which can lead very quickly to fragmented memory, if &lt; data > itself is structured with different sized values. it may happen, that your operating system's memory modell will work against mallocing small amounts of memory.</p>

<p>With SAX, you only load portions of data into memory and get rid of it as soon as it is consumed. But your implementation must change from traversing the Document into a kind of State Machine with feeding (&lt; data >) and consuming/processing (&lt; / data >).</p>
