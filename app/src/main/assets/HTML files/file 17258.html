<p><code>UNION</code> removes duplicate rows that appear in both subqueries, and therefore must create a temporary table for the result.</p>

<p>If you can guarantee that the subqueries are distinct, or if you don't care about those duplicates, use <code>UNION ALL</code> instead.</p>

<p>(In your case, the sorting by the non-indexed value <code>int3</code> requires a temporary table anyway.)</p>

<hr>

<p>To optimize the subqueries, run them with <a href="http://www.sqlite.org/lang_explain.html" rel="nofollow"><code>EXPLAIN QUERY PLAN</code></a> to check whether they use indexes.</p>

<p>You can use <code>LIKE</code> if you ensure that your indexes are declared correctly; see <a href="http://www.sqlite.org/optoverview.html#like_opt" rel="nofollow"><code>LIKE</code> optimization</a>.</p>

<p>See <a href="http://www.sqlite.org/queryplanner.html" rel="nofollow">Query Planning</a> for an explanation of how to construct indexes. Your two indexes seem to be optimal.</p>
