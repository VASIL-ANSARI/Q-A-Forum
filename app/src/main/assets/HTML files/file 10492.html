<p><a href="http://www.comeaucomputing.com/tryitout/" rel="nofollow">Comeau</a> thinks that your code is incorrect, so I think that the constructor-interpretation shadowing the type-interpretation is what the standard mandates<sup>1</sup>.</p>

<p>Still, your code happily compiles if you clear up the ambiguity and tell the compiler that you're trying to access the <code>derived</code> member of the base class:</p>

<pre><code>struct base
{
  struct derived {};
};

struct derived : base {};

int main()
{
  typedef derived::base::derived type;
  return 0;
}
</code></pre>

<p>By the way, the fact that the constructor-interpretation prevails kinda makes sense: you have a well-known way to tell the compiler that you want to refer to stuff of the base class (via the scope resolution operator), but you wouldn't have a syntax to do the reverse (forcing the compiler to understand that you're referring to the constructor). So the "constructor-by-default" behavior seems quite sensible.</p>

<hr />

<ol>
<li>I may look it up later, but I don't guarantee that I actually will, this kind of pesky name issues are always a mess to look up.</li>
</ol>
