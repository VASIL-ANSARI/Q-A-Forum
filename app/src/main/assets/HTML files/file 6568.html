<p>There are several options. Here are four that come to mind, each with their own pros and cons:</p>

<ol>
<li><p>Discriminate by signature:</p>

<pre><code>- (void)myFunctionWithA:(AObject *)obj;
- (void)myFunctionWithB:(BObject *)obj;
</code></pre></li>
<li><p>Declare a parameter of type <code>NSObject *</code> (or <code>id</code>, as suggested in the comments) and query the type inside the function.</p></li>
<li>As above, but constrain it by declaring a common base class <code>BaseObject *</code>, from which <code>AObject</code> and <code>BObject</code> inherit.</li>
<li><p>Combine the base class with a trampoline technique:</p>

<pre><code>- (void)myFunction:(BaseObject *)base {
    [base myTrampoline:self];
}
</code></pre>

<p><code>BaseObject</code> declares the abstract method <code>myTrampoline:</code>, which <code>AObject</code> and <code>BObject</code> implement.</p></li>
</ol>

<p>Without knowing more about your problem, it's impossible to say which is best.</p>
