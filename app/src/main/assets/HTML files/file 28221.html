<p>Whenever a <code>TypeInitializationException</code> is thrown, check all initialization logic of the type you are referring to for the first time in the statement where the exception is thrown - in your case: <code>Logger</code>.</p>

<p>Initialization logic includes: the type's static constructor (which - if I didn't miss it - you do <strong>not</strong> have for <code>Logger</code>) and field initialization.</p>

<p>Field initialization is pretty much "uncritical" in <code>Logger</code> except for the following lines:</p>

<pre><code>private static string s_bstCommonAppData = Path.Combine(s_commonAppData, "XXXX");
private static string s_bstUserDataDir = Path.Combine(s_bstCommonAppData, "UserData");
private static string s_commonAppData = Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData);
</code></pre>

<p><code>s_commonAppData</code> is <code>null</code> at the point where <code>Path.Combine(s_commonAppData, "XXXX");</code> is called. As far as I'm concerned, these initializations happen in the <strong>exact</strong> order you wrote them - so put <code>s_commonAppData</code> up by at least two lines ;)</p>
