<p>Instead of using <code>security.code</code> as the model path use <code>code</code>. Use the class <code>RTSecurityModel</code> in the value section of the bindings tab instead of the AppDelegate.</p>

<p><a href="http://www.midwinter-dg.com/resources.html" rel="nofollow">Here</a> is a demo project. </p>

<p>Do <strong>not</strong> bind the <code>Text Field Cell</code>, use the <code>Text Field</code>.</p>

<p>You can check if a value is null if you fill the <code>Null Placeholder</code> with text, will it show that text instead? Then in time of binding the value it null.</p>

<p>To see your <code>RTSecurityModel</code> in the Interface Builder you must let it know your class, it won't look for it.</p>

<p>Add an Object and then set the custom class of it to <code>RTSecurityModel</code>.
Then you can choose this object and set the referencing outlet to the property in the App Delegate.
Assignment will now be directly reflected in the label.</p>

<p><img src="http://i.stack.imgur.com/0hLI1.jpg" alt="enter image description here"></p>

<hr>

<p>I can think of two ways to solve this programmatically without Interface Builder:</p>

<ol>
<li><p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html" rel="nofollow">Key Value Coding</a></p>

<pre><code>// add an observer for the value on the object that has the method below implemented
[self addObserver: self forKeyPath: @"security.code" options: NSKeyValueObservingOptionNew context: NULL];

// method will be called when the observer has 'seen' a value change
-(void) observeValueForKeyPath: (NSString *)keyPath ofObject: (id) object                  change: (NSDictionary *) change context: (void *) context {
    label.text = ...
}
</code></pre></li>
<li><p>Use a custom setter for <code>code</code> (<code>@synthesize</code> will still create the getter for you)</p>

<pre><code>- (void)setCode:(NSString *)aString {
    label.text = aString;
}
</code></pre></li>
</ol>
