<p>Defining <code>Default</code> in mapping does not change .Net defaults.</p>

<p>When you instantiate your <code>Location</code> class, I guess your <code>Type</code> property is not initialized (no initialization value or constructor not setting it) and thus has its default .Net value for a string: <code>null</code>.</p>

<p>NHibernate will not replace that <code>null</code> by the <code>Default</code> you have declared. How could it guess it was not willingly set to null?</p>

<p>You should initialize your class properties with their default values in your class definition.</p>

<p>A sort of workaround could be used nonetheless. For <code>string</code> properties and other nullable properties, you may use the <code>dynamic-insert</code> option on your class, since it causes NHibernate to not send to DB the properties which are null. </p>

<p><a href="http://nhibernate.info/doc/nhibernate-reference/mapping.html#mapping-declaration-class" rel="nofollow">See the doc:</a></p>

<blockquote>
  <p>(8)   dynamic-insert (optional, defaults to false): Specifies that
  INSERT SQL should be generated at runtime and contain only the columns
  whose values are not null.</p>
</blockquote>

<p>Of course, it cannot work with properties having a non-nullable type.</p>

<p>So, what is the officially supported purposes of defining defaults in mapping? I only know one: enabling DB schema generation from mappings to generate default constraints for columns.</p>

<p>We may consider the <code>dynamic-insert</code> option should take those defaults into account. But if that were the case (and maybe it is, NHibernate doc is sometimes lagging behind implemented functionalities), that would cause my suggested 'workaround' to fail, since the behavior of dynamic-insert should be then to <em>contain only the columns whose values are equals to their declared default in mappings, or null if they do not have a declared default</em>.</p>
