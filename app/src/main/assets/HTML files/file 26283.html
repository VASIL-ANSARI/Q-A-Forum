<p>PHP does not support multiple inheritance which is what I think you are trying to approximate here. It does however support (as of 5.4) <a href="http://php.net/manual/en/language.oop5.traits.php" rel="nofollow">traits</a>, which in many cases can provide you with comparable functionality. </p>

<pre><code>trait ParentTrait {
   public function someUsefulMethod(){/*...*/};
   public function someOtherUsefulMethod(){/*...*/};
}

abstract class ClientParent(){}

class ClientChild1 extends ClientParent {
      use ParentTrait;
}

$clientChild1 = new ClientChild1();
$clientChild1-&gt;someUsefulMethod();
</code></pre>

<p>Another option would be to use composition instead, possibly for your problem employing the Strategy pattern would work. </p>

<pre><code>class SuperWidget extends Widget{
    private $dataStrategy;

    public function __construct(DataStrategy $strategy){
         $this-&gt;dataStrategy = $strategy;
    }

    // do this if you need to expose the functionality. 
    public function getData(){
        return $this-&gt;dataStrategy-&gt;getData();
    }

    // or if you are just using it in your class
    public function renderWidget($option){
        $data = $this-&gt;dataStrategy-&gt;getData($option);
        // use the data to render the widget;
        return $renderedWidget;
    }
}

$dataStrategy = JsonDataStrategy("http://data.source.url/jsonService.php");
$widget = new SuperWidget($dataStrategy);
</code></pre>
