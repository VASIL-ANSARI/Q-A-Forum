<p>Shelakel's comment on the question half answered the question for me.</p>

<p>I changed the "DisplayTemplates/PaymentItem" to be just "PaymentItem" and it begun calling the correct template.  However, it did raise another issue, where it was complaining that it was trying to pass an IList into the individual object.</p>

<p>This is how the PaymentItems looks on the main model:</p>

<pre><code>private IList&lt;PaymentItemViewModel&gt; paymentItems = new List&lt;PaymentItemViewModel&gt;();

public IEnumerable&lt;PaymentItemViewModel&gt; PaymentItems
{
    get { return paymentItems; }
    set { paymentItems = value.ToList(); }
}
</code></pre>

<p>To resolve the issue I had to make the model on the display template an IList and put a foreach inside it.  Kinda pointless really as I thought one of the main reasons of templates is that you don't need to loop through collections on the views!</p>

<p>Anyway, I believe the IList issue stems from the fact the initial collection starts life as an IList, but I have got it working now so I guess the question is answered.</p>

<p>Changing the paymentItems declaration from <code>IList&lt;PaymentItemViewModel</code> to <code>IEnumerable&lt;PaymentItemViewModel&gt;</code> doesn't change anything.</p>
