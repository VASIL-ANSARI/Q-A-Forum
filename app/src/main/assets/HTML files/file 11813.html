<p>Since the depth of your data is arbitrary, it is easier to resort to recursion to flatten it. This function creates a flat dictionary, with the  path to each data item composed as the key, in order to avoid collisions. </p>

<p>You can retrieve its contents later with <code>for key in sorted(dic_.keys())</code>, for example.</p>

<p>I didn't test it, since you did not provide a "valid" snippet of your data.</p>

<pre><code>def flatten(structure, key="", path="", flattened=None):
    if flattened is None:
        flattened = {}
    if type(structure) not in(dict, list):
        flattened[((path + "_") if path else "") + key] = structure
    elif isinstance(structure, list):
        for i, item in enumerate(structure):
            flatten(item, "%d" % i, path + "_" + key, flattened)
    else:
        for new_key, value in structure.items():
            flatten(value, new_key, path + "_" + key, flattened)
    return flattened
</code></pre>
