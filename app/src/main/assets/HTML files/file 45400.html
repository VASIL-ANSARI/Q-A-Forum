<p>It turns out that my test didn't work rather the were run stand alone or part of a suite, I had a separate issue with using the wrong annotations for @BeforeTest which masked the defect when running the whole suite.</p>

<p>The fix was pretty simple.  I added the SpringApplicationConfiguration annotation above my test:</p>

<pre><code>@SpringApplicationConfiguration(classes =
    {
        MockController.class,
        SpringApplicationContext.class
   }
public class MyTest extends AstractTestNGSpringContextTests
</code></pre>

<p>There are two parts to this.  The @SpringApplicationCOnfiguration loads only those values I listed.  I could have pointed to configuration classes, but that would ultimately load most of the beans in my enviroment which is overkill for a unit test.  So I load the two @component objects needed in my ApplicationContext for my unit test to work only.</p>

<p>I also had to extend AbstractTestNGSpringContextTests because It's the only way to get spring to play nice with the TestNG kit were using for our tests.  If others are using junit tests instead of TestNG don't extend the AbstracTestNGSpringContextTests, instead I believe your want to add the annotation:</p>

<pre><code>@RunWith(SpringJUnit4ClassRunner.class)
</code></pre>

<p>Though I haven't used it since I'm not using junit.</p>

<p>Hopefully this answer saves others who are trying to figure out how to load only a few classes instead of the entire enviroment (most examples I found want you to load configuration files that will load every bean, which is slow and honestly undesirable in a unit test).</p>

<p>Arguably I should still have mocked out the SpringApplicationContext entirely, I'm lazy and sloppy :)</p>
