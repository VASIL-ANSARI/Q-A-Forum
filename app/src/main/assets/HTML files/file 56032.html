<p>I think you'll have to make a trade-off: Either you accept some anti-pattern or you open up you <code>Building</code> "interface" to act as an Adapter:</p>

<pre><code>class Building implements Factory{

    // the other building stuff

    @Override
    public void printFactoryOutput(){ /* NO OP */ }
}
</code></pre>

<p>Then you can call <code>printFactoryOutput</code> on all <code>Building</code>s having no effect up to this point.</p>

<p>Since your <code>Factory</code>-implementations extend <code>Building</code> they automatically inherit the NOOP-Implementation. But since you override it:</p>

<pre><code>class ShakyFactoryBuilding extends Building implements Factory{

  ShakyFactoryBuilding(){
   super(); 
  }

  @Override
  public void printBuildQuality(){
   println("The build quality is shaky");
  }

  @Override
  public void printFactoryOutput(){
   println("This factory makes slightly different stuff"); 
  }
}
</code></pre>

<p>... you have the desired result.</p>

<p>Drawback is of course that all Buildings do have the <code>printFactoryOutput</code> visible. But that's the trade-off I was talking about. If this is not acceptable, you'll have to completely reconsider your design.</p>

<p>To make it clear that a Building that is <strong>not</strong> a Factory shall not be called that Method on, you could throw an UnsupportedOperationException in Building, but that would force try/catch blocks everywhere in your code. You could as well return a boolean: default=false and returning true if in fact a factory ... There are plenty possibilities.</p>

<p>You could also change your design to use <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance" rel="nofollow">composition over inheritance</a>.</p>
