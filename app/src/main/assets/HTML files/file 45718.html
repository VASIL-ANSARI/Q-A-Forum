<p>Use standard <a href="https://en.wikipedia.org/wiki/Parsing" rel="nofollow">parsing</a> techniques, and read commands from <code>std::cin</code></p>

<p>You might want to declare a type for the vector of arguments.</p>

<pre><code>typedef std::vector&lt;std::string&gt; vectarg_T;
</code></pre>

<p>declare a type for functions processing commands:</p>

<pre><code>typedef std::function&lt;void(vectarg_T)&gt; commandprocess_T;
</code></pre>

<p>and have a map associating command names to their processors:</p>

<pre><code>std::map&lt;std::string,commandprocess_T&gt; commandmap;
</code></pre>

<p>then fill that map at initialization time, e.g. using anonymous functions:</p>

<pre><code> commandmap["echo"] = [&amp;](vectarg_T args){ 
    int cnt=0;
    for (auto&amp; curarg: args) { 
      if (cnt++ &gt; 0)   std::cout &lt;&lt; ' ';
      std::cout &lt;&lt; curarg;
    }
    std::cout &lt;&lt; std::endl;
 };
</code></pre>

<p>If your question is about parsing program arguments (of <code>main</code>), use <a href="http://man7.org/linux/man-pages/man3/getopt.3.html" rel="nofollow">getopt(3)</a> and related functions. GNU libc <a href="http://www.gnu.org/software/libc/manual/html_node/Program-Arguments.html" rel="nofollow">provides</a> also <code>argp_parse</code>.</p>

<p><strong>Consider</strong> perhaps instead <strong>embedding an <a href="https://en.wikipedia.org/wiki/Interpreter_%28computing%29" rel="nofollow">interpreter</a></strong> in your program, e.g. embedding <a href="http://www.gnu.org/software/guile/" rel="nofollow">GNU Guile</a> or <a href="http://lua.org/" rel="nofollow">Lua</a>. But embedding an interpreter is an important architectural design decision and should be made early. Then your application becomes <a href="https://en.wikipedia.org/wiki/Turing_completeness" rel="nofollow">Turing-complete</a>.</p>
