<p>Try using <a href="http://msdn.microsoft.com/en-us/library/system.linq.parallelenumerable.asparallel.aspx" rel="nofollow">ParallelEnumerable.AsParallel</a>.</p>

<pre><code>data.AsParallel.ForEach(DoWork);
</code></pre>

<p>It will automatically create threads depending on amount of processors / cores.
The only problem, that it's included in Framework 4.0.
More info about <a href="http://msdn.microsoft.com/en-us/library/dd460688.aspx" rel="nofollow">PLINQ</a>. (And as <strong>andras</strong> commented: for framwork 3.5 it is available as stand-alone  <a href="http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx" rel="nofollow">Reactive Extensions (Rx)</a>)</p>

<p>UPD: as 0xA3 said, refactoring code, making each item have it's own calc variables is strongly recommended.
I suggest you to extract calculation logics to DataItem</p>

<p>Or create special class like "Calculator", which would be do all the work, so DataItem would only store data, and logics of calculations would be contained in Calculator class.</p>

<pre><code>data.AsParallel.ForEach(x=&gt; new Calculator().DoWork(x));
</code></pre>

<p>where Calculator class is something like this</p>

<pre><code>class Calculator
{
   // variables here

  void DoWork(DataItem item)
  {
     Step1(item);
     Step2(item);
     // ...
     // StepN(item);
  }
}
</code></pre>
