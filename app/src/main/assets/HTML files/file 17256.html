<p>If <code>a</code> is a specific type that declares itself at compile time as implementing <code>P1</code> then you shouldn't need to cast.</p>

<p>If <code>a</code> is of type <code>id</code> then you'll need to cast only if the return type is ambiguous and you're actually using it, or if it had parameters. That'll generally mean that there are multiple method signatures for the method name <code>p1Message</code> so the compiler doesn't know which to expect.</p>

<p>If <code>a</code> is of some type that doesn't declare itself as implementing <code>P1</code> then â unless it separately (and repetitiously) declares <code>p1Message</code> â you'll get a warning because you're calling a method that the object may not implement.</p>

<p>If I had to guess, probably <code>a</code> is declared as being of type <code>id</code> rather than <code>id &lt;P1&gt;</code> (which is more normal for, say, delegates) and you have multiple <code>p1Message</code>s flying around. You might also put the cast in proactively because one day you might have multiple different messages with the same name and someone else that might implement <code>p1Message</code> shouldn't have to know every other place in the project that somebody uses that method name.</p>

<p>The compiler can't induce from the <code>conformsToProtocol:</code> check that it is safe to call <code>p1Message</code> exactly because it's a dynamic runtime. You may have substituted a different implementation of <code>conformsToProtocol:</code> either at compile time or at runtime, meaning that it isn't safe to assume that the compiler knows what it does. That call will be dynamically dispatched just like any other.</p>
