<p>try below solution:</p>

<pre><code>runIt();

function localScoped(arg1, callback) {
  console.log('arg1', arg1);
  callback();
}

function runIt() {
   var myValue = 0;
   async.eachLimit(["hi"], 1,
      function launchOneVar(clientCode, doneLaunchOneVar) {
        //console.log(clientCode);
          async.waterfall([

              function (myCallback) {
                  myValue = clientCode;
                  myCallback(null , myValue);
              },
              async.apply(localScoped)

          ], function (err, result) {
              console.log('last - '+myValue);
              doneLaunchOneVar(null, result);
          });
      },
     function finishing(err) {
     }
  );
}
</code></pre>

<p><strong>how water fall works:</strong> .</p>

<p>Runs a list of async tasks, passing the results of each into the next one.</p>

<p>Runs an array of functions in series, each passing their results to the next in the array. However, if any of the functions pass an error to the callback, the next function is not executed and the main callback is immediately called with the error.</p>

<p>For more detail have a look at: <a href="https://www.npmjs.com/package/async-waterfall" rel="nofollow">https://www.npmjs.com/package/async-waterfall</a></p>
