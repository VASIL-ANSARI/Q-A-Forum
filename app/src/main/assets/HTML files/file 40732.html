<p>When you use overloading, the compiler knows which function to call by examining the type of the parameters passed. So if the parameters are the same, then the possible choice should be only one. In your case, there are two possible candidates differing only in the result. In case you need an alternative route, create your alternative function by passing as last parameter the "result" object as an argument passed by reference. â  </p>

<p>instead of</p>

<pre><code>Object update(std::string , int , std::vector&lt;Object*&gt;);

void update(std::string , int , std::vector&lt;Object*&gt;, Object&amp; o);
</code></pre>

<p>Instead of writing: </p>

<pre><code>Object a=update(s,i,v);
</code></pre>

<p>you will write:</p>

<pre><code>Object a;update(s,i,v,a);
</code></pre>
