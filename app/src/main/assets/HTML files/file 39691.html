<p>In the line:</p>

<pre><code>words_read = sscanf(cmd_buffer, "%d %c%hx x%hx", &amp;cmd_char, &amp;leadChar, &amp;location, &amp;value);
</code></pre>

<p>you tell <code>sscanf()</code> that <code>&amp;location</code> is a <code>short *</code>, but it isn't; it is an <code>int *</code>.  You need to change the conversion specification to <code>%x</code>.  GCC should tell you about this problem, though you might need to twist its arm gently (<code>-Wall</code> is recommended; IIRC, <code>-Wformat</code> is the specific option that's needed, but <code>-Wall</code> is better if you're not using it already).</p>

<p>In fact, as <a href="http://stackoverflow.com/users/2410359/chux">chux</a> points out in a <a href="http://stackoverflow.com/questions/27286900/conflicting-types-with-parameters-in-a-function-in-c/27287061?noredirect=1#comment43041162_27287061">comment</a>, there's also a type mismatch between <code>%d</code> and <code>&amp;cmd_char</code>, too.  Thus, you really need:</p>

<pre><code>words_read = sscanf(cmd_buffer, "%c %c%d x%hx", &amp;cmd_char, &amp;leadChar, &amp;location, &amp;value);
</code></pre>

<p>And if you're not sure whether there might be leading blanks on the string, then add a space before the first <code>%c</code>.  Note that even though you write a space in the format string, <code>sscanf()</code> treats that as optional white space, so the format will accept both of these:</p>

<pre><code>m x305f x002c
mx305fx002c
</code></pre>

<p>and various other inputs too.</p>
