<p>It is likely due to optimization settings or redefinition of <code>inline</code> that force <code>__convert_from_v</code> to be inlined. Here's a small artificial example that reproduces the error:</p>

<pre><code>#define inline __always_inline
#include &lt;bits/c++locale.h&gt;

int main () {
  __locale_t loc;
  return std::__convert_from_v(loc, 0, 0, 0);
}
</code></pre>

<p>Compiling with g++ 4.6.1 on Ubuntu 11.10 gives the error:</p>

<pre><code>/usr/include/c++/4.6/x86_64-linux-gnu/./bits/c++locale.h: In function âint std::__convert_from_v(__locale_struct* const&amp;, char*, int, const char*, ...)â:
/usr/include/c++/4.6/x86_64-linux-gnu/./bits/c++locale.h:70:3: sorry, unimplemented: function âint std::__convert_from_v(__locale_struct* const&amp;, char*, int, const char*, ...)â can never be inlined because it uses variable argument lists
</code></pre>

<p>So check your code for redefinition of <code>inline</code> or try different optimization settings.</p>

<p>I think the reason this function is marked as <code>inline</code> is because it is defined in a header. Without <code>inline</code> you'd get it defined in every translation unit that includes (normally indirectly) this header.</p>
