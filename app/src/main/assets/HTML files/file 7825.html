<p>well you can just bind the service instead of starting it. that means it's a local service which will get stopped when there arent any more activities bound to it. but be carefull because the service runs in the ui thread so move things in a background thread. what i have commonly used in situations like this is a handler that postDelayed a runnable executing an async task where you can do whatever you want to do and then rescheduling it so it runs in some time period. also remove the callbacks when the service is destroyed and start it sticky so that if it is killed it restarts and you can also remove the callbacks on start.</p>

<p>As an alternative you can use an intent service or a simple service with alarms that is started by the alarm on specific time periods, that calls selfStop after it has completed a scan. but if you are running frequent checks then this creates an overhead because the service needs to be created over and over again (so better keep it running then).</p>

<p>there is also the timerTask class but i simply find this 2 solutions better. the timer class introduces a new thread </p>

<p>see: <a href="http://developer.android.com/reference/java/util/Timer.html" rel="nofollow">Timer</a></p>

<p><a href="http://steve.odyfamily.com/?p=12" rel="nofollow">And This for an implementation</a></p>

<p>and here is someone that tried to do the same thing as you are:</p>

<p><a href="http://stackoverflow.com/questions/2161750/android-controlling-a-task-with-timer-and-timertask">Timer task and answers</a></p>
