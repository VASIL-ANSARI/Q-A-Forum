<p>They are reserved words <em>and</em> built-in values. From the <a href="https://docs.python.org/3/whatsnew/3.0.html#changed-syntax" rel="nofollow">Python 3 What's New</a>:</p>

<blockquote>
  <p><code>True</code>, <code>False</code>, and <code>None</code> are reserved words. (2.6 partially enforced the restrictions on <code>None</code> already.)</p>
</blockquote>

<p>This means you cannot use them as names, assigning a different value to them. This prevents accidentally masking the built-in singleton values:</p>

<pre><code>&gt;&gt;&gt; True = False
  File "&lt;stdin&gt;", line 1
SyntaxError: can't assign to keyword
</code></pre>

<p>Also see <a href="http://python-history.blogspot.co.uk/2013/11/story-of-none-true-false.html" rel="nofollow">Guido van Rossum's history lesson on <code>None</code>, <code>True</code> and <code>False</code></a>:</p>

<blockquote>
  <p>I still forgot to answer whether None/True/False are literals or keywords. My answer is that they are both. They are keywords because that's how the parser recognizes them. They are literals because that's their role in expressions and because they stand for constant values.</p>
</blockquote>

<p>With <code>True</code>, <code>False</code> and <code>None</code> classified as keywords, the Python compiler can actually optimize their use, since you cannot (directly) rebind these names  Python can look them up as constants instead of globals, which is faster. </p>

<p>Until Python 3.4 there were still some corner cases where the compiler would issue a global lookup for these objects, see <a href="http://bugs.python.org/issue16619" rel="nofollow">issue 16619</a>. From Python 3.4 onwards the Python parser has been extended to produce a new AST node <code>NameConstant</code> to ensure that they are treated as constants everywhere. </p>
