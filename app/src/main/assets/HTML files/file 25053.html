<p>This can be an issue with the check you are doing, try SQLITE_OK. Its said here in <a href="http://www.sqlite.org/c3ref/step.html" rel="nofollow">docs</a> as In the legacy interface(older interface), the return value will be either <strong>SQLITE_BUSY, SQLITE_DONE, SQLITE_ROW, SQLITE_ERROR, or SQLITE_MISUSE</strong>. With the <strong>"v2" interface</strong>, any of the other result codes or extended result codes might be returned as well.</p>

<pre><code>if (sqlite3_prepare_v2(_mDb, insert_stmt, -1, &amp;statement, nil) == SQLITE_OK)
        {
            if (sqlite3_step(statement) == SQLITE_DONE)
            {
               return YES;
            }
            else 
            {
              NSLog(@"failed to add user");
            }
            sqlite3_finalize(statement);
        }
</code></pre>

<p>you can also find a similar question and its answer <a href="http://stackoverflow.com/questions/1053020/does-insert-in-sqlite-return-sqlite-ok-or-sqlite-done">here</a></p>

<p>Insert a curly brace after the prepare statement and close it after finalize statement. As you get SQLITE_MISUSE, it can be that this routine was called inappropriately. Perhaps it was called on a prepared statement that has already been finalized or on one that had previously returned SQLITE_ERROR or SQLITE_DONE. Or it could be the case that the same database connection is being used by two or more threads at the same moment in time.</p>

<p>Hope this helps :)</p>
