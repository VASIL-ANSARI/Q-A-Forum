<p>If it is only one message that is the problem, why not write it to a file (and flush the file) before you process the message. After acking the message, delete the file. </p>

<p>And if you are concerned about the message broker crashing, first step is to upgrade it to RabbitMQ 2.4.1 running on Erlang R14B02. Second step is to cluster it so that you have multiple servers acting as the MQ broker. And only then, change your app to track the messages that have been processed, either by timestamp or by saving message IDs. Then, if RabbitMQ requeues a message, you will already have it and will process it and remember it. When it comes around a second time you will ignore it.</p>

<p>You may need to set prefetch to 0 for this to work right.</p>

<p>And there is another alternative too. You could consider writing your own RabbitMQ plugin to provide the exact behaviour that you need. Erlang may look complex at first sight, but it really isn't that hard to learn for an experienced programmer who has already learned a few languages. In particular, if you have anyone with functional programming experience in languages like Haskell or CAML, they will quickly pick up enough Erlang to do the job.</p>

<p>Because of Erlang's internal model of message-passing processes, RabbitMQ plugins can essentially do anything that they want. There is no specific limited plugin API that they need to conform to. </p>

<p>In other words, if RabbitMQ only does 99% of what you need, consider yourself lucky that with a small amount of work, you can leverage that 99% and achieve everything that you need. But in order to do this you have to get away from the idea that RabbitMQ is yet another package that you install with your system's package installation tools. In cases like yours RabbitMQ should be considered to be a mission critical tool, and you should install Erlang and RabbitMQ from source, and configure them to your needs without letting your OS limit you.</p>
