<p>If you enable some warnings for your code, a good compiler will warn you that you are "returning the address of a local variable" (or something like that). </p>

<pre><code>char** func1_Str()
{
    char *p = "Linux";
    return &amp;p;
}
</code></pre>

<p>In this example, <code>p</code> is located on the stack, and initialized with the address of the constant string <code>"Linux"</code>. You are then returning the address of <code>p</code> on the stack, and immediately after that, the stack pointer is reset when the function returns to the caller. When you then call <code>func2_Str</code>, the same location on the stack is then reused <code>p</code>
 in <code>func2_Str</code>. The stack is like a stack of plates in a kitchen, you put new ones on when you call into a function, you take the off again when returning. </p>

<p>So, yes, you'll get the same address for both of your pointers, and because of that, anything they point to will be the same as well, of course. </p>

<p>The name of the variable has nothing to do with it (as you would have found out if you tried the simple experiment of renaming one of them to something else). You could also do something like this:</p>

<pre><code>char** func1_Str()
{
    char *q = "Windows";
    char *p = "Linux";
    return &amp;p;
}
</code></pre>

<p>And you'd (probably) see that <code>p</code>'s value has changed, because we now need another four bytes. </p>

<p>(I also find it rather amazing that your system gets EXACTLY the same address as the example in the link - are you actually compiling this yourself, or just copying and pasting from the site)
(Of course, if you had actually read the text on the site you linked, you would have understood that)</p>
