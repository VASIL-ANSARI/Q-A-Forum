<h2>C#</h2>

<p>It is possible by making the two methods part of two different interfaces, and casting the object to one of the two interfaces. For example:</p>

<pre><code>interface ILoopingIterator
{
    void Next();
    void Previous();
}

interface INonLoopingIterator
{
    void Next();
}

class PlaysItBothWays : ILoopingIterator, INonLoopingIterator
{
    void ILoopingIterator.Next()
    {
         this.NextCore();
    }

    void ILoopingIterator.Previous()
    {
         // since this code will never be shared anyway, put it here
    }

    void INonLoopingIterator.Next()
    {
         this.NextCore();
    }

    private void NextCore()
    {
        // do stuff here; this method only exists so that code can be shared
    }
}
</code></pre>

<p>Note that I have made the class implement <em>both</em> interfaces explicitly; this way, users of instances are <em>forced</em> to select which "mode" they want to use the class in. You could implement only one interface explicitly instead (providing a "default" mode that can be changed).</p>

<p>and now:</p>

<pre><code>var looping = (ILoopingIterator) new PlaysItBothWays(); // selects mode A
var nonLooping = (INonLoopingIterator) new PlaysItBothWays(); // selects mode B
</code></pre>

<p>Of course this does not stop anyone from casting the instance to the "other" interface if they want to, but if the programmer wants to subvert their own code they can also use reflection which allows much more than that.</p>

<h2>Java</h2>

<p>In Java, the above is not possible. You can come close by having the class expose methods that return instances of one of the two interfaces, and using the returned value. Of course then the object is really a factory and not a service provider, so that's feels like cheating on the problem.</p>

<pre><code>class PlaysItBothWays
{
    public ILoopingIterator asLooping() { return /* something */ }
    public INonLoopingIterator asNonLooping() { return /* something else */ }
}
</code></pre>
