<p>The function <code>GetText()</code> won't give you the actual name of the node in question, but the text inside the node. For instance, invoking <code>GetText()</code> on this hypothetical node</p>

<pre><code>&lt;node&gt;This is text!&lt;/node&gt;
</code></pre>

<p>will yield "This is text!" as a <code>const char*</code> or a <code>const std::string&amp;</code> depending on how you compile. See the API reference of <a href="http://www.grinninglizard.com/tinyxmldocs/classTiXmlElement.html" rel="nofollow">TiXmlElement</a>.</p>

<p>If you want to query the node name itself, use <code>TiXmlNode::Value()</code>.</p>

<p>If you want an attribute, simply use <code>Attribute(const char*)</code> or <code>QueryStringAttribute(...)</code> on the element. For instance, retrieving and printing the following with the document you provided</p>

<pre><code>std::cout &lt;&lt; doc.FirstChildElement ()-&gt;FirstChildElement ()-&gt;Attribute ("name") &lt;&lt; std::endl;
</code></pre>

<p>yields "testAPPlication".</p>

<p>In general, see the <a href="http://www.grinninglizard.com/tinyxmldocs/index.html" rel="nofollow">full documentation</a> of TinyXML first.</p>

<p><strong>EDIT:</strong> The following example depicts in a simple, yet ugly way what you need:</p>

<pre><code>TiXmlDocument doc;

if(doc.LoadFile ("test.xml"))
{
  TiXmlElement* graphElem   = doc.FirstChildElement()-&gt;FirstChildElement ()-&gt;FirstChildElement ();
  TiXmlElement* channelElem = graphElem-&gt;FirstChildElement ();

  for(; channelElem; channelElem = channelElem-&gt;NextSiblingElement ())
  {
    std::cout &lt;&lt; channelElem-&gt;Attribute ("producer")
              &lt;&lt; " | "
              &lt;&lt; channelElem-&gt;Attribute ("consumer")
              &lt;&lt; std::endl;
  }
}
</code></pre>

<p><strong>EDIT2</strong>: Removed infinite loop and conditional.</p>
