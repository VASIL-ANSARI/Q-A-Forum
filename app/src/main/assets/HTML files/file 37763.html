<p>Something like this will skip over the nulls. It resorts to a linear search once it hits nulls, but I can't think of a better way to do it.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

int search(char arr[][20], char *strtofind, int l, int r)
{
    int mid , val, down = 1, start;
    if(l &lt;= r)
    {
        mid = (l+r)/2;
        start = mid;
        while(0 == arr[mid])
        {
            if(down)
            {
                if(mid &gt;= l)
                {
                    mid--;
                }
                else
                {
                    down = 0;
                    mid = start;
                }
            }
            else
            {
                if(mid &lt;= r)
                {
                    mid++;
                }
                else
                {
                    return -1;
                }
            }
        }
        val = strcmp(strtofind, arr[mid]);
        if(val == 0)
            return mid;
        else if(val &gt; 0)
        {
            return search(arr, strtofind,mid+1,r);
        }
        else
        {
            return search(arr, strtofind, l, mid-1);
        }
    }
    return -1;
}

int main(int argc, char** argv)
{

    int idx;
    char arr[][20] = {"STR1", "STR2","STR3","STR4"};

    int num = sizeof(arr)/sizeof(arr[0]);
    idx = search(arr, "STR2", 0, num-1);
    if(-1 != idx)
    {
        printf("Found at = %d\n", idx);
    }
    else
    {
        printf("Not found");
    }
    return (EXIT_SUCCESS);
}
</code></pre>
