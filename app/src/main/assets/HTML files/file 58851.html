<p>If in the first version of the code <code>size</code> is <code>sizeof(addr6)</code> (as you stated in the comments), then the first version of the code uses <code>memcpy</code> to copy <code>sizeof(struct sockaddr_in6)</code> bytes of data.</p>

<p>The second version of the code uses regular <code>struct sockaddr</code> assignment to copy only <code>sizeof(struct sockaddr)</code> bytes.</p>

<p><code>sizeof(struct sockaddr)</code> is smaller than <code>sizeof(struct sockaddr_in6)</code>, which makes these two code samples different.</p>

<p>Note that in the first version the recipient object in that <code>memcpy</code> is of <code>struct sockaddr</code> type, i.e. it is smaller than the number of bytes copied. Memory overrun occurs, which clobbers some other data stored in adjacent memory locations. The code "works" only by accident. I.e. if this bit "works", then some other piece of code (the one that relies on the now-clobbered data) is likely to fail.</p>
