<p>Never say never, in SQL.</p>

<p>The statement:</p>

<pre><code>select percent_rank() over (partition by &lt;x&gt; order by &lt;y&gt;)
</code></pre>

<p>is essentially equivalent to:</p>

<pre><code>select row_number() over (partition by &lt;x&gt; order by &lt;y&gt;) / count(*) over (partition by &lt;x&gt;)
</code></pre>

<p>Essentially means that it works when there are no duplicates in the data.  It should be close enough even when there are duplicates.</p>

<p>The "real" answer is that it is equivalent to:</p>

<pre><code>select row_number() over (partition by &lt;x&gt; order by &lt;y&gt;) / count(distinct &lt;y&gt;) over (partition by &lt;x&gt;)
</code></pre>

<p>But, we don't have count(distinct) as a function.  And, it is a pain to express in 2008, unless you really need to.</p>

<p>The function cume_dist() is harder because it requires a cumulative sum, and you need a self join for that.  The approximation assuming no duplicates:</p>

<pre><code>with t as (select &lt;x&gt;, &lt;y&gt;,
                  row_number() over (partition by &lt;x&gt; order by &lt;y&gt;) as seqnum
           from &lt;table&gt;
          )
select t.*, sumy*1.0 / sum(sumy) over (partition by &lt;x&gt;)
from (select t.*, sum(tprev.y) as sumy
      from t left outer join
           t tprev
           on t.x = tprev.x and t.seqnum &gt;= tprev.seqnum
     ) t
</code></pre>
