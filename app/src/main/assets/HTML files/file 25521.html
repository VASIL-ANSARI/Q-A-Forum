<p>The question is a little broad but here's my analysis of the code posted.</p>

<p>Option 3 is nothing but a more redundant option 1: <code>$.fn.find</code> already returns a jQuery object, there is no need to decompose it and add its elements to yet another jQuery object.</p>

<p>Option 2 is fine when you're doing something completely different with each element:</p>

<pre><code>node
  .find('a').doThis().end()
  .find('b').doThat();
</code></pre>

<p>Note that <code>.end()</code> is most likely slower than using <code>node.find()</code> again - a variable lookup is usually faster a function call, but then we're talking about microseconds.</p>

<p>I'd consider option 1 the best performance-wise, as it will perform only a single DOM query.</p>

<p>Note that if you're applying simple methods without element-specific logic, you don't need <code>.each()</code>, so then you have an option 4:</p>

<pre><code> node.find('a,b,c,d,e').doSomething();
</code></pre>

<p>That is, jQuery does implicit iteration applying <code>doSomething</code> to each matched element.</p>

<p>All of these will have unnoticeable performance difference unless applied inside a huge loop. <a href="http://jsperf.com/" rel="nofollow">jsPerf</a> is the tool to run performance tests, but note that modern JS engines such as V8 do a quite good job optimizing repetitive behavior.</p>

<p>Also, remember <em>"Premature optimization is the root of all evil"</em>. Deal with performance issues as they become apparent. Don't sacrifice readability for microseconds. You can use optimization tools such as <a href="http://closure-compiler.appspot.com/home" rel="nofollow">Closure Compiler</a> before deploying to gain some micro/milliseconds performance.</p>
