<p>This is a string literal in SQL:</p>

<pre><code>'to'
</code></pre>

<p>This is a quoted identifier in (standard) SQL:</p>

<pre><code>"to"
</code></pre>

<p>This is a quoted identifier in MySQL:</p>

<pre><code>`to`
</code></pre>

<p>SQLite also supports the MySQL-specific syntax for compatibility reasons. And for completeness, this is a quoted identifier in SQL Server:</p>

<pre><code>[to]
</code></pre>

<p>PostgreSQL follows the standard.</p>

<p>So when you say this:</p>

<pre><code>Model.where("'to' &gt; ?", Time.now)
</code></pre>

<p>you're trying to compare a constant string with a timestamp that is formatted as a string. That would be like this in Ruby:</p>

<pre><code>'to' &gt; '2015-11-11 09:27:11'
</code></pre>

<p>so of course it doesn't work as expected.</p>

<p>You have various options:</p>

<ol>
<li>Rename the column so that you don't have to worry about quoting it.</li>
<li>Use the same database in your development, test, and production environments so that you don't have to worry about identifier quoting differences. This is a really good idea anyway, there are many differences between databases that ActiveRecord won't help you with.</li>
<li>Try to get ActiveRecord to write the SQL for you. This doesn't work that well for non-<code>=</code> comparisons unless you want to make a big confusing mess with AREL.</li>
</ol>

<p>I would start with <strong>2</strong> because, as I said, there are many differences between databases (identifier quoting, reserved words, case sensitivity, date/time manipulation functions, SQL functionality, column types, GROUP BY behavior, ...) that ActiveRecord cannot help you with. Developing and testing on top of one database but deploying on another is just asking for trouble.</p>
