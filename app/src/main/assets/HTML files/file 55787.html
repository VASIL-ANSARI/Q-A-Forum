<p>If we assume no overflow in the calculations:</p>

<pre><code>int function (unsigned int a[], int n) {
    if (n &gt;= 0) return !function(a, -n-1);
    if (++n == 0) return 0;
    return function(a+1, n) + ((a[0] % 2) ? -a[0] : a[0]);
}
</code></pre>

<blockquote class="spoiler">
  <p> On first call into the function, the <code>n</code> is nonnegative, and reflects the size of the array. We recursively call the function and logically negate the result, and arithmetically negate <code>n+1</code>. The off by one negation allows <code>-1</code> to represent <code>0</code><p>On subsequent calls, the sum of evens are positively accumulated, and odds are negatively accumulated. The negative <code>n</code> is incremented until it reaches <code>0</code>. The result of the recursive calls on the negative <code>n</code> is <code>0</code> if the sums are equal, and non-zero otherwise.<p>On return to the outermost call, the logical negation flips it so that <code>1</code> is returned if the sums are equal and <code>0</code> otherwise.</p>
</blockquote>

<p>I'll leave it as an exercise to appropriately deal with overflow.</p>
