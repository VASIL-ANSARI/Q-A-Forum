<p><em>First, let me get this rant out of the way:</em> what you propose is very bad design. It fits the definition of <a href="http://en.wikipedia.org/wiki/Code_smell" rel="nofollow">smelly code</a>.</p>

<p>If you insist on doing it this way, the "best" approach to take is to declare some public variables on your page that return the actual UI elements.</p>

<pre><code>&lt;UserControl x:Class="MyNamespace.MyPage"  ...&gt;
    &lt;Grid&gt;
        &lt;TextBox x:Name="SomeTextBox" Width="100" /&gt;
    &lt;/Grid&gt;
&lt;/UserControl&gt;


public class MyPage
{
    public TextBox MyTextBox
    {
        get { return SomeTextBox; }
    }
}


public class SomeOtherClass
{
    private void SomeFunction()
    {
        var page = new MyPage();
        page.MyTextBox.Text = "some text";
    }
}
</code></pre>

<p>Of course the preferred method would be to use something like the MVVM pattern to implement binding from your window to its viewmodel, then you can just read the property values from the viewmodel, this way you avoid trying to touch any UI elements from a totally different class.  </p>

<p>Another way to do it (without going the full MVVM route) is to inject the necessary values into the constructor of the control/page that you are instantiating, and from there you can assign them to the appropriate UI element properties. This is still smelly, but better than directly accessing the UI elements from the outside.</p>
