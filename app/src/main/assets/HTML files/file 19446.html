<blockquote>
  <p>Are there any other ways to achieve synchronization in that scenario (not using AtomicInteger)?</p>
</blockquote>

<p>First off, you should be using <a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/atomic/AtomicInteger.html" rel="nofollow"><code>AtomicInteger</code></a> if you can.  I'm not sure why you would not use it.</p>

<blockquote>
  <p>Would volatile keyword work here?</p>
</blockquote>

<p>Yes except not for the <code>++</code>. <code>AtomicInteger</code> provides a safe increment without locking.  If you want to roll your own (for some crazy reason) then you will need the blocking or you need to duplicate the <code>AtomicInteger</code> internal spin mechanisms.</p>

<blockquote>
  <p>But what about get()? I have read it should be synchronized too, but could someone explain me why? </p>
</blockquote>

<p><code>AtomicInteger</code> wraps a <code>volatile int</code> to provide its functionality.  When you access the <code>volatile</code> field you cross a memory barrier on the <code>get()</code> as well.   You <em>need</em> to cross that memory barrier to ensure that if another thread has updated the value, the thread calling the <code>get()</code> sees the update.  Otherwise, a thread could be working with a very outdated value.</p>
