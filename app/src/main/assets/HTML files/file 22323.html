<p>I would consider the separation of the interface from the implementation. e.g. in Java</p>

<pre><code>interface Cancellable {
   void cancel();
}
interface Shippable{
   void ship();
}
</code></pre>

<p>etc.</p>

<pre><code>public class NewState implements Cancellable, Shippable {
  public void cancel() { ... }
  public void ship() { ... }
}
</code></pre>

<p>If you have an underlying private State, it can implement <em>all</em> the required interfaces, and your public States need only delegate those supported states. e.g.</p>

<pre><code> public class UnderlyingState implements Cancellable, Shippable ... {
    public void cancel() { ... }
    public void ship() { ... }
 }

  public class ShippableState implements Shippable {
     private UnderlyingState ustate = new UnderlyingState();
     public void cancel() {
        // you can *only* cancel this
        ustate.cancel();    
     }
   }
</code></pre>

<p>In the above you'd probably need to return a new state object (rather than <code>void</code>) and have your <code>Order</code> adopt that new state. The <code>UnderlyingState</code> object would enforce some state machine.</p>

<p>The headache with this is that as your number of states increase, your interfaces and implementation increases too.</p>
