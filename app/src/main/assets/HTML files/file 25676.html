<p>1) you would get <code>scroll_position*one_stepscroll</code>   .you would find begining item index with  <code>scroll_position*one_stepscroll/item.height -1</code> and last item index with adding 
constant  item sizes (panel.height/item.height+1 ) .
then u would draw items to backbuffer  (as u see from calculations its height will be greater than panel.height of course ) . then show that buffer on panel graphics .so this is how double buffering works .`(if your controls will contain big images to draw then you can use some lazy loading techniques. proxy pattern  to speed up scrolling , check this : <a href="http://www.informit.com/articles/article.aspx?p=30367" rel="nofollow" title="proxy pattern">proxy pattern</a></p>

<p>1A)if your item.heights differ then you have find first item different way. i would 
suggest you for performance to store each items begining position too . this way u will 
reduce calculation instead of  finding looping throw items and adding heights each time</p>

<p>2)you will get its state and show state . for example u can do . <code>filled rectangle as for checked hollow rectangle for unchecked</code> .(think it will be your own object with additional boolean state property ,or just boolean variable and with its  x,y,width,height  ) .on panel click you will check click position with visible checkbox items areas . then you would change its <code>state = !state</code> . then again you will redraw whole panel again for visible items .</p>

<p>3)3rd way  just change contents when scrolling and use controls . and scrolling step  will be one object  movement . Trust me on long run user prefer easy workng over fance shamancy things.   .just use 10 controls items  . and 100 objects storing values for it . on scrolling you would   just change those 10 items display properties (text ,state or image or whatever) from 100    objects . this way you will use controls itself .easy solution for performance and memory too.   </p>
