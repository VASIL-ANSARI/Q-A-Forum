<p>I think this variation is mixing a bit of MVC with a bit of MVVM, although it's none of both. So, the <code>Model-View</code> part of the pattern is solved in your proposal by injecting the models straight into the view implementation and then send some kind of commands, via events.</p>

<p>You then need to solve or go around the <code>View-Model</code> part of the pattern by either providing properties in the model that can be set directly by the view, or by exposing some events in the view and do the same kind of injection in the model. </p>

<p>I think it will get ugly. Even if the model is only a set of observable entities and you control them from somewhere else (the controller? :)). </p>

<p>I can already see the code, countless events and properties mixed and mingled... But it all depends on how complicated your UI will become, how many views you will have and how complex will they get. In a view with 10+ buttons and/or inputs I think is a bad idea to go with this approach.  </p>

<p>I say that as long as you do not have a dedicated MVVM infrastructure, like WPF or HTML, there's no point in implementing your own. You can't get to that beautiful degree of separation only with a hand-coded framework. You need some support to entirely separate the UI code from the model, do bindings and so on.</p>

<p>Perhaps you can comment some more on what you want to use it. If you need it for a client framework (like HTML/JS) or for a Windows Forms implementation then there may be some dedicated solutions you could use, or better, some easier paths you could take. </p>

<p>This all comes from a guy who implemented an MVP variation on top of ASP.NET Web Forms. If I only could turn back time. </p>
