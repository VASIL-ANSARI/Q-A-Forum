<p>The short answer is that you should make the property you need available through the view's controller.</p>

<p>In your example, because <code>OtherView</code> is nested in the <code>ApplicationView</code>'s template, it will have a <code>controller</code> property that is set to <code>ApplicationController</code>. In your router, you can call <code>router.applicationController.connectControllers('externalData')</code>. That will set an <code>externalDataController</code> property on <code>applicationController</code>. Then you can expose the property you need:</p>

<pre><code>App.ApplicationController = Em.ArrayController.extend
  content: [] #Assume a bunch of values of some kind here
  externalDataController: null # set via connectControllers call in router
  stellarPropertyBinding: Em.Binding.oneWay('externalDataController.stellarProperty')
</code></pre>

<p>And <code>OtherView</code> becomes:</p>

<pre><code>App.OtherView = Em.View.extend
  templateName: 'other-view'
  someComputedProperty: (-&gt;
    @get('controller.stellarProperty') + ' flying pigs'
  ).property('controller.stellarProperty')
</code></pre>

<p>Hope that helps!</p>
