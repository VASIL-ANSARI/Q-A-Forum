<p>Is this homework? If not, use <code>std::stable_partition()</code>:</p>

<pre><code>struct IsEven {
    template&lt;class T&gt;
    bool operator()(const T&amp; v) const { return v % 2 == 0; }
};

int* arr = {1,2,3,4,5,6,7,8};
int* mid = std::stable_partition(arr, arr+8, IsEven());
</code></pre>

<p>If it is a homework, then your instructor probably expects you to write the algorithm. If you don't have to maintain the ordering as in the input sequence then you can do it rather efficiently:</p>

<ol>
<li>Find the <strong>first</strong> element that <strong>doesn't</strong> satisfy the predicate (i.e., is <em>odd</em>).</li>
<li>Find that <strong>last</strong> element that <strong>does</strong> satisfy the predicate (i.e., is <em>even</em>)</li>
<li>swap the two elements.</li>
<li>Repeat, starting from the positions you just found, until the two positions meet.</li>
<li>The point where the two positions meet is the <strong>middle</strong> of the partition, where even numbers stop and odd numbers begin.</li>
</ol>

<p>This is roughly how <code>std::partition()</code> works. If you do have to maintain the relative ordering in the input array then you can still do it in-place, but it will be faster if you use a temporary buffer. Copy the elements that don't match the predicate into that buffer, and squeeze in place those that do. Finally bring back in the elements that don't match, at the end of the array, in order.</p>
