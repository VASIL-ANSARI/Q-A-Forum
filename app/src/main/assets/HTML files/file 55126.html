<p>This solution is not better than <code>O(N*M*Log(N)*Log(M))</code>, but it is better than your implementation.</p>

<p>By seeing your order of execution of <code>for</code> loops and accessing of array <code>M</code>, There will be too many Memory jump and cache miss which cause program to run slow.</p>

<p>Example:-</p>

<p>See the time taken by following Loops:</p>

<pre><code>int M[1000][1000][11][11];
for(int i = 0 ; i &lt;= 10 ; i++){
    for(int j = 0 ; j &lt;= 10 ; j++){
        for(int x = 0 ; x &lt; 1000 ; x++){
            for(int y = 0 ;  y &lt; 1000 ; y++){
                M[x][y][i][j] = 1;
            }
        }
    }
}
</code></pre>

<p>Above execution take <strong><em>1.9 sec</em></strong>.</p>

<pre><code>int M[11][11][1000][1000];
for(int i = 0 ; i &lt;= 10 ; i++){
    for(int j = 0 ; j &lt;= 10 ; j++){
        for(int x = 0 ; x &lt; 1000 ; x++){
            for(int y = 0 ;  y &lt; 1000 ; y++){
                M[i][j][x][y] = 1;
            }
        }
    }
}
</code></pre>

<p>And this one takes only <strong><em>0.2 sec</em></strong>. So always try to write loops such that there is sequential access of memory.</p>

<p>For more details you can read <a href="http://stackoverflow.com/questions/9936132/why-does-the-order-of-the-loops-affect-performance-when-iterating-over-a-2d-arra">here</a>.</p>

<p>So if you change your code in following manner it will be much more faster:</p>

<pre><code>M[Log(n)][Log(m)][n][m];
for(int i=0; (1&lt;&lt;i) &lt;= n; i++)
        for(int j=0; (1&lt;&lt;j) &lt;= m; j++)
            for(int x=0; x + (1&lt;&lt;i)-1 &lt; n; x++)
                for(int y = 0; y + (1&lt;&lt;j) -1 &lt; m; y++)
                {
                    i=(int)i;
                    j=(int)j;
                    if (i == 0 &amp;&amp; j == 0)
                            M[i][j][x][y] = arr[x][y]; 
                    else if (i == 0)
                            M[i][j][x][y] = maxi(2,M[i][j-1][x][y], M[i][j-1][x][(y+(1&lt;&lt;(j-1)))]);
                    else if (j == 0)
                            M[i][j][x][y] = maxi(2,M[i-1][j][x][y], M[i-1][j][(x+ (1&lt;&lt;(i-1)))][y]);
                    else 
                            M[i][j][x][y] = maxi(4,M[i-1][j-1][x][y], M[i-1][j-1][(x + (1&lt;&lt;(i-1)))][y], M[i-1][j-1][x][(y+(1&lt;&lt;(j-1)))], M[i-1][j-1][(x + (1&lt;&lt;(i-1)))][(y+(1&lt;&lt;(j-1)))]);
                }
</code></pre>

<p>And one more optimization can be done, if you are calculation <code>log()</code> too many times (i.e order of 10^5 or greater) than you can use <code>31-__builtin_clz()</code> instead  of <code>log()</code>.</p>

<pre><code>k = 31-__builtin_clz(x1 - x + 1);
l = 31-__builtin_clz(y1 - y + 1);
int max_element = max(4,M[k][l][x][y], M[k][l][(x1 - (1&lt;&lt;k) + 1)][y], M[k][l][x][(y1 - (1&lt;&lt;l) + 1)], M[k][l][(x1 - (1&lt;&lt;k) + 1)][(y1 - (1&lt;&lt;l) + 1)]);
</code></pre>
