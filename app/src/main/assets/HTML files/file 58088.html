<p>Usually when creating forms in rails you use form_for to create a form is bound to a single model instance for example: <code>form_for(@thing)</code>.</p>

<p>However when constructing something like a search query or filters you just want a plain old form without any data binding since the goal is not to create or modify a resource.</p>

<pre><code>&lt;%= form_tag(profiles_path, method: :get) do %&gt;
  &lt;% label_tag 'fees_to', 'Maximum fee' %&gt;
  &lt;% number_field_tag 'fees_to' %&gt;
  &lt;% submit_tag 'Search' %&gt;
&lt;% end %&gt;
</code></pre>

<hr>

<pre><code>def index
  @profiles = Profile.all
  @profiles = @profiles.fees_to(params[:fees_to]) if params[:fees_to].present?
end
</code></pre>

<hr>

<blockquote>
  <p>explain the difference between using Profile. instead of @profile?</p>
</blockquote>

<p><code>Profile</code> is a constant - which in this case contains the class <code>Profile</code>.
<code>@profile</code> is a instance variable - in this context it belongs to the controller and will most likely be <code>nil</code> since it is the index action.</p>

<pre><code>Profile.fees_to(50) # calls the class method `fees_to` on `Profile`.
@profile.fees_to(50) # will most likely give a `NoMethodError`.
</code></pre>

<p>However when you are doing:</p>

<pre><code>@profiles = Profile.all
@profiles = @profiles.fees_to(params[:fees_to]) if params[:fees_to].present?
</code></pre>

<p>What is happening is that you are just chaining scope calls like in this example:</p>

<pre><code>@users = User.where(city: 'London')
             .where(forename: 'John')
</code></pre>

<p>except that instead of chaining you are mutating the variable <code>@profiles</code>.</p>
