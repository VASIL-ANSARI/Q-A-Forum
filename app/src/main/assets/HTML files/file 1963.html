<p>Yes, <code>std::auto_ptr</code> calls <code>delete</code> on its content when it goes out of scope. You use <code>auto_ptr</code> only if no shared ownership takes place.<br>
<code>auto_ptr</code> isn't particularly flexible, you can't use it with objects created with <code>new[]</code> or anything else.</p>

<p>Shared ownership is usually approached with shared pointers, which e.g. <a href="http://www.boost.org/doc/libs/1_41_0/libs/smart_ptr/smart_ptr.htm" rel="nofollow">boost</a> has implementations of. The most common usage, implemented e.g. in Boosts <code>shared_ptr</code>, employs a <a href="http://en.wikipedia.org/wiki/Reference_counting" rel="nofollow">reference counting</a> scheme and cleans up the pointee when the last smart pointer goes out of scope.<br>
<code>shared_ptr</code> has one big advantage - it lets you specify custom deleters. With that you can basically put every kind of resource in it and just have to specify what deleter it should use.</p>
