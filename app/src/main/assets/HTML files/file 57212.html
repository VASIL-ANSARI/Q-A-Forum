<p>When <code>i = 2500, n = 10000, j = 0, sizeof(int) = 4</code>, <code>(i * n + j) * sizeof(int)</code> will become <code>100000000</code>.</p>

<p><code>*(adj + (i * n + j) * sizeof(int))</code> is equivalent to <code>adj[(i * n + j) * sizeof(int)]</code>, so accessing <code>adj[100000000]</code> will cause out-of-range access, which invokes <em>undefined behavior</em> if only 100000000 elements are allocated via <code>adj = (int *)calloc(n * n, sizeof(int));</code>.</p>

<p>To fix this problem, remove the harmful <code>* sizeof(int)</code> so that it can access the elements of the array properly.</p>

<pre><code>void adjSetter(int i, int j, int value) {
    *(adj + (i * n + j)) = value;
}
</code></pre>

<p>Better thing is to use array indexing, which I think is more easy-to-read and write.</p>

<pre><code>void adjSetter(int i, int j, int value) {
    adj[i * n + j] = value;
}
</code></pre>
