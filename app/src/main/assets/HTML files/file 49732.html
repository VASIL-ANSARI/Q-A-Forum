<p>The type returned by Garage.getCar is Automobile, it's not going to expose any of these park methods. Since the shift methods are static you're not going to get polymorphic behavior out of them, they have to be called on the specific classes. </p>

<p>It is likely you are expecting the thing using the Automobile to be too smart about how it's using the Automobile, thereby defeating the purpose of using an interface. The point of using interfaces or superclasses like this is so that the program can manipulate objects at a high level without caring about implementation details, letting the different object implementations take care of themselves. An analogous toy example might be an Automobile that exposed a park method, where that park method was implemented differently by the specific subclass according to its specific needs. </p>

<p>(Or alternatively get rid of the interface altogether, since driving a Mustang is not anything like driving a Corolla it might not make sense for them to share an interface.) </p>

<p>Interfaces and superclasses help provide a high-level interface and hide implementation details so they can be contained locally and don't leak out all over the rest of the program. Work out how you want the object to be used, which defines the interface you want to expose, and what you want the object to take care of on its own.</p>
