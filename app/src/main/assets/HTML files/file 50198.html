<p>Overloading is done based on the static type of the argument. If the object <code>foo</code> you use an operator with is non-<code>const</code> the non-<code>const</code> overload is used. If it is <code>const</code> the <code>const</code> overload is used.</p>

<p>If you want to distinguish between reading and writing you'll need to return a proxy from your subscript operator which converts to the suitable type for reading and has a suitable assignment operator for writing:</p>

<pre><code> class X;
 class Proxy {
     X*  object;
     Key key;
 public:
     Proxy(X* object, Key key): object(object), key(key) {}
     operator V() const { return object-&gt;read(key); }
     void operator=(V const&amp; v) { object-&gt;write(key, v); }
 };
 class X {
     // ...
 public:
     V    read(key) const;
     void write(key, V const&amp; v);
     Proxy operator[](Key key)       { return Proxy(this, key); }
     V     operator[](Key key) const { return this-&gt;read(key); }
     // ...
 };
</code></pre>
