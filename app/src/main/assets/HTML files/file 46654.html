<p>I would probably extend a new Matcher for that, something like that (beware, NPEs lurking):</p>

<pre><code>class SubMapMatcher extends BaseMatcher&lt;Map&lt;?,?&gt;&gt; {

private Object key;
private Object subMapKey;
private Object subMapValue;

public SubMapMatcher(Object key, Object subMapKey, Object subMapValue) {
    super();
    this.key = key;
    this.subMapKey = subMapKey;
    this.subMapValue = subMapValue;
}

@Override
public boolean matches(Object item) {

    Map&lt;?,?&gt; map = (Map&lt;?,?&gt;)item;

    if (!map.containsKey(key)) {
        return false;
    }

    Object o = map.get(key);

    if (!(o instanceof Map&lt;?,?&gt;)) {
        return false;
    }

    Map&lt;?,?&gt; subMap = (Map&lt;?,?&gt;)o;
    return subMap.containsKey(subMapKey) &amp;&amp; subMap.get(subMapKey).equals(subMapValue);
}

@Override
public void describeTo(Description description) {
    description.appendText(String.format("contains %s -&gt; %s : %s", key, subMapKey, subMapValue));
}

public static SubMapMatcher containsSubMapWithKeyValue(String key, String subMapKey, String subMapValue) {
    return new SubMapMatcher(key, subMapKey, subMapValue);
}

}
</code></pre>
