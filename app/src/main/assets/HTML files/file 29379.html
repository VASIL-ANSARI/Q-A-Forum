<p>First of all, the prefix increment operator has this signature: </p>

<pre><code>Iterator&amp; operator++();
</code></pre>

<p>and the postfix should be declared and defined in terms of the prefix in this way: </p>

<pre><code>const Iterator&amp; operator++(int){Iterator old = *this; ++(*this); return old;}
</code></pre>

<p>You probably want the prefix to ask to its node the next (leftmost) node, </p>

<pre><code>Iterator&amp; Iterator::operator++(){
    myParent = mCurrentNode; 
    return  myParent.getRightOf(mCurrentNode); 
}
</code></pre>

<p>You see that I assumed you have a way to construct an iterator from a node you probably should have at least a 
private one. </p>

<p>I suppose you want to iterate through leaf nodes, (anyway the internal nodes implementation is not dissimilar). 
You need a getRightOf method more or less doing the following, let me write down some pseudocode for it: </p>

<pre><code>Node* Node::getRightOf(Node* aNode){ 
    if aNode == mLeftChild{
        if mRightNode
            return mRightNode(this); 
        return mParent(this)
    }
    if aNode == mRightChild{
        return mParent(this)
    }
    if aNode == mParent{
        if mLeftNode
            return mLeftNode(this); 
        if mRightNode
            return mRightNode(this); 
        return this; 
    }
}
</code></pre>

<p>you need some care for managing cases like iterations at the end of the container. </p>

<p><strong>WARNING</strong></p>

<p>In Node's destructor I read: </p>

<pre><code>if ( mParent ) delete mParent;
</code></pre>

<p>this looks dangerous: who deletes the ParentNode? The left or the right child? </p>
