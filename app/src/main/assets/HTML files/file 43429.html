<p>It's expected that the data gets returned long after the request is made (long, relative to nearly instantaneous execution of the next line of code after the send request).  The trick is to defer the update of the UI until the request completes.</p>

<pre><code>// optionally update the UI to say 'busy', e.g. placeholders or activity
// indicators in parts that are incomplete until the response arrives
[NSURLConnection sendAsynchronousRequest:request
                                   queue:[NSOperationQueue mainQueue]
                       completionHandler:^(NSURLResponse *response, NSData *data, NSError *error) {
    // optionally update the UI to say 'done'
    if (!error) {
        NSDictionary *json = [NSJSONSerialization JSONObjectWithData: requestHandler options: NSJSONReadingMutableContainers error: &amp;e];
        // update the UI here (and only here to the extent it depends on the json)
    } else {
        // update the UI to indicate error
    }
}];
</code></pre>

<p>Even more abstractly -- and more correctly -- consider that the data being fetched is likely part of the app's model.  A fetch from the server is just one cause of change to the model.  When the model is changed for any reason, either through user action or this fetch or some other event, it is the view controller's job to observe that it changed, and tell the views to update.</p>
