<p>If you are storing integers, use <code>Long</code>.  Your statement that <em>"Advantage of Using Double is that it gives a more wider range for storing Whole Numbers"</em> is incorrect.  Both are 64 bits long, but <code>double</code> has to use some bits for the exponent, leaving fewer bits to represent the magnitude.  You can store larger numbers in a <code>double</code> but you will lose precision.</p>

<p>In other words, for numbers larger than some upper bound you can no longer store adjacent "whole numbers"... given an integer value above this threshold, the "next" possible <code>double</code> will be more than 1 greater than the previous number.</p>

<p>For example</p>

<pre><code>public class Test1  
{

    public static void main(String[] args) throws Exception 
    {
        long   long1 = Long.MAX_VALUE - 100L;
        double dbl1  = long1;
        long   long2 = long1+1;
        double dbl2  = dbl1+1;
        double dbl3  = dbl2+Math.ulp(dbl2);

        System.out.printf("%d %d\n%f %f %f", long1, long2, dbl1, dbl2, dbl3);
    }

}
</code></pre>

<p>This outputs:</p>

<pre><code>9223372036854775707 9223372036854775708
9223372036854776000.000000 9223372036854776000.000000 9223372036854778000.000000
</code></pre>

<p>Note that</p>

<ol>
<li>The double representation of Long.MAX_VALUE-100 does <strong><em>NOT</em></strong> equal the original value</li>
<li>Adding 1 to the double representation of Long.MAX_VALUE-100 has no effect</li>
<li>At this magnitude, the difference between one double and the next possible double value is 2000.</li>
</ol>

<p>Another way of saying this is that <code>long</code> has just under 19 digits precision, while <code>double</code> has only 16 digits precision.  Double can store numbers larger than 16 digits, but at the cost of truncation/rounding in the low-order digits.</p>

<p>If you need more than 19 digits precision you must resort to <code>BigInteger</code>, with the expected decrease in performance.</p>
