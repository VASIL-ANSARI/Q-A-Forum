<p>There are two bugs is the above algorithm:</p>

<p>The internal <code>counter</code> loop does not increase <code>iStart</code> and <code>iLess</code>. So the second iteration gives <code>1000th</code> array element with zero <code>i</code>. That is why it gives answer <code>1000</code>. <code>iStart</code> and <code>iLess</code> should be increased in that loop:</p>

<pre><code>while (counter &lt; 10 &amp;&amp; success === false) {
    // ...
    iStart += 1000;
    iLess += 1000;
}
</code></pre>

<p>The variable <code>counter</code> is not reset to zero after the full cycle run. So, the maximum probed number is <code>9999</code>. After the <code>while</code> loop <code>counter</code> should be set to zero.</p>

<hr>

<p>Such algorithm is very inefficient. It is able to solve the problem for <code>10</code>. Probably it can be used for <code>15</code>. However, I do not expect to receive the result for <code>20</code> in a reasonable time.</p>

<p>More efficient and quite obvious algorithm may be based on counting prime factors of all numbers in given range (<code>1..20</code>). The maximum count of each unique prime factor for all numbers in range should be multiplied to give the result.
It can be done even better using Euclidean algorithm.</p>
