<p>Here is the code for my <strong>RenderObject</strong> with your <strong>Cube</strong> added as an object to it and my own implemanation of my cube.</p>

<p><a href="http://pastebin.com/Q1WQnFTC" rel="nofollow">XNA RenderObject with 2 types of Cubes</a></p>

<p>And this is my test game for the implementation of this.</p>

<p>You can simple change defaultCube = false, to try with yours. But you should resize it to 0.5, because it should be x start = -0.5f, x end = 0.5f, which is equal to 1 in size. THen you can easily just change the world scale instead.</p>

<p><a href="http://pastebin.com/RqxM2sLM" rel="nofollow">Test game for XNA RenderObject</a></p>

<p>Since none of the above works, or because it's possible that something else in your code is hindering performance I made an example that I've used for an earlier engine.</p>

<p>To minimalize the amount of data of each object I simply create an abstract class that can handle just about any type of vertex, so you can create a color cube, normal cube, textured cube and so on.</p>

<p>First of all I have an RenderObject that stores all the fields required by a object to rendered; VertexBuffer, IndexBuffer, World matrix, BoundingBox.</p>

<p>And then I create a specific class that handles each type, Normal, Color, Texture. In this case I just included a version of the PrimitiveColor, which creates a Color render object.</p>

<p>You can even further extend this to instead of just a PrimitiveColor class, it can be a Cube class that only takes a type (Color/Normal/Texture) and you can minimalize your code for creating different types of cube, because in this case a cube will always be cube with 36 vertices and 6 faces. It's static.</p>

<p>Anyway, this is not required. But like any game programming or object oriented programming, a good structure is important and increases the workflow. And recreating the same properties for 100 of classes isn't that much fun. And this makes it easier to debug and find errors.</p>

<p>So, to simplify: RenderObject -> PrimitiveColor/PrimitiveNormal -> ColorCube / ColorNormal, you can then work with the cube instead of the rest.</p>

<p>I have no idea if you render "one" cube or a thousand cubes. But in my case I rendered 50*50 cubes and I had to use a frustum to cull for cubes within view of the camera to not get reduced performance. If you do this and it's still not working it's possible the error lies in another code.</p>

<p>This, I think is an optimal way to handle this. Because each rendered object share a buffer, a matrix and perhaps a render method (not always necessarily) and this way you can only work on the code that matters - creating the cube. It does not recreate any effects, it does not recreate any buffers after they've been initialized (although they can be changed rather quickly in the update method - I've done this with a terrain, just remember to dispose the old vertexbuffer before changing say a color in the vertices and then recreate the buffer)</p>

<p>My Cube, scaled correctly. Adds a white, black, white, black cube to see where they start and end.
<img src="http://i.stack.imgur.com/VBbCb.png" alt="enter image description here"></p>

<p>Your Cube, scaled incorrectly. Adds your default colors.
<img src="http://i.stack.imgur.com/0YpDt.png" alt="enter image description here"></p>

<p>But the important thing is that the framerate is not at fault before skipping to frustum cull the cubes. If you don't do this, it will cause framedrop. But if you only draw one cube, this should not happen.</p>
