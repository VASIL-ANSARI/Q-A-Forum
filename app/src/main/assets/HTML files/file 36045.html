<p>UI properties may only be modified on the JavaFX application thread. In your example, the generated properties live on 5 different threads, while <code>pieValueProperty()</code> of <code>PieChart.Data</code> may only be modified on the JavaFX application thread.</p>

<p>Here is a working solution, using <a href="https://github.com/TomasMikula/ReactFX" rel="nofollow">ReactFX</a> event streams as data sources.</p>

<pre><code>import java.time.Duration;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

import javafx.application.Application;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.scene.Scene;
import javafx.scene.chart.PieChart;
import javafx.stage.Stage;

import org.reactfx.EventStream;
import org.reactfx.EventStreams;

class ChartData {
    private final ScheduledExecutorService scheduler =
            Executors.newSingleThreadScheduledExecutor();
    private final Executor executor = scheduler;

    EventStream&lt;Double&gt; pieProp1 = randomDoubleStream();
    EventStream&lt;Double&gt; pieProp2 = randomDoubleStream();
    EventStream&lt;Double&gt; pieProp3 = randomDoubleStream();
    EventStream&lt;Double&gt; pieProp4 = randomDoubleStream();
    EventStream&lt;Double&gt; pieProp5 = randomDoubleStream();

    private EventStream&lt;Double&gt; randomDoubleStream() {
        return EventStreams.ticks(Duration.ofMillis(100), scheduler, executor)
                .supply(() -&gt; Math.random() * 30)
                .threadBridgeToFx(executor);
    }

    public void dispose() {
        scheduler.shutdown();
    }
}

public class AsyncChart extends Application {

    @Override
    public void start(Stage s){
        PieChart pc = new PieChart();
        ObservableList&lt;PieChart.Data&gt; chartData = FXCollections.observableArrayList();
        chartData.add(new PieChart.Data("Dat1", 0.0));
        chartData.add(new PieChart.Data("Dat2", 0.0));
        chartData.add(new PieChart.Data("Dat3", 0.0));
        chartData.add(new PieChart.Data("Dat4", 0.0));
        chartData.add(new PieChart.Data("Dat5", 0.0));
        pc.setLegendVisible(false);

        ChartData cd = new ChartData();
        cd.pieProp1.feedTo(chartData.get(0).pieValueProperty());
        cd.pieProp2.feedTo(chartData.get(1).pieValueProperty());
        cd.pieProp3.feedTo(chartData.get(2).pieValueProperty());
        cd.pieProp4.feedTo(chartData.get(3).pieValueProperty());
        cd.pieProp5.feedTo(chartData.get(4).pieValueProperty());

        pc.setData(chartData);

        Scene sc = new Scene(pc);

        s.setScene(sc);
        s.setOnHidden(evt -&gt; cd.dispose());
        s.show();
    }

    public static void main (String[] args){
        launch(args);
    }
}
</code></pre>

<p>There are two important things to note about this code:</p>

<ol>
<li><p><code>executor</code> is a <em>single thread</em> executor. This is important, because just as JavaFX properties, ReactFX event streams are designed to be accessed from a single thread only. If you wanted the five streams to be generated by 5 different threads, you would need five <em>single thread</em> executors, one to generate each stream.</p></li>
<li><p>Note the <code>threadBridgeToFx(executor)</code> line. This returns a stream that mirrors the original stream (accessed from <code>executor</code>'s thread), but can be accessed from (and only from) the JavaFX application thread.</p></li>
</ol>
