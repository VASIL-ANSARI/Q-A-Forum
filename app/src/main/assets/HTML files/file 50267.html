<p>So, if I understand correctly, you want to create a new list containing all the users of <code>usersB</code>, except those that have the same name as any of the users in <code>usersA</code>, right?</p>

<p>First of all, I would change the strategy: instead of adding all the users, then removing some, I would only add the users that belong to the list in the first place.</p>

<p>And in Java 8, that can be done with</p>

<pre><code>List&lt;User&gt; result = 
    usersB.stream()
          .filter(u -&gt; !userNameIn(u, usersA))
          .collect(Collectors.toList());
</code></pre>

<p>with <code>userNameIn</code> defined as</p>

<pre><code>private boolean userNameIn(User u, List&lt;User&gt; users) {
    return users.stream().anyMatch(user -&gt; user.getName().equalsIgnoreCase(u.getName()));
}
</code></pre>

<p>That won't be very efficient if <code>usersA</code> contains a large number of users. A more efficient solution would be to store all the lowercase names of <code>usersA</code> in a HashSet, and replace the method with</p>

<pre><code>List&lt;User&gt; result = 
    usersB.stream()
          .filter(u -&gt; !lowercaseNames.contains(u.getName().toLowerCase()))
          .collect(Collectors.toList());
</code></pre>
