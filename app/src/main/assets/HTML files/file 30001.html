<p>Your class <code>Prot</code> needs to override the <code>Object.Equals()</code> method. This is how <code>List&lt;T&gt;.Remove</code> works. From the documentation:</p>

<blockquote>
  <p>If type <code>T</code> implements the <code>IEquatable&lt;T&gt;</code> generic interface, the equality comparer is the Equals method of that interface; otherwise, the default equality comparer is <code>Object.Equals</code>. </p>
</blockquote>

<p>If you don't override <code>Object.Equals</code> it will just use the default implementation which checks for reference equality, not value equality.</p>

<p>So, <code>temp.Remove(prot);</code> was never removing any values. (This can be validated based on the return value of <code>Remove</code>. It returns <code>true</code> if it successfully removes a value, and <code>false</code> otherwise.</p>

<p>Here's a basic example: <a href="http://ideone.com/vOZoYI" rel="nofollow">http://ideone.com/vOZoYI</a> </p>

<hr>

<p>Initial Answer (issue was a typo in question).</p>

<p>You are modifying a new object, a <code>List&lt;Prot&gt;</code>, not the <code>Prot[]</code> parameter. If you assign <code>pack</code> to the <code>List&lt;Prot&gt;.ToArray()</code> then it will remove it from the array passed in.</p>

<pre><code>public static void Delete(ref Prot[] pack, Prot prot)
{
    var temp = new List&lt;Prot&gt;(pack);
    temp.Remove(prot);
    pack = temp.ToArray();
}
</code></pre>
