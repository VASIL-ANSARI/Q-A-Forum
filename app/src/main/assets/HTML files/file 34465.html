<p>You declare your arrays as follows:</p>

<pre><code>//declare array's
int secondsArray[seconds];
float heightWatermelonArray[seconds];
</code></pre>

<p>Then access in the following loop:</p>

<pre><code>for (count = 0; count &lt;= seconds; count++)
</code></pre>

<p>When you declare an array of length <code>seconds</code>, this allocates an array with <code>seconds</code> number of elements. Because arrays are zero-indexed, this means that the indices <code>0..(seconds-1)</code> are valid. Your loop will go from <code>0..seconds</code>, hence will cause an overflow. To fix, simply change the <code>&lt;=</code> to <code>&lt;</code>.</p>

<p>The other solution is to resize your arrays as Zeta says below. In this case, just change your array specification to the following:</p>

<pre><code>//declare array's
int secondsArray[seconds+1];
float heightWatermelonArray[seconds+1];
</code></pre>

<p>You're then probably wondering why you get a weird number instead of zero there. Because on x86 (I assume you're on x86), the stack grows downwards, <code>heightWatermelonArray</code> will be directly <em>before</em> <code>secondsArray</code> in memory. When you write to <code>heightWatermelonArray[seconds]</code> (i.e off the end of <code>heightWatermelonArray</code>, you overflow the array, then go to the next bit of memory. In this case, that memory will be the first element of <code>secondsArray</code>, and so you corrupt memory.</p>
