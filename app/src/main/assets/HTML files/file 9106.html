<p>You can't just use <code>volatile</code> like that to make code thread-safe. Volatile helps with single-threaded apps that map variables to external devices by ensuring the value is always re-read but for threads it is insufficient as not only can statements be reordered by the compiler but instructions can be reordered by the processor. You should use a proper multithreading primitive for this, either supplied by a library, or a compiler specific implementation (eg. Interlocked functions on Win32, or the Atomic Builtins on gcc). Similarly it's not clear that any of your other data structures are safe for multi-threaded modification.</p>

<p>As for performance, it's hard to tell what the problem is because we don't know anything about your graph structure and your code is too abstract to work out much about it. However, you seem to spend a lot of time iterating through links that may or may not have been processed yet. Ideally you'd do that the other way around and start by processing a link that has no dependencies, then when it's done, start on the links that depended on this one, and so on, meaning there is no waiting. Perhaps something like a topological sort would help here.</p>
