<p>The quick answer is, use <code>.filter()</code> to select the rows you want, e.g.:</p>

<pre><code>d3.csv("data.csv", function(csv) {
    csv = csv.filter(function(row) {
        return row['Class'] == 'Second Class' || row['Class'] == 'First Class';
    })
    vis.datum(csv).call(chart);
});
</code></pre>

<p>This is easy if you, the coder, are choosing the filters. If you need this to be chosen by user interaction, however, you're going to need to build out a more complex function. Assuming that you have saved the user choices in an object called <code>filters</code>, with keys corresponding to your rows, one option might look like:</p>

<pre><code>// an example filters object
var filters = {
    'Class': ['First Class', 'Second Class'],
    'Sex': 'Female'
};

d3.csv("data.csv", function(csv) {
    csv = csv.filter(function(row) {
        // run through all the filters, returning a boolean
        return ['Class','Age','Sex','Survived'].reduce(function(pass, column) {
            return pass &amp;&amp; (
                // pass if no filter is set
                !filters[column] ||
                    // pass if the row's value is equal to the filter
                    // (i.e. the filter is set to a string)
                    row[column] === filters[column] ||
                    // pass if the row's value is in an array of filter values
                    filters[column].indexOf(row[column]) &gt;= 0
                );
        }, true);
    })
    console.log(csv.length, csv);
});
</code></pre>

<p>(You don't have to do this with <code>.reduce()</code>, but I like how clean it is.)</p>

<p>If, as is probably the case, you don't want to do this filtering at load time, but instead filter dynamically depending on user input, you can still use the filter function, but you'll want to store <code>csv</code> in memory somewhere and filter it on the fly, perhaps in an <code>update()</code> function triggered by user interactions.</p>
