<p>(It looks like you have a stray <code>}</code>, but that's not relevant to the answer)</p>

<p>In your function <code>int* createEnvironment(int width, int height, int numOfX)</code>, when you do <code>char array[width][height];</code>, you allocate a width x height block of memory in the stack. Your then use a few for loops that fill in the X's in certain spots. That all looks fine.</p>

<p>The problem is that <code>array</code> is allocated on the stack. Once <code>createEnvironment</code> returns, all of the variables that were placed on the stack will no longer be valid, since those areas of memory might be used by subsequent function calls. An easier way to think about this is to consider where each variable 'lives' within the program. Global variables live in the program and can be accessed by anyone. Variables that live in main can be accessed in main, and in functions that are called by main (i.e. with pointers). However, if you call function A from main, which has some variable V declared, and then call function B from main, B cannot access V, since V only lived in main. The solution to this problem would be to pass V back to main to be sent to B.</p>

<p>Fortunately, the C standard library provides <a href="http://www.cplusplus.com/reference/cstdlib/malloc/" rel="nofollow"><code>malloc</code></a>, which allocates memory off the heap, not the stack. When you allocate memory in the heap, it live in the heap regardless of which context it is created from. If function A creates variable V in the heap with <code>malloc</code>, then V can be accessed from main, B, or any other function, so long as a pointer to V is provided. This is also where memory leaks come from; when space is allocated from the heap, if it is not freed with <code>free</code>, then it stays allocated until the program ends.</p>

<p>The short answer is to replace the line <code>char array[width][height];</code> with <code>char * array = malloc(width * height * sizeof(char));</code>. Not that the <code>sizeof</code> isn't strictly necessary since a char is one byte in size, but that would need to be changed if you changed <code>char</code> to some other type.</p>

<p>You'll also need to update the way you access a sub-element of the array. Since the width and height of the array won't be known if it's in the heap, you'll have to instead provide an offset from array, which should give you a clue how arrays work in C to begin with. I'll leave that for you to figure out.</p>
