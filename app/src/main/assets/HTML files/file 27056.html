<p>Since each of the element in the original array are considered unique even when they have the same value, the problem can be treated in this way: For each element in the array, you have two choices: including it or not including it in the set. Therefore each element doubles the number of solutions, resulting the overall number of solutions: 2 * 2 * 2 ... * 2 - 1 = 2^n - 1. Minus one is because you are excluding empty set from the solutions. Since the number of solutions is 2^n - 1, the complexity of your algorithm cannot be better than O(2^n). The only improvement you can do is probably write the algorithm in a way that is more compact or easier to understand.</p>

<p>I have the following code that I think is more straightforward. I have not tested so there might be bugs.</p>

<pre><code>// Generate unique sets in the range [k..n) of the input arr. With elements
// from [0..k) already in the prefix.
void Unique(int[] arr, int k, List&lt;int&gt; prefix, List&lt;int[]&gt; solutions)
{
    // Got a solution when we reached the end of array.
    if (k == arr.Length)
    {
        if (prefix.Length &gt; 0)
            solutions.Add(prefix.ToArray());
        return;
    }

    // Exclude arr[k]
    Unique(arr, k + 1, prefix, solutions);

    // Include arr[k]
    prefix.Add(arr[k]);
    Unique(arr, k + 1, prefix, solutions);
    prefix.Remove(arr[k]); // Restore the prefix list
}

List&lt;int[]&gt; Unique(int[] arr)
{
    List&lt;int[]&gt; solutions = new List&lt;int[]&gt;();
    Unique(arr, 0, new List&lt;int&gt;(), List&lt;int[]&gt; solutions);
    return solutions;
}
</code></pre>
