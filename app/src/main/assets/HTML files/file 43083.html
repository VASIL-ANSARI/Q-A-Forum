<p>Under C++11 rules, <code>B</code> is not an aggregate type. C++11 [dcl.init.aggr]/1:</p>

<blockquote>
  <p>An <em>aggregate</em> is an array or a class (Clause 9) with no user-provided constructors (12.1), <strong>no <em>brace-or-equal-initializers</em> for non-static data members</strong> (9.2), no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>
</blockquote>

<p><code>B</code> only has a default constructor, and thus cannot be initialized from the <em>braced-initializer-list</em> <code>{2}</code>. </p>

<p>C++14 allows <em>brace-or-equal-initializers</em> for non-static data members in an aggregate. N4140 [dcl.init.aggr]/1:</p>

<blockquote>
  <p>An <em>aggregate</em> is an array or a class (Clause 9) with no user-provided constructors (12.1), no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>
</blockquote>

<p>With fairly straight-forward semantics: fields for which there is no initializer specified are initialized from their <em>brace-or-equal-initializer</em>, if any, and otherwise initialized with <code>{}</code> [dcl.init.aggr]/7:</p>

<blockquote>
  <p>If there are fewer <em>initializer-clauses</em> in the list than there are members in the aggregate, then each member not explicitly initialized shall be initialized from its <em>brace-or-equal-initializer</em> or, if there is no <em>brace-or-equal-initializer</em>, from an empty initializer list (8.5.4).</p>
</blockquote>

<p>Your program is thus valid C++14 (<a href="http://melpon.org/wandbox/permlink/IoUviio8T4DOUqUY" rel="nofollow"><strong>DEMO</strong></a>). Essentially, the prohibition of <em>brace-or-equal-initializer</em>s in C++11 was a mistake that C++14 corrected.</p>
