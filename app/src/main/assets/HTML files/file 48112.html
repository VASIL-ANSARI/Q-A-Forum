<p>The problem is that you have:</p>

<pre><code>uint16_t x;
</code></pre>

<p>but then you try to write to that memory location as if it were the location of <code>unsigned</code>.</p>

<p>If you were on a system where <code>unsigned</code> and <code>uint16_t</code> are the same type, this is fine. But on other systems, such as the one you used for your code sample, you are in trouble.</p>

<p>First of all, this causes <a href="http://stackoverflow.com/a/4105123/1505939">undefined behaviour</a> by violating the <a href="http://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule">strict aliasing rule</a>. Variables of type <code>uint16_t</code> may only be written to through lvalues of type <code>uint16_t</code>, or a character type.</p>

<p>But even if it did not violate strict aliasing, you would still cause UB by writing outside the bounds of <code>x</code>. Probably, you are writing 4 or 8 bytes into a 2-byte memory location, so it will overflow the buffer.</p>

<p>There could also be UB if <code>x</code> is not correctly <a href="http://www.ibm.com/developerworks/library/pa-dalign/" rel="nofollow">aligned</a> for <code>unsigned</code>.</p>
